{
  "conversation_id": "558aa7cf-9cac-4a08-b417-6226b4eabdcc",
  "next_message": null,
  "history": [
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "Prompt": {
            "prompt": "what messages i recently got on whatsapp ?"
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "498d6322-fded-4d18-a2da-6882afbb255e",
          "content": "I'll check your recent WhatsApp messages for you.",
          "tool_uses": [
            {
              "id": "tooluse_iYFpwelKQ4GsFw9H7aQlvQ",
              "name": "whatsapp_indexer___get_messages_by_date",
              "orig_name": "whatsapp_indexer___get_messages_by_date",
              "args": {
                "date_query": "today"
              },
              "orig_args": {
                "date_query": "today"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_iYFpwelKQ4GsFw9H7aQlvQ",
                "content": [
                  {
                    "Json": {
                      "content": [
                        {
                          "type": "text",
                          "text": "WhatsApp client is not ready yet. Please wait for authentication to complete."
                        }
                      ]
                    }
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "30295f5f-301f-472a-b1cf-b24fc3ca95da",
          "content": "It looks like your WhatsApp client isn't authenticated yet. Let me check the status:",
          "tool_uses": [
            {
              "id": "tooluse_X22GPZpkS4q2cZNf0RU5tA",
              "name": "whatsapp_indexer___whatsapp_status",
              "orig_name": "whatsapp_indexer___whatsapp_status",
              "args": {},
              "orig_args": {}
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_X22GPZpkS4q2cZNf0RU5tA",
                "content": [
                  {
                    "Json": {
                      "content": [
                        {
                          "type": "text",
                          "text": "WhatsApp Client Status: Not ready (authenticating or disconnected)"
                        }
                      ]
                    }
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "Response": {
          "message_id": "7b05bd2d-50ac-4ffa-a3be-b110401e905f",
          "content": "Your WhatsApp client is currently not ready - it's either still authenticating or disconnected. You'll need to authenticate your WhatsApp session first before I can retrieve your messages.\n\nTo set up WhatsApp access, you would typically need to:\n1. Ensure the WhatsApp indexer service is running\n2. Complete the authentication process (usually involves scanning a QR code with your phone)\n3. Wait for the connection to be established\n\nOnce the WhatsApp client is authenticated and ready, I'll be able to help you check your recent messages. Would you like me to try checking the status again in a moment, or do you need help with setting up the WhatsApp connection?"
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "Prompt": {
            "prompt": "the mcp server should not depened on the whats up client, it shouild pnly relay on the vector index and the service that listens to the whatsapp messages and updates the index will run seperatly , change the code accordingly. "
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "0aa1540d-23d5-417e-880c-ccfb94b5504b",
          "content": "You're absolutely right! The MCP server should be decoupled from the WhatsApp client and only interact with the vector index. The WhatsApp message listening and indexing should be a separate service. Let me examine the current code structure and refactor it accordingly.",
          "tool_uses": [
            {
              "id": "tooluse_yrlj4dYAR_6v7TZCZUTtSw",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "path": ".",
                "mode": "Directory"
              },
              "orig_args": {
                "path": ".",
                "mode": "Directory"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_yrlj4dYAR_6v7TZCZUTtSw",
                "content": [
                  {
                    "Text": "drwxr-xr-x 16 503 20 512 Jul 27 13:27 ./whatsapp-indexer\n-rw-r--r-- 1 503 20 401570 Jul 27 14:01 ./1"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "a6244ee1-3b17-4270-b5f2-2bd20b7ef70a",
          "content": "",
          "tool_uses": [
            {
              "id": "tooluse_XApkgWA5TmCYE1lL-1A07w",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Directory",
                "path": "./whatsapp-indexer"
              },
              "orig_args": {
                "mode": "Directory",
                "path": "./whatsapp-indexer"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_XApkgWA5TmCYE1lL-1A07w",
                "content": [
                  {
                    "Text": "drwxr-xr-x 4 503 20 128 Jul 27 13:28 ./whatsapp-indexer/.wwebjs_cache\ndrwxr-xr-x 255 503 20 8160 Jul 27 13:19 ./whatsapp-indexer/node_modules\n-rw-r--r-- 1 503 20 6846 Jul 27 13:19 ./whatsapp-indexer/README.md\n-rw-r--r-- 1 503 20 1142 Jul 27 13:10 ./whatsapp-indexer/.gitignore\n-rw-r--r-- 1 503 20 115923 Jul 27 13:19 ./whatsapp-indexer/package-lock.json\n-rw-r--r-- 1 503 20 931 Jul 27 13:18 ./whatsapp-indexer/package.json\n-rw-r--r-- 1 503 20 202 Jul 27 13:19 ./whatsapp-indexer/.env\ndrwxr-xr-x 3 503 20 96 Jul 27 13:20 ./whatsapp-indexer/.wwebjs_auth\ndrwxr-xr-x 3 503 20 96 Jul 27 13:18 ./whatsapp-indexer/scripts\n-rwxr-xr-x 1 503 20 231 Jul 27 13:12 ./whatsapp-indexer/start-mcp.sh\n-rw-r--r-- 1 503 20 202 Jul 27 13:16 ./whatsapp-indexer/.env.example\n-rwxr-xr-x 1 503 20 391 Jul 27 13:20 ./whatsapp-indexer/start-indexer.sh\ndrwxr-xr-x 4 503 20 128 Jul 27 13:54 ./whatsapp-indexer/data\ndrwxr-xr-x 9 503 20 288 Jul 27 13:18 ./whatsapp-indexer/src"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "42774a85-d72f-437c-903c-4360a27fc7a4",
          "content": "",
          "tool_uses": [
            {
              "id": "tooluse_1QPi12ioQBSZ3HHsKooqkw",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Directory",
                "path": "./whatsapp-indexer/src"
              },
              "orig_args": {
                "mode": "Directory",
                "path": "./whatsapp-indexer/src"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_1QPi12ioQBSZ3HHsKooqkw",
                "content": [
                  {
                    "Text": "-rw-r--r-- 1 503 20 5465 Jul 27 13:07 ./whatsapp-indexer/src/database.js\n-rw-r--r-- 1 503 20 6971 Jul 27 14:00 ./whatsapp-indexer/src/whatsapp-client.js\n-rw-r--r-- 1 503 20 5282 Jul 27 13:24 ./whatsapp-indexer/src/message-processor.js\n-rw-r--r-- 1 503 20 852 Jul 27 13:09 ./whatsapp-indexer/src/index.js\n-rw-r--r-- 1 503 20 688 Jul 27 13:17 ./whatsapp-indexer/src/config.js\n-rw-r--r-- 1 503 20 16009 Jul 27 14:00 ./whatsapp-indexer/src/mcp-server.js\n-rw-r--r-- 1 503 20 10289 Jul 27 13:26 ./whatsapp-indexer/src/local-vector-store.js"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "5081ca79-8243-4b67-9f39-f821b40a6966",
          "content": "Let me examine the current MCP server implementation to understand how it's coupled with the WhatsApp client:",
          "tool_uses": [
            {
              "id": "tooluse_UqGrxak7SdiBNAucUY_4ug",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/mcp-server.js"
              },
              "orig_args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/mcp-server.js"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_UqGrxak7SdiBNAucUY_4ug",
                "content": [
                  {
                    "Text": "import { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport WhatsAppClient from './whatsapp-client.js';\nimport * as chrono from 'chrono-node';\n\nclass WhatsAppMCPServer {\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'whatsapp-indexer',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n    \n    this.whatsappClient = new WhatsAppClient();\n    this.setupTools();\n  }\n\n  setupTools() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => {\n      return {\n        tools: [\n          {\n            name: 'whatsapp_status',\n            description: 'Check the status of the WhatsApp client connection',\n            inputSchema: {\n              type: 'object',\n              properties: {},\n            },\n          },\n          {\n            name: 'search_messages',\n            description: 'Search WhatsApp messages using natural language queries. Supports semantic search and filters by sender, date, and content type.',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                query: {\n                  type: 'string',\n                  description: 'Natural language search query (e.g., \"get me the url Roni sent me for the thai restaurant\")',\n                },\n                limit: {\n                  type: 'number',\n                  description: 'Maximum number of results to return (default: 10)',\n                  default: 10,\n                },\n              },\n              required: ['query'],\n            },\n          },\n          {\n            name: 'get_urls_by_sender',\n            description: 'Get all URLs shared by a specific person',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                sender_name: {\n                  type: 'string',\n                  description: 'Name of the person who sent the URLs',\n                },\n                limit: {\n                  type: 'number',\n                  description: 'Maximum number of URLs to return (default: 20)',\n                  default: 20,\n                },\n              },\n              required: ['sender_name'],\n            },\n          },\n          {\n            name: 'get_messages_by_date',\n            description: 'Get messages from a specific date or date range',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                date_query: {\n                  type: 'string',\n                  description: 'Date or date range in natural language (e.g., \"today\", \"this week\", \"last Monday\", \"January 15\")',\n                },\n                sender_name: {\n                  type: 'string',\n                  description: 'Optional: filter by specific sender',\n                },\n              },\n              required: ['date_query'],\n            },\n          },\n          {\n            name: 'find_schedule_with_person',\n            description: 'Find scheduling-related messages with a specific person',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                person_name: {\n                  type: 'string',\n                  description: 'Name of the person to find scheduling messages with',\n                },\n                time_period: {\n                  type: 'string',\n                  description: 'Time period to search (e.g., \"this week\", \"next week\", \"today\")',\n                  default: 'this week',\n                },\n              },\n              required: ['person_name'],\n            },\n          },\n          {\n            name: 'check_plans_for_day',\n            description: 'Check if there are any plans or appointments for a specific day',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                day: {\n                  type: 'string',\n                  description: 'Day to check for plans (e.g., \"Wednesday\", \"tomorrow\", \"January 20\")',\n                },\n              },\n              required: ['day'],\n            },\n          },\n        ],\n      };\n    });\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const { name, arguments: args } = request.params;\n\n      try {\n        switch (name) {\n          case 'whatsapp_status':\n            return await this.handleWhatsAppStatus(args);\n          \n          case 'search_messages':\n            return await this.handleSearchMessages(args);\n          \n          case 'get_urls_by_sender':\n            return await this.handleGetUrlsBySender(args);\n          \n          case 'get_messages_by_date':\n            return await this.handleGetMessagesByDate(args);\n          \n          case 'find_schedule_with_person':\n            return await this.handleFindScheduleWithPerson(args);\n          \n          case 'check_plans_for_day':\n            return await this.handleCheckPlansForDay(args);\n          \n          default:\n            throw new Error(`Unknown tool: ${name}`);\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error.message}`,\n            },\n          ],\n        };\n      }\n    });\n  }\n\n  async handleWhatsAppStatus(args) {\n    const status = this.whatsappClient.isReady ? 'Connected and ready' : 'Not ready (authenticating or disconnected)';\n    \n    return {\n      content: [\n        {\n          type: 'text',\n          text: `WhatsApp Client Status: ${status}`,\n        },\n      ],\n    };\n  }\n\n  async handleSearchMessages(args) {\n    if (!this.whatsappClient.isReady) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: 'WhatsApp client is not ready yet. Please wait for authentication to complete.',\n          },\n        ],\n      };\n    }\n\n    const { query, limit = 10 } = args;\n    \n    const results = await this.whatsappClient.searchMessages(query, { limit });\n    \n    if (results.results.length === 0) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `No messages found for query: \"${query}\"`,\n          },\n        ],\n      };\n    }\n\n    const formattedResults = results.results.map(msg => {\n      const date = new Date(msg.timestamp).toLocaleString();\n      const urls = msg.urls ? msg.urls.split('|').join(', ') : '';\n      \n      return `**From:** ${msg.senderName || msg.sender_name}\n**Date:** ${date}\n**Message:** ${msg.content}\n${urls ? `**URLs:** ${urls}` : ''}\n**Relevance Score:** ${msg.relevanceScore?.toFixed(3) || 'N/A'}\n---`;\n    }).join('\\n\\n');\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${results.results.length} messages for \"${query}\":\\n\\n${formattedResults}`,\n        },\n      ],\n    };\n  }\n\n  async handleGetUrlsBySender(args) {\n    if (!this.whatsappClient.isReady) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: 'WhatsApp client is not ready yet. Please wait for authentication to complete.',\n          },\n        ],\n      };\n    }\n\n    const { sender_name, limit = 20 } = args;\n    \n    const urls = await this.whatsappClient.getUrlsBySender(sender_name, limit);\n    \n    if (urls.length === 0) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `No URLs found from ${sender_name}`,\n          },\n        ],\n      };\n    }\n\n    const formattedUrls = urls.map(urlData => {\n      const date = new Date(urlData.timestamp).toLocaleString();\n      return `**URL:** ${urlData.url}\n**Domain:** ${urlData.domain || 'Unknown'}\n**Date:** ${date}\n**Context:** ${urlData.content.substring(0, 100)}...\n---`;\n    }).join('\\n\\n');\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${urls.length} URLs from ${sender_name}:\\n\\n${formattedUrls}`,\n        },\n      ],\n    };\n  }\n\n  async handleGetMessagesByDate(args) {\n    if (!this.whatsappClient.isReady) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: 'WhatsApp client is not ready yet. Please wait for authentication to complete.',\n          },\n        ],\n      };\n    }\n\n    const { date_query, sender_name } = args;\n    \n    // Parse the date query\n    const parsedDates = chrono.parse(date_query);\n    if (parsedDates.length === 0) {\n      throw new Error(`Could not parse date: \"${date_query}\"`);\n    }\n\n    const date = parsedDates[0].start.date();\n    const startOfDay = new Date(date);\n    startOfDay.setHours(0, 0, 0, 0);\n    const endOfDay = new Date(date);\n    endOfDay.setHours(23, 59, 59, 999);\n\n    const messages = await this.whatsappClient.getMessagesByDateRange(\n      startOfDay.getTime(),\n      endOfDay.getTime(),\n      sender_name\n    );\n\n    if (messages.length === 0) {\n      const senderText = sender_name ? ` from ${sender_name}` : '';\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `No messages found${senderText} for ${date_query}`,\n          },\n        ],\n      };\n    }\n\n    const formattedMessages = messages.map(msg => {\n      const time = new Date(msg.timestamp).toLocaleTimeString();\n      const urls = msg.urls ? ` [URLs: ${msg.urls}]` : '';\n      \n      return `**${time} - ${msg.sender_name}:** ${msg.content}${urls}`;\n    }).join('\\n');\n\n    const senderText = sender_name ? ` from ${sender_name}` : '';\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${messages.length} messages${senderText} for ${date_query}:\\n\\n${formattedMessages}`,\n        },\n      ],\n    };\n  }\n\n  async handleFindScheduleWithPerson(args) {\n    if (!this.whatsappClient.isReady) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: 'WhatsApp client is not ready yet. Please wait for authentication to complete.',\n          },\n        ],\n      };\n    }\n\n    const { person_name, time_period = 'this week' } = args;\n    \n    // Create a search query that looks for scheduling-related messages\n    const schedulingQuery = `${person_name} meet meeting schedule appointment plan when time`;\n    \n    // Parse time period to get date range\n    const parsedDates = chrono.parse(time_period);\n    let dateRange = null;\n    \n    if (parsedDates.length > 0) {\n      const date = parsedDates[0].start.date();\n      // For \"this week\", create a week range\n      if (time_period.toLowerCase().includes('week')) {\n        const startOfWeek = new Date(date);\n        startOfWeek.setDate(date.getDate() - date.getDay());\n        startOfWeek.setHours(0, 0, 0, 0);\n        \n        const endOfWeek = new Date(startOfWeek);\n        endOfWeek.setDate(startOfWeek.getDate() + 6);\n        endOfWeek.setHours(23, 59, 59, 999);\n        \n        dateRange = {\n          start: startOfWeek.getTime(),\n          end: endOfWeek.getTime(),\n        };\n      }\n    }\n\n    const results = await this.whatsappClient.searchMessages(schedulingQuery, {\n      limit: 20,\n    });\n\n    // Filter results for the specific person and scheduling content\n    const schedulingMessages = results.results.filter(msg => {\n      const senderMatch = msg.senderName?.toLowerCase().includes(person_name.toLowerCase()) ||\n                         msg.sender_name?.toLowerCase().includes(person_name.toLowerCase());\n      const contentMatch = /\\b(meet|meeting|schedule|appointment|plan|when|time|tomorrow|today|monday|tuesday|wednesday|thursday|friday|saturday|sunday)\\b/i.test(msg.content);\n      \n      return senderMatch && contentMatch;\n    });\n\n    if (schedulingMessages.length === 0) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `No scheduling messages found with ${person_name} for ${time_period}`,\n          },\n        ],\n      };\n    }\n\n    const formattedMessages = schedulingMessages.map(msg => {\n      const date = new Date(msg.timestamp).toLocaleString();\n      return `**${date} - ${msg.senderName || msg.sender_name}:** ${msg.content}`;\n    }).join('\\n\\n');\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${schedulingMessages.length} scheduling-related messages with ${person_name} for ${time_period}:\\n\\n${formattedMessages}`,\n        },\n      ],\n    };\n  }\n\n  async handleCheckPlansForDay(args) {\n    if (!this.whatsappClient.isReady) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: 'WhatsApp client is not ready yet. Please wait for authentication to complete.',\n          },\n        ],\n      };\n    }\n\n    const { day } = args;\n    \n    // Parse the day\n    const parsedDates = chrono.parse(day);\n    if (parsedDates.length === 0) {\n      throw new Error(`Could not parse day: \"${day}\"`);\n    }\n\n    const date = parsedDates[0].start.date();\n    const startOfDay = new Date(date);\n    startOfDay.setHours(0, 0, 0, 0);\n    const endOfDay = new Date(date);\n    endOfDay.setHours(23, 59, 59, 999);\n\n    // Search for plan-related messages on that day\n    const planQuery = 'plan plans meeting appointment schedule busy free available';\n    \n    const results = await this.whatsappClient.searchMessages(planQuery, {\n      limit: 50,\n    });\n\n    // Filter for messages on the specific day that mention plans\n    const dayPlans = results.results.filter(msg => {\n      const messageDate = new Date(msg.timestamp);\n      const isOnDay = messageDate >= startOfDay && messageDate <= endOfDay;\n      const hasPlanContent = /\\b(plan|plans|meeting|appointment|schedule|busy|free|available)\\b/i.test(msg.content);\n      \n      return isOnDay && hasPlanContent;\n    });\n\n    if (dayPlans.length === 0) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `No plans found for ${day}`,\n          },\n        ],\n      };\n    }\n\n    const formattedPlans = dayPlans.map(msg => {\n      const time = new Date(msg.timestamp).toLocaleTimeString();\n      return `**${time} - ${msg.senderName || msg.sender_name}:** ${msg.content}`;\n    }).join('\\n\\n');\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${dayPlans.length} plan-related messages for ${day}:\\n\\n${formattedPlans}`,\n        },\n      ],\n    };\n  }\n\n  async start() {\n    console.log('🚀 Starting WhatsApp MCP Server...');\n    \n    // Start MCP server first\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    \n    console.log('✅ WhatsApp MCP Server is running');\n    \n    // Initialize WhatsApp client in background (non-blocking) with timeout\n    Promise.race([\n      this.whatsappClient.initialize(),\n      new Promise((_, reject) => \n        setTimeout(() => reject(new Error('WhatsApp initialization timeout')), 30000)\n      )\n    ]).catch(error => {\n      console.error('❌ Failed to initialize WhatsApp client:', error);\n      console.log('💡 MCP server will continue running. WhatsApp tools will show \"not ready\" status.');\n    });\n  }\n\n  async stop() {\n    console.log('🛑 Stopping WhatsApp MCP Server...');\n    await this.whatsappClient.shutdown();\n    console.log('✅ WhatsApp MCP Server stopped');\n  }\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.log('\\n🛑 Received SIGINT, shutting down gracefully...');\n  if (global.mcpServer) {\n    await global.mcpServer.stop();\n  }\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  console.log('\\n🛑 Received SIGTERM, shutting down gracefully...');\n  if (global.mcpServer) {\n    await global.mcpServer.stop();\n  }\n  process.exit(0);\n});\n\n// Start the server\nconst mcpServer = new WhatsAppMCPServer();\nglobal.mcpServer = mcpServer;\n\nmcpServer.start().catch(error => {\n  console.error('❌ Failed to start MCP server:', error);\n  process.exit(1);\n});"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "5258c18a-17e0-42a9-9032-120c2d7f6f50",
          "content": "Now let me check the WhatsApp client to understand the current coupling:",
          "tool_uses": [
            {
              "id": "tooluse_y4h4sasMTqKS61EzTCu8Pw",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/whatsapp-client.js",
                "start_line": 1,
                "end_line": 50
              },
              "orig_args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/whatsapp-client.js",
                "start_line": 1,
                "end_line": 50
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_y4h4sasMTqKS61EzTCu8Pw",
                "content": [
                  {
                    "Text": "import pkg from 'whatsapp-web.js';\nconst { Client, LocalAuth } = pkg;\nimport qrcode from 'qrcode-terminal';\nimport Database from './database.js';\nimport LocalVectorStore from './local-vector-store.js';\nimport MessageProcessor from './message-processor.js';\n\nclass WhatsAppClient {\n  constructor() {\n    this.client = new Client({\n      authStrategy: new LocalAuth(),\n      puppeteer: {\n        headless: true,\n        args: [\n          '--no-sandbox', \n          '--disable-setuid-sandbox',\n          '--disable-dev-shm-usage',\n          '--disable-accelerated-2d-canvas',\n          '--no-first-run',\n          '--no-zygote',\n          '--disable-gpu'\n        ],\n        timeout: 60000,\n      },\n    });\n    \n    this.database = new Database();\n    this.vectorStore = new LocalVectorStore();\n    this.messageProcessor = new MessageProcessor();\n    this.isReady = false;\n  }\n\n  async initialize() {\n    console.log('🚀 Initializing WhatsApp Indexer...');\n    \n    // Initialize database and vector store\n    await this.database.initialize();\n    await this.vectorStore.initialize();\n    \n    // Set up WhatsApp client event handlers\n    this.setupEventHandlers();\n    \n    // Initialize WhatsApp client\n    await this.client.initialize();\n  }\n\n  setupEventHandlers() {\n    this.client.on('qr', (qr) => {\n      console.log('📱 Scan this QR code with your WhatsApp:');\n      qrcode.generate(qr, { small: true });"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "2a4807c5-b737-4c3e-848c-cb80029ba663",
          "content": "Let me also check the database and vector store to understand the current architecture:",
          "tool_uses": [
            {
              "id": "tooluse_0IRWisQZR4aXbotey_7WZQ",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/database.js",
                "start_line": 1,
                "end_line": 50
              },
              "orig_args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/database.js",
                "start_line": 1,
                "end_line": 50
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_0IRWisQZR4aXbotey_7WZQ",
                "content": [
                  {
                    "Text": "import sqlite3 from 'sqlite3';\nimport { config } from './config.js';\nimport path from 'path';\nimport fs from 'fs';\n\nclass Database {\n  constructor() {\n    this.db = null;\n  }\n\n  async initialize() {\n    // Ensure data directory exists\n    const dataDir = path.dirname(config.database.path);\n    if (!fs.existsSync(dataDir)) {\n      fs.mkdirSync(dataDir, { recursive: true });\n    }\n\n    return new Promise((resolve, reject) => {\n      this.db = new sqlite3.Database(config.database.path, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          this.createTables().then(resolve).catch(reject);\n        }\n      });\n    });\n  }\n\n  async createTables() {\n    const createMessagesTable = `\n      CREATE TABLE IF NOT EXISTS messages (\n        id TEXT PRIMARY KEY,\n        chat_id TEXT NOT NULL,\n        sender_name TEXT NOT NULL,\n        sender_number TEXT NOT NULL,\n        content TEXT NOT NULL,\n        timestamp INTEGER NOT NULL,\n        message_type TEXT NOT NULL,\n        has_urls BOOLEAN DEFAULT FALSE,\n        created_at INTEGER DEFAULT (strftime('%s', 'now'))\n      )\n    `;\n\n    const createUrlsTable = `\n      CREATE TABLE IF NOT EXISTS urls (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        message_id TEXT NOT NULL,\n        url TEXT NOT NULL,\n        domain TEXT,\n        title TEXT,"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "65b330cb-1e42-433a-b51c-80dc8bd4abd9",
          "content": "Now let me check the local vector store:",
          "tool_uses": [
            {
              "id": "tooluse_lUyqUyO2QWGJm3mVd-kImA",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/local-vector-store.js",
                "start_line": 1,
                "end_line": 50
              },
              "orig_args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/local-vector-store.js",
                "start_line": 1,
                "end_line": 50
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_lUyqUyO2QWGJm3mVd-kImA",
                "content": [
                  {
                    "Text": "import { pipeline } from '@xenova/transformers';\nimport faiss from 'faiss-node';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport { config } from './config.js';\n\nconst { IndexFlatIP } = faiss;\n\nclass LocalVectorStore {\n  constructor() {\n    this.embedder = null;\n    this.index = null;\n    this.metadata = [];\n    this.isInitialized = false;\n    this.vectorStorePath = config.vectorStore.path;\n    this.indexPath = path.join(this.vectorStorePath, 'faiss.index');\n    this.metadataPath = path.join(this.vectorStorePath, 'metadata.json');\n  }\n\n  async initialize() {\n    try {\n      console.log('🚀 Initializing local vector store...');\n      \n      // Ensure vector store directory exists\n      await fs.ensureDir(this.vectorStorePath);\n      \n      // Initialize the embedding model\n      console.log('📥 Loading embedding model (this may take a moment on first run)...');\n      this.embedder = await pipeline('feature-extraction', config.vectorStore.modelName, {\n        quantized: false,\n      });\n      \n      // Load or create FAISS index\n      await this.loadOrCreateIndex();\n      \n      this.isInitialized = true;\n      console.log('✅ Local vector store initialized successfully');\n      console.log(`📊 Index contains ${this.metadata.length} vectors`);\n      \n    } catch (error) {\n      console.error('❌ Failed to initialize local vector store:', error);\n      throw error;\n    }\n  }\n\n  async loadOrCreateIndex() {\n    try {\n      // Try to load existing index and metadata\n      if (await fs.pathExists(this.indexPath) && await fs.pathExists(this.metadataPath)) {\n        console.log('📂 Loading existing vector index...');"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "4279d200-ea22-492d-8979-545e7891648a",
          "content": "Perfect! Now I understand the current architecture. Let me refactor this to properly separate concerns. I'll create:\n\n1. A standalone MCP server that only interacts with the database/vector store\n2. A separate WhatsApp listener service that handles WhatsApp messages and updates the index\n3. A shared data access layer\n\nLet me start by creating the refactored MCP server:",
          "tool_uses": [
            {
              "id": "tooluse_pSjb8OndQC23yBQDxV1jTw",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "command": "create",
                "path": "./whatsapp-indexer/src/mcp-server-standalone.js",
                "summary": "Create a standalone MCP server that only interacts with the database and vector store, decoupled from WhatsApp client",
                "file_text": "import { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport Database from './database.js';\nimport LocalVectorStore from './local-vector-store.js';\nimport * as chrono from 'chrono-node';\n\nclass WhatsAppMCPServer {\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'whatsapp-indexer',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n    \n    this.database = new Database();\n    this.vectorStore = new LocalVectorStore();\n    this.isInitialized = false;\n    this.setupTools();\n  }\n\n  async initialize() {\n    console.log('🚀 Initializing WhatsApp MCP Server...');\n    \n    try {\n      // Initialize database and vector store\n      await this.database.initialize();\n      await this.vectorStore.initialize();\n      \n      this.isInitialized = true;\n      console.log('✅ WhatsApp MCP Server initialized successfully');\n    } catch (error) {\n      console.error('❌ Failed to initialize WhatsApp MCP Server:', error);\n      throw error;\n    }\n  }\n\n  setupTools() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => {\n      return {\n        tools: [\n          {\n            name: 'whatsapp_status',\n            description: 'Check the status of the WhatsApp indexer service',\n            inputSchema: {\n              type: 'object',\n              properties: {},\n            },\n          },\n          {\n            name: 'search_messages',\n            description: 'Search WhatsApp messages using natural language queries. Supports semantic search and filters by sender, date, and content type.',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                query: {\n                  type: 'string',\n                  description: 'Natural language search query (e.g., \"get me the url Roni sent me for the thai restaurant\")',\n                },\n                limit: {\n                  type: 'number',\n                  description: 'Maximum number of results to return (default: 10)',\n                  default: 10,\n                },\n              },\n              required: ['query'],\n            },\n          },\n          {\n            name: 'get_urls_by_sender',\n            description: 'Get all URLs shared by a specific person',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                sender_name: {\n                  type: 'string',\n                  description: 'Name of the person who sent the URLs',\n                },\n                limit: {\n                  type: 'number',\n                  description: 'Maximum number of URLs to return (default: 20)',\n                  default: 20,\n                },\n              },\n              required: ['sender_name'],\n            },\n          },\n          {\n            name: 'get_messages_by_date',\n            description: 'Get messages from a specific date or date range',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                date_query: {\n                  type: 'string',\n                  description: 'Date or date range in natural language (e.g., \"today\", \"this week\", \"last Monday\", \"January 15\")',\n                },\n                sender_name: {\n                  type: 'string',\n                  description: 'Optional: filter by specific sender',\n                },\n              },\n              required: ['date_query'],\n            },\n          },\n          {\n            name: 'find_schedule_with_person',\n            description: 'Find scheduling-related messages with a specific person',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                person_name: {\n                  type: 'string',\n                  description: 'Name of the person to find scheduling messages with',\n                },\n                time_period: {\n                  type: 'string',\n                  description: 'Time period to search (e.g., \"this week\", \"next week\", \"today\")',\n                  default: 'this week',\n                },\n              },\n              required: ['person_name'],\n            },\n          },\n          {\n            name: 'check_plans_for_day',\n            description: 'Check if there are any plans or appointments for a specific day',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                day: {\n                  type: 'string',\n                  description: 'Day to check for plans (e.g., \"Wednesday\", \"tomorrow\", \"January 20\")',\n                },\n              },\n              required: ['day'],\n            },\n          },\n        ],\n      };\n    });\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const { name, arguments: args } = request.params;\n\n      try {\n        if (!this.isInitialized) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: 'WhatsApp indexer is not initialized yet. Please wait for initialization to complete.',\n              },\n            ],\n          };\n        }\n\n        switch (name) {\n          case 'whatsapp_status':\n            return await this.handleWhatsAppStatus(args);\n          \n          case 'search_messages':\n            return await this.handleSearchMessages(args);\n          \n          case 'get_urls_by_sender':\n            return await this.handleGetUrlsBySender(args);\n          \n          case 'get_messages_by_date':\n            return await this.handleGetMessagesByDate(args);\n          \n          case 'find_schedule_with_person':\n            return await this.handleFindScheduleWithPerson(args);\n          \n          case 'check_plans_for_day':\n            return await this.handleCheckPlansForDay(args);\n          \n          default:\n            throw new Error(`Unknown tool: ${name}`);\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error.message}`,\n            },\n          ],\n        };\n      }\n    });\n  }\n\n  async handleWhatsAppStatus(args) {\n    try {\n      // Check if we have any messages in the database\n      const messageCount = await this.database.getMessageCount();\n      const lastMessageTime = await this.database.getLastMessageTime();\n      \n      let status = `WhatsApp Indexer Status: Ready\n📊 Total messages indexed: ${messageCount}`;\n\n      if (lastMessageTime) {\n        const lastMessageDate = new Date(lastMessageTime).toLocaleString();\n        status += `\n🕒 Last message indexed: ${lastMessageDate}`;\n      }\n\n      if (messageCount === 0) {\n        status += `\n⚠️  No messages found. Make sure the WhatsApp listener service is running and has processed messages.`;\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: status,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Error checking status: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n\n  async handleSearchMessages(args) {\n    const { query, limit = 10 } = args;\n    \n    try {\n      const results = await this.vectorStore.search(query, limit);\n      \n      if (results.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No messages found for query: \"${query}\"`,\n            },\n          ],\n        };\n      }\n\n      const formattedResults = results.map(result => {\n        const date = new Date(result.timestamp).toLocaleString();\n        const urls = result.urls ? result.urls.split('|').join(', ') : '';\n        \n        return `**From:** ${result.sender_name}\n**Date:** ${date}\n**Message:** ${result.content}\n${urls ? `**URLs:** ${urls}` : ''}\n**Relevance Score:** ${result.score?.toFixed(3) || 'N/A'}\n---`;\n      }).join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${results.length} messages for \"${query}\":\\n\\n${formattedResults}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Search failed: ${error.message}`);\n    }\n  }\n\n  async handleGetUrlsBySender(args) {\n    const { sender_name, limit = 20 } = args;\n    \n    try {\n      const urls = await this.database.getUrlsBySender(sender_name, limit);\n      \n      if (urls.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No URLs found from ${sender_name}`,\n            },\n          ],\n        };\n      }\n\n      const formattedUrls = urls.map(urlData => {\n        const date = new Date(urlData.timestamp).toLocaleString();\n        return `**URL:** ${urlData.url}\n**Domain:** ${urlData.domain || 'Unknown'}\n**Date:** ${date}\n**Context:** ${urlData.content.substring(0, 100)}...\n---`;\n      }).join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${urls.length} URLs from ${sender_name}:\\n\\n${formattedUrls}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Failed to get URLs: ${error.message}`);\n    }\n  }\n\n  async handleGetMessagesByDate(args) {\n    const { date_query, sender_name } = args;\n    \n    try {\n      // Parse the date query\n      const parsedDates = chrono.parse(date_query);\n      if (parsedDates.length === 0) {\n        throw new Error(`Could not parse date: \"${date_query}\"`);\n      }\n\n      const date = parsedDates[0].start.date();\n      const startOfDay = new Date(date);\n      startOfDay.setHours(0, 0, 0, 0);\n      const endOfDay = new Date(date);\n      endOfDay.setHours(23, 59, 59, 999);\n\n      const messages = await this.database.getMessagesByDateRange(\n        startOfDay.getTime(),\n        endOfDay.getTime(),\n        sender_name\n      );\n\n      if (messages.length === 0) {\n        const senderText = sender_name ? ` from ${sender_name}` : '';\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No messages found${senderText} for ${date_query}`,\n            },\n          ],\n        };\n      }\n\n      const formattedMessages = messages.map(msg => {\n        const time = new Date(msg.timestamp).toLocaleTimeString();\n        const urls = msg.urls ? ` [URLs: ${msg.urls}]` : '';\n        \n        return `**${time} - ${msg.sender_name}:** ${msg.content}${urls}`;\n      }).join('\\n');\n\n      const senderText = sender_name ? ` from ${sender_name}` : '';\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${messages.length} messages${senderText} for ${date_query}:\\n\\n${formattedMessages}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Failed to get messages by date: ${error.message}`);\n    }\n  }\n\n  async handleFindScheduleWithPerson(args) {\n    const { person_name, time_period = 'this week' } = args;\n    \n    try {\n      // Create a search query that looks for scheduling-related messages\n      const schedulingQuery = `${person_name} meet meeting schedule appointment plan when time`;\n      \n      // Parse time period to get date range\n      const parsedDates = chrono.parse(time_period);\n      let dateRange = null;\n      \n      if (parsedDates.length > 0) {\n        const date = parsedDates[0].start.date();\n        // For \"this week\", create a week range\n        if (time_period.toLowerCase().includes('week')) {\n          const startOfWeek = new Date(date);\n          startOfWeek.setDate(date.getDate() - date.getDay());\n          startOfWeek.setHours(0, 0, 0, 0);\n          \n          const endOfWeek = new Date(startOfWeek);\n          endOfWeek.setDate(startOfWeek.getDate() + 6);\n          endOfWeek.setHours(23, 59, 59, 999);\n          \n          dateRange = {\n            start: startOfWeek.getTime(),\n            end: endOfWeek.getTime(),\n          };\n        }\n      }\n\n      const results = await this.vectorStore.search(schedulingQuery, 20);\n\n      // Filter results for the specific person and scheduling content\n      const schedulingMessages = results.filter(msg => {\n        const senderMatch = msg.sender_name?.toLowerCase().includes(person_name.toLowerCase());\n        const contentMatch = /\\b(meet|meeting|schedule|appointment|plan|when|time|tomorrow|today|monday|tuesday|wednesday|thursday|friday|saturday|sunday)\\b/i.test(msg.content);\n        \n        return senderMatch && contentMatch;\n      });\n\n      if (schedulingMessages.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No scheduling messages found with ${person_name} for ${time_period}`,\n            },\n          ],\n        };\n      }\n\n      const formattedMessages = schedulingMessages.map(msg => {\n        const date = new Date(msg.timestamp).toLocaleString();\n        return `**${date} - ${msg.sender_name}:** ${msg.content}`;\n      }).join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${schedulingMessages.length} scheduling-related messages with ${person_name} for ${time_period}:\\n\\n${formattedMessages}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Failed to find schedule messages: ${error.message}`);\n    }\n  }\n\n  async handleCheckPlansForDay(args) {\n    const { day } = args;\n    \n    try {\n      // Parse the day\n      const parsedDates = chrono.parse(day);\n      if (parsedDates.length === 0) {\n        throw new Error(`Could not parse day: \"${day}\"`);\n      }\n\n      const date = parsedDates[0].start.date();\n      const startOfDay = new Date(date);\n      startOfDay.setHours(0, 0, 0, 0);\n      const endOfDay = new Date(date);\n      endOfDay.setHours(23, 59, 59, 999);\n\n      // Search for plan-related messages on that day\n      const planQuery = 'plan plans meeting appointment schedule busy free available';\n      \n      const results = await this.vectorStore.search(planQuery, 50);\n\n      // Filter for messages on the specific day that mention plans\n      const dayPlans = results.filter(msg => {\n        const messageDate = new Date(msg.timestamp);\n        const isOnDay = messageDate >= startOfDay && messageDate <= endOfDay;\n        const hasPlanContent = /\\b(plan|plans|meeting|appointment|schedule|busy|free|available)\\b/i.test(msg.content);\n        \n        return isOnDay && hasPlanContent;\n      });\n\n      if (dayPlans.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No plans found for ${day}`,\n            },\n          ],\n        };\n      }\n\n      const formattedPlans = dayPlans.map(msg => {\n        const time = new Date(msg.timestamp).toLocaleTimeString();\n        return `**${time} - ${msg.sender_name}:** ${msg.content}`;\n      }).join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${dayPlans.length} plan-related messages for ${day}:\\n\\n${formattedPlans}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Failed to check plans: ${error.message}`);\n    }\n  }\n\n  async start() {\n    console.log('🚀 Starting WhatsApp MCP Server...');\n    \n    // Initialize database and vector store first\n    await this.initialize();\n    \n    // Start MCP server\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    \n    console.log('✅ WhatsApp MCP Server is running and ready');\n  }\n\n  async stop() {\n    console.log('🛑 Stopping WhatsApp MCP Server...');\n    // No WhatsApp client to shutdown, just cleanup if needed\n    console.log('✅ WhatsApp MCP Server stopped');\n  }\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.log('\\n🛑 Received SIGINT, shutting down gracefully...');\n  if (global.mcpServer) {\n    await global.mcpServer.stop();\n  }\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  console.log('\\n🛑 Received SIGTERM, shutting down gracefully...');\n  if (global.mcpServer) {\n    await global.mcpServer.stop();\n  }\n  process.exit(0);\n});\n\n// Start the server\nconst mcpServer = new WhatsAppMCPServer();\nglobal.mcpServer = mcpServer;\n\nmcpServer.start().catch(error => {\n  console.error('❌ Failed to start MCP server:', error);\n  process.exit(1);\n});"
              },
              "orig_args": {
                "command": "create",
                "path": "./whatsapp-indexer/src/mcp-server-standalone.js",
                "summary": "Create a standalone MCP server that only interacts with the database and vector store, decoupled from WhatsApp client",
                "file_text": "import { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport Database from './database.js';\nimport LocalVectorStore from './local-vector-store.js';\nimport * as chrono from 'chrono-node';\n\nclass WhatsAppMCPServer {\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'whatsapp-indexer',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    );\n    \n    this.database = new Database();\n    this.vectorStore = new LocalVectorStore();\n    this.isInitialized = false;\n    this.setupTools();\n  }\n\n  async initialize() {\n    console.log('🚀 Initializing WhatsApp MCP Server...');\n    \n    try {\n      // Initialize database and vector store\n      await this.database.initialize();\n      await this.vectorStore.initialize();\n      \n      this.isInitialized = true;\n      console.log('✅ WhatsApp MCP Server initialized successfully');\n    } catch (error) {\n      console.error('❌ Failed to initialize WhatsApp MCP Server:', error);\n      throw error;\n    }\n  }\n\n  setupTools() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => {\n      return {\n        tools: [\n          {\n            name: 'whatsapp_status',\n            description: 'Check the status of the WhatsApp indexer service',\n            inputSchema: {\n              type: 'object',\n              properties: {},\n            },\n          },\n          {\n            name: 'search_messages',\n            description: 'Search WhatsApp messages using natural language queries. Supports semantic search and filters by sender, date, and content type.',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                query: {\n                  type: 'string',\n                  description: 'Natural language search query (e.g., \"get me the url Roni sent me for the thai restaurant\")',\n                },\n                limit: {\n                  type: 'number',\n                  description: 'Maximum number of results to return (default: 10)',\n                  default: 10,\n                },\n              },\n              required: ['query'],\n            },\n          },\n          {\n            name: 'get_urls_by_sender',\n            description: 'Get all URLs shared by a specific person',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                sender_name: {\n                  type: 'string',\n                  description: 'Name of the person who sent the URLs',\n                },\n                limit: {\n                  type: 'number',\n                  description: 'Maximum number of URLs to return (default: 20)',\n                  default: 20,\n                },\n              },\n              required: ['sender_name'],\n            },\n          },\n          {\n            name: 'get_messages_by_date',\n            description: 'Get messages from a specific date or date range',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                date_query: {\n                  type: 'string',\n                  description: 'Date or date range in natural language (e.g., \"today\", \"this week\", \"last Monday\", \"January 15\")',\n                },\n                sender_name: {\n                  type: 'string',\n                  description: 'Optional: filter by specific sender',\n                },\n              },\n              required: ['date_query'],\n            },\n          },\n          {\n            name: 'find_schedule_with_person',\n            description: 'Find scheduling-related messages with a specific person',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                person_name: {\n                  type: 'string',\n                  description: 'Name of the person to find scheduling messages with',\n                },\n                time_period: {\n                  type: 'string',\n                  description: 'Time period to search (e.g., \"this week\", \"next week\", \"today\")',\n                  default: 'this week',\n                },\n              },\n              required: ['person_name'],\n            },\n          },\n          {\n            name: 'check_plans_for_day',\n            description: 'Check if there are any plans or appointments for a specific day',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                day: {\n                  type: 'string',\n                  description: 'Day to check for plans (e.g., \"Wednesday\", \"tomorrow\", \"January 20\")',\n                },\n              },\n              required: ['day'],\n            },\n          },\n        ],\n      };\n    });\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const { name, arguments: args } = request.params;\n\n      try {\n        if (!this.isInitialized) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: 'WhatsApp indexer is not initialized yet. Please wait for initialization to complete.',\n              },\n            ],\n          };\n        }\n\n        switch (name) {\n          case 'whatsapp_status':\n            return await this.handleWhatsAppStatus(args);\n          \n          case 'search_messages':\n            return await this.handleSearchMessages(args);\n          \n          case 'get_urls_by_sender':\n            return await this.handleGetUrlsBySender(args);\n          \n          case 'get_messages_by_date':\n            return await this.handleGetMessagesByDate(args);\n          \n          case 'find_schedule_with_person':\n            return await this.handleFindScheduleWithPerson(args);\n          \n          case 'check_plans_for_day':\n            return await this.handleCheckPlansForDay(args);\n          \n          default:\n            throw new Error(`Unknown tool: ${name}`);\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error.message}`,\n            },\n          ],\n        };\n      }\n    });\n  }\n\n  async handleWhatsAppStatus(args) {\n    try {\n      // Check if we have any messages in the database\n      const messageCount = await this.database.getMessageCount();\n      const lastMessageTime = await this.database.getLastMessageTime();\n      \n      let status = `WhatsApp Indexer Status: Ready\n📊 Total messages indexed: ${messageCount}`;\n\n      if (lastMessageTime) {\n        const lastMessageDate = new Date(lastMessageTime).toLocaleString();\n        status += `\n🕒 Last message indexed: ${lastMessageDate}`;\n      }\n\n      if (messageCount === 0) {\n        status += `\n⚠️  No messages found. Make sure the WhatsApp listener service is running and has processed messages.`;\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: status,\n          },\n        ],\n      };\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Error checking status: ${error.message}`,\n          },\n        ],\n      };\n    }\n  }\n\n  async handleSearchMessages(args) {\n    const { query, limit = 10 } = args;\n    \n    try {\n      const results = await this.vectorStore.search(query, limit);\n      \n      if (results.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No messages found for query: \"${query}\"`,\n            },\n          ],\n        };\n      }\n\n      const formattedResults = results.map(result => {\n        const date = new Date(result.timestamp).toLocaleString();\n        const urls = result.urls ? result.urls.split('|').join(', ') : '';\n        \n        return `**From:** ${result.sender_name}\n**Date:** ${date}\n**Message:** ${result.content}\n${urls ? `**URLs:** ${urls}` : ''}\n**Relevance Score:** ${result.score?.toFixed(3) || 'N/A'}\n---`;\n      }).join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${results.length} messages for \"${query}\":\\n\\n${formattedResults}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Search failed: ${error.message}`);\n    }\n  }\n\n  async handleGetUrlsBySender(args) {\n    const { sender_name, limit = 20 } = args;\n    \n    try {\n      const urls = await this.database.getUrlsBySender(sender_name, limit);\n      \n      if (urls.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No URLs found from ${sender_name}`,\n            },\n          ],\n        };\n      }\n\n      const formattedUrls = urls.map(urlData => {\n        const date = new Date(urlData.timestamp).toLocaleString();\n        return `**URL:** ${urlData.url}\n**Domain:** ${urlData.domain || 'Unknown'}\n**Date:** ${date}\n**Context:** ${urlData.content.substring(0, 100)}...\n---`;\n      }).join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${urls.length} URLs from ${sender_name}:\\n\\n${formattedUrls}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Failed to get URLs: ${error.message}`);\n    }\n  }\n\n  async handleGetMessagesByDate(args) {\n    const { date_query, sender_name } = args;\n    \n    try {\n      // Parse the date query\n      const parsedDates = chrono.parse(date_query);\n      if (parsedDates.length === 0) {\n        throw new Error(`Could not parse date: \"${date_query}\"`);\n      }\n\n      const date = parsedDates[0].start.date();\n      const startOfDay = new Date(date);\n      startOfDay.setHours(0, 0, 0, 0);\n      const endOfDay = new Date(date);\n      endOfDay.setHours(23, 59, 59, 999);\n\n      const messages = await this.database.getMessagesByDateRange(\n        startOfDay.getTime(),\n        endOfDay.getTime(),\n        sender_name\n      );\n\n      if (messages.length === 0) {\n        const senderText = sender_name ? ` from ${sender_name}` : '';\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No messages found${senderText} for ${date_query}`,\n            },\n          ],\n        };\n      }\n\n      const formattedMessages = messages.map(msg => {\n        const time = new Date(msg.timestamp).toLocaleTimeString();\n        const urls = msg.urls ? ` [URLs: ${msg.urls}]` : '';\n        \n        return `**${time} - ${msg.sender_name}:** ${msg.content}${urls}`;\n      }).join('\\n');\n\n      const senderText = sender_name ? ` from ${sender_name}` : '';\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${messages.length} messages${senderText} for ${date_query}:\\n\\n${formattedMessages}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Failed to get messages by date: ${error.message}`);\n    }\n  }\n\n  async handleFindScheduleWithPerson(args) {\n    const { person_name, time_period = 'this week' } = args;\n    \n    try {\n      // Create a search query that looks for scheduling-related messages\n      const schedulingQuery = `${person_name} meet meeting schedule appointment plan when time`;\n      \n      // Parse time period to get date range\n      const parsedDates = chrono.parse(time_period);\n      let dateRange = null;\n      \n      if (parsedDates.length > 0) {\n        const date = parsedDates[0].start.date();\n        // For \"this week\", create a week range\n        if (time_period.toLowerCase().includes('week')) {\n          const startOfWeek = new Date(date);\n          startOfWeek.setDate(date.getDate() - date.getDay());\n          startOfWeek.setHours(0, 0, 0, 0);\n          \n          const endOfWeek = new Date(startOfWeek);\n          endOfWeek.setDate(startOfWeek.getDate() + 6);\n          endOfWeek.setHours(23, 59, 59, 999);\n          \n          dateRange = {\n            start: startOfWeek.getTime(),\n            end: endOfWeek.getTime(),\n          };\n        }\n      }\n\n      const results = await this.vectorStore.search(schedulingQuery, 20);\n\n      // Filter results for the specific person and scheduling content\n      const schedulingMessages = results.filter(msg => {\n        const senderMatch = msg.sender_name?.toLowerCase().includes(person_name.toLowerCase());\n        const contentMatch = /\\b(meet|meeting|schedule|appointment|plan|when|time|tomorrow|today|monday|tuesday|wednesday|thursday|friday|saturday|sunday)\\b/i.test(msg.content);\n        \n        return senderMatch && contentMatch;\n      });\n\n      if (schedulingMessages.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No scheduling messages found with ${person_name} for ${time_period}`,\n            },\n          ],\n        };\n      }\n\n      const formattedMessages = schedulingMessages.map(msg => {\n        const date = new Date(msg.timestamp).toLocaleString();\n        return `**${date} - ${msg.sender_name}:** ${msg.content}`;\n      }).join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${schedulingMessages.length} scheduling-related messages with ${person_name} for ${time_period}:\\n\\n${formattedMessages}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Failed to find schedule messages: ${error.message}`);\n    }\n  }\n\n  async handleCheckPlansForDay(args) {\n    const { day } = args;\n    \n    try {\n      // Parse the day\n      const parsedDates = chrono.parse(day);\n      if (parsedDates.length === 0) {\n        throw new Error(`Could not parse day: \"${day}\"`);\n      }\n\n      const date = parsedDates[0].start.date();\n      const startOfDay = new Date(date);\n      startOfDay.setHours(0, 0, 0, 0);\n      const endOfDay = new Date(date);\n      endOfDay.setHours(23, 59, 59, 999);\n\n      // Search for plan-related messages on that day\n      const planQuery = 'plan plans meeting appointment schedule busy free available';\n      \n      const results = await this.vectorStore.search(planQuery, 50);\n\n      // Filter for messages on the specific day that mention plans\n      const dayPlans = results.filter(msg => {\n        const messageDate = new Date(msg.timestamp);\n        const isOnDay = messageDate >= startOfDay && messageDate <= endOfDay;\n        const hasPlanContent = /\\b(plan|plans|meeting|appointment|schedule|busy|free|available)\\b/i.test(msg.content);\n        \n        return isOnDay && hasPlanContent;\n      });\n\n      if (dayPlans.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `No plans found for ${day}`,\n            },\n          ],\n        };\n      }\n\n      const formattedPlans = dayPlans.map(msg => {\n        const time = new Date(msg.timestamp).toLocaleTimeString();\n        return `**${time} - ${msg.sender_name}:** ${msg.content}`;\n      }).join('\\n\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${dayPlans.length} plan-related messages for ${day}:\\n\\n${formattedPlans}`,\n          },\n        ],\n      };\n    } catch (error) {\n      throw new Error(`Failed to check plans: ${error.message}`);\n    }\n  }\n\n  async start() {\n    console.log('🚀 Starting WhatsApp MCP Server...');\n    \n    // Initialize database and vector store first\n    await this.initialize();\n    \n    // Start MCP server\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    \n    console.log('✅ WhatsApp MCP Server is running and ready');\n  }\n\n  async stop() {\n    console.log('🛑 Stopping WhatsApp MCP Server...');\n    // No WhatsApp client to shutdown, just cleanup if needed\n    console.log('✅ WhatsApp MCP Server stopped');\n  }\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.log('\\n🛑 Received SIGINT, shutting down gracefully...');\n  if (global.mcpServer) {\n    await global.mcpServer.stop();\n  }\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  console.log('\\n🛑 Received SIGTERM, shutting down gracefully...');\n  if (global.mcpServer) {\n    await global.mcpServer.stop();\n  }\n  process.exit(0);\n});\n\n// Start the server\nconst mcpServer = new WhatsAppMCPServer();\nglobal.mcpServer = mcpServer;\n\nmcpServer.start().catch(error => {\n  console.error('❌ Failed to start MCP server:', error);\n  process.exit(1);\n});"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_pSjb8OndQC23yBQDxV1jTw",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "5d1e6502-b340-420a-9220-24f09a2a44b6",
          "content": "Now let me add the missing database methods that the MCP server needs:",
          "tool_uses": [
            {
              "id": "tooluse_t48H-ErNTAWlPQWmcXIizw",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/database.js"
              },
              "orig_args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/database.js"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_t48H-ErNTAWlPQWmcXIizw",
                "content": [
                  {
                    "Text": "import sqlite3 from 'sqlite3';\nimport { config } from './config.js';\nimport path from 'path';\nimport fs from 'fs';\n\nclass Database {\n  constructor() {\n    this.db = null;\n  }\n\n  async initialize() {\n    // Ensure data directory exists\n    const dataDir = path.dirname(config.database.path);\n    if (!fs.existsSync(dataDir)) {\n      fs.mkdirSync(dataDir, { recursive: true });\n    }\n\n    return new Promise((resolve, reject) => {\n      this.db = new sqlite3.Database(config.database.path, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          this.createTables().then(resolve).catch(reject);\n        }\n      });\n    });\n  }\n\n  async createTables() {\n    const createMessagesTable = `\n      CREATE TABLE IF NOT EXISTS messages (\n        id TEXT PRIMARY KEY,\n        chat_id TEXT NOT NULL,\n        sender_name TEXT NOT NULL,\n        sender_number TEXT NOT NULL,\n        content TEXT NOT NULL,\n        timestamp INTEGER NOT NULL,\n        message_type TEXT NOT NULL,\n        has_urls BOOLEAN DEFAULT FALSE,\n        created_at INTEGER DEFAULT (strftime('%s', 'now'))\n      )\n    `;\n\n    const createUrlsTable = `\n      CREATE TABLE IF NOT EXISTS urls (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        message_id TEXT NOT NULL,\n        url TEXT NOT NULL,\n        domain TEXT,\n        title TEXT,\n        description TEXT,\n        created_at INTEGER DEFAULT (strftime('%s', 'now')),\n        FOREIGN KEY (message_id) REFERENCES messages (id)\n      )\n    `;\n\n    const createIndexes = [\n      'CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp)',\n      'CREATE INDEX IF NOT EXISTS idx_messages_sender ON messages(sender_name)',\n      'CREATE INDEX IF NOT EXISTS idx_messages_chat ON messages(chat_id)',\n      'CREATE INDEX IF NOT EXISTS idx_urls_message ON urls(message_id)',\n      'CREATE INDEX IF NOT EXISTS idx_urls_domain ON urls(domain)',\n    ];\n\n    return new Promise((resolve, reject) => {\n      this.db.serialize(() => {\n        this.db.run(createMessagesTable);\n        this.db.run(createUrlsTable);\n        \n        indexCreation: for (const index of createIndexes) {\n          this.db.run(index);\n        }\n        \n        resolve();\n      });\n    });\n  }\n\n  async saveMessage(messageData) {\n    const { id, chatId, senderName, senderNumber, content, timestamp, messageType, urls = [] } = messageData;\n    \n    return new Promise((resolve, reject) => {\n      this.db.serialize(() => {\n        // Insert message\n        const insertMessage = `\n          INSERT OR REPLACE INTO messages \n          (id, chat_id, sender_name, sender_number, content, timestamp, message_type, has_urls)\n          VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        `;\n        \n        this.db.run(insertMessage, [\n          id, chatId, senderName, senderNumber, content, timestamp, messageType, urls.length > 0\n        ], function(err) {\n          if (err) {\n            reject(err);\n            return;\n          }\n\n          // Insert URLs if any\n          if (urls.length > 0) {\n            const insertUrl = `\n              INSERT INTO urls (message_id, url, domain, title, description)\n              VALUES (?, ?, ?, ?, ?)\n            `;\n            \n            for (const urlData of urls) {\n              this.run(insertUrl, [\n                id, urlData.url, urlData.domain, urlData.title, urlData.description\n              ]);\n            }\n          }\n          \n          resolve(this.lastID);\n        });\n      });\n    });\n  }\n\n  async searchMessages(query, limit = 50) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        SELECT m.*, GROUP_CONCAT(u.url) as urls\n        FROM messages m\n        LEFT JOIN urls u ON m.id = u.message_id\n        WHERE m.content LIKE ? OR m.sender_name LIKE ?\n        GROUP BY m.id\n        ORDER BY m.timestamp DESC\n        LIMIT ?\n      `;\n      \n      this.db.all(sql, [`%${query}%`, `%${query}%`, limit], (err, rows) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(rows);\n        }\n      });\n    });\n  }\n\n  async getMessagesByDateRange(startDate, endDate, senderName = null) {\n    return new Promise((resolve, reject) => {\n      let sql = `\n        SELECT m.*, GROUP_CONCAT(u.url) as urls\n        FROM messages m\n        LEFT JOIN urls u ON m.id = u.message_id\n        WHERE m.timestamp BETWEEN ? AND ?\n      `;\n      \n      const params = [startDate, endDate];\n      \n      if (senderName) {\n        sql += ' AND m.sender_name LIKE ?';\n        params.push(`%${senderName}%`);\n      }\n      \n      sql += ' GROUP BY m.id ORDER BY m.timestamp DESC';\n      \n      this.db.all(sql, params, (err, rows) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(rows);\n        }\n      });\n    });\n  }\n\n  async getUrlsBySender(senderName, limit = 20) {\n    return new Promise((resolve, reject) => {\n      const sql = `\n        SELECT u.*, m.sender_name, m.timestamp, m.content\n        FROM urls u\n        JOIN messages m ON u.message_id = m.id\n        WHERE m.sender_name LIKE ?\n        ORDER BY m.timestamp DESC\n        LIMIT ?\n      `;\n      \n      this.db.all(sql, [`%${senderName}%`, limit], (err, rows) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(rows);\n        }\n      });\n    });\n  }\n\n  async close() {\n    return new Promise((resolve) => {\n      if (this.db) {\n        this.db.close(resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n}\n\nexport default Database;"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "f168ded9-85c5-4583-b3cc-29eaef068815",
          "content": "I need to add the missing methods to the database class:",
          "tool_uses": [
            {
              "id": "tooluse_Fcyvcuw5SvW7pFcUhmtfFQ",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Add missing database methods for message count and last message time",
                "path": "./whatsapp-indexer/src/database.js",
                "old_str": "  async close() {\n    return new Promise((resolve) => {\n      if (this.db) {\n        this.db.close(resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n}\n\nexport default Database;",
                "new_str": "  async getMessageCount() {\n    return new Promise((resolve, reject) => {\n      const sql = 'SELECT COUNT(*) as count FROM messages';\n      \n      this.db.get(sql, (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(row.count);\n        }\n      });\n    });\n  }\n\n  async getLastMessageTime() {\n    return new Promise((resolve, reject) => {\n      const sql = 'SELECT MAX(timestamp) as last_timestamp FROM messages';\n      \n      this.db.get(sql, (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(row.last_timestamp);\n        }\n      });\n    });\n  }\n\n  async close() {\n    return new Promise((resolve) => {\n      if (this.db) {\n        this.db.close(resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n}\n\nexport default Database;",
                "command": "str_replace"
              },
              "orig_args": {
                "summary": "Add missing database methods for message count and last message time",
                "path": "./whatsapp-indexer/src/database.js",
                "old_str": "  async close() {\n    return new Promise((resolve) => {\n      if (this.db) {\n        this.db.close(resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n}\n\nexport default Database;",
                "new_str": "  async getMessageCount() {\n    return new Promise((resolve, reject) => {\n      const sql = 'SELECT COUNT(*) as count FROM messages';\n      \n      this.db.get(sql, (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(row.count);\n        }\n      });\n    });\n  }\n\n  async getLastMessageTime() {\n    return new Promise((resolve, reject) => {\n      const sql = 'SELECT MAX(timestamp) as last_timestamp FROM messages';\n      \n      this.db.get(sql, (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(row.last_timestamp);\n        }\n      });\n    });\n  }\n\n  async close() {\n    return new Promise((resolve) => {\n      if (this.db) {\n        this.db.close(resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n}\n\nexport default Database;",
                "command": "str_replace"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_Fcyvcuw5SvW7pFcUhmtfFQ",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "0eec96e2-8e94-43ba-be75-1921fc7f28f8",
          "content": "Now let me create a separate WhatsApp listener service that handles the WhatsApp client and updates the index:",
          "tool_uses": [
            {
              "id": "tooluse_Ztqjax4ASIO_syJVHVVcxw",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Create a separate WhatsApp listener service that handles WhatsApp messages and updates the index",
                "path": "./whatsapp-indexer/src/whatsapp-listener.js",
                "file_text": "import pkg from 'whatsapp-web.js';\nconst { Client, LocalAuth } = pkg;\nimport qrcode from 'qrcode-terminal';\nimport Database from './database.js';\nimport LocalVectorStore from './local-vector-store.js';\nimport MessageProcessor from './message-processor.js';\n\nclass WhatsAppListener {\n  constructor() {\n    this.client = new Client({\n      authStrategy: new LocalAuth(),\n      puppeteer: {\n        headless: true,\n        args: [\n          '--no-sandbox', \n          '--disable-setuid-sandbox',\n          '--disable-dev-shm-usage',\n          '--disable-accelerated-2d-canvas',\n          '--no-first-run',\n          '--no-zygote',\n          '--disable-gpu'\n        ],\n        timeout: 60000,\n      },\n    });\n    \n    this.database = new Database();\n    this.vectorStore = new LocalVectorStore();\n    this.messageProcessor = new MessageProcessor();\n    this.isReady = false;\n    this.isShuttingDown = false;\n  }\n\n  async initialize() {\n    console.log('🚀 Initializing WhatsApp Listener Service...');\n    \n    try {\n      // Initialize database and vector store\n      await this.database.initialize();\n      await this.vectorStore.initialize();\n      \n      // Set up WhatsApp client event handlers\n      this.setupEventHandlers();\n      \n      // Initialize WhatsApp client\n      await this.client.initialize();\n      \n      console.log('✅ WhatsApp Listener Service initialized successfully');\n    } catch (error) {\n      console.error('❌ Failed to initialize WhatsApp Listener Service:', error);\n      throw error;\n    }\n  }\n\n  setupEventHandlers() {\n    this.client.on('qr', (qr) => {\n      console.log('📱 Scan this QR code with your WhatsApp:');\n      qrcode.generate(qr, { small: true });\n    });\n\n    this.client.on('ready', () => {\n      console.log('✅ WhatsApp client is ready!');\n      this.isReady = true;\n    });\n\n    this.client.on('authenticated', () => {\n      console.log('🔐 WhatsApp client authenticated');\n    });\n\n    this.client.on('auth_failure', (msg) => {\n      console.error('❌ WhatsApp authentication failed:', msg);\n    });\n\n    this.client.on('disconnected', (reason) => {\n      console.log('📱 WhatsApp client disconnected:', reason);\n      this.isReady = false;\n      \n      if (!this.isShuttingDown) {\n        console.log('🔄 Attempting to reconnect...');\n        setTimeout(() => {\n          this.client.initialize().catch(console.error);\n        }, 5000);\n      }\n    });\n\n    this.client.on('message', async (message) => {\n      try {\n        await this.handleMessage(message);\n      } catch (error) {\n        console.error('❌ Error handling message:', error);\n      }\n    });\n\n    this.client.on('message_create', async (message) => {\n      try {\n        // Handle sent messages (from this account)\n        if (message.fromMe) {\n          await this.handleMessage(message);\n        }\n      } catch (error) {\n        console.error('❌ Error handling sent message:', error);\n      }\n    });\n  }\n\n  async handleMessage(message) {\n    if (!this.isReady) {\n      return;\n    }\n\n    try {\n      // Get chat and contact info\n      const chat = await message.getChat();\n      const contact = await message.getContact();\n      \n      // Process the message\n      const processedMessage = await this.messageProcessor.processMessage(message, chat, contact);\n      \n      if (processedMessage) {\n        // Save to database\n        await this.database.saveMessage(processedMessage);\n        \n        // Add to vector store for semantic search\n        await this.vectorStore.addMessage(processedMessage);\n        \n        console.log(`📝 Indexed message from ${processedMessage.senderName}: ${processedMessage.content.substring(0, 50)}...`);\n      }\n    } catch (error) {\n      console.error('❌ Error processing message:', error);\n    }\n  }\n\n  async getChats() {\n    if (!this.isReady) {\n      throw new Error('WhatsApp client is not ready');\n    }\n    \n    return await this.client.getChats();\n  }\n\n  async getChatById(chatId) {\n    if (!this.isReady) {\n      throw new Error('WhatsApp client is not ready');\n    }\n    \n    return await this.client.getChatById(chatId);\n  }\n\n  async getContactById(contactId) {\n    if (!this.isReady) {\n      throw new Error('WhatsApp client is not ready');\n    }\n    \n    return await this.client.getContactById(contactId);\n  }\n\n  async sendMessage(chatId, message) {\n    if (!this.isReady) {\n      throw new Error('WhatsApp client is not ready');\n    }\n    \n    const chat = await this.getChatById(chatId);\n    return await chat.sendMessage(message);\n  }\n\n  async shutdown() {\n    console.log('🛑 Shutting down WhatsApp Listener Service...');\n    this.isShuttingDown = true;\n    \n    try {\n      if (this.client) {\n        await this.client.destroy();\n      }\n      \n      if (this.database) {\n        await this.database.close();\n      }\n      \n      console.log('✅ WhatsApp Listener Service shut down successfully');\n    } catch (error) {\n      console.error('❌ Error during shutdown:', error);\n    }\n  }\n\n  // Health check method\n  getStatus() {\n    return {\n      isReady: this.isReady,\n      isShuttingDown: this.isShuttingDown,\n      clientState: this.client?.info?.wid ? 'authenticated' : 'not_authenticated',\n    };\n  }\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.log('\\n🛑 Received SIGINT, shutting down gracefully...');\n  if (global.whatsappListener) {\n    await global.whatsappListener.shutdown();\n  }\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  console.log('\\n🛑 Received SIGTERM, shutting down gracefully...');\n  if (global.whatsappListener) {\n    await global.whatsappListener.shutdown();\n  }\n  process.exit(0);\n});\n\n// Start the listener service if this file is run directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const listener = new WhatsAppListener();\n  global.whatsappListener = listener;\n  \n  listener.initialize().catch(error => {\n    console.error('❌ Failed to start WhatsApp Listener Service:', error);\n    process.exit(1);\n  });\n}\n\nexport default WhatsAppListener;",
                "command": "create"
              },
              "orig_args": {
                "summary": "Create a separate WhatsApp listener service that handles WhatsApp messages and updates the index",
                "path": "./whatsapp-indexer/src/whatsapp-listener.js",
                "file_text": "import pkg from 'whatsapp-web.js';\nconst { Client, LocalAuth } = pkg;\nimport qrcode from 'qrcode-terminal';\nimport Database from './database.js';\nimport LocalVectorStore from './local-vector-store.js';\nimport MessageProcessor from './message-processor.js';\n\nclass WhatsAppListener {\n  constructor() {\n    this.client = new Client({\n      authStrategy: new LocalAuth(),\n      puppeteer: {\n        headless: true,\n        args: [\n          '--no-sandbox', \n          '--disable-setuid-sandbox',\n          '--disable-dev-shm-usage',\n          '--disable-accelerated-2d-canvas',\n          '--no-first-run',\n          '--no-zygote',\n          '--disable-gpu'\n        ],\n        timeout: 60000,\n      },\n    });\n    \n    this.database = new Database();\n    this.vectorStore = new LocalVectorStore();\n    this.messageProcessor = new MessageProcessor();\n    this.isReady = false;\n    this.isShuttingDown = false;\n  }\n\n  async initialize() {\n    console.log('🚀 Initializing WhatsApp Listener Service...');\n    \n    try {\n      // Initialize database and vector store\n      await this.database.initialize();\n      await this.vectorStore.initialize();\n      \n      // Set up WhatsApp client event handlers\n      this.setupEventHandlers();\n      \n      // Initialize WhatsApp client\n      await this.client.initialize();\n      \n      console.log('✅ WhatsApp Listener Service initialized successfully');\n    } catch (error) {\n      console.error('❌ Failed to initialize WhatsApp Listener Service:', error);\n      throw error;\n    }\n  }\n\n  setupEventHandlers() {\n    this.client.on('qr', (qr) => {\n      console.log('📱 Scan this QR code with your WhatsApp:');\n      qrcode.generate(qr, { small: true });\n    });\n\n    this.client.on('ready', () => {\n      console.log('✅ WhatsApp client is ready!');\n      this.isReady = true;\n    });\n\n    this.client.on('authenticated', () => {\n      console.log('🔐 WhatsApp client authenticated');\n    });\n\n    this.client.on('auth_failure', (msg) => {\n      console.error('❌ WhatsApp authentication failed:', msg);\n    });\n\n    this.client.on('disconnected', (reason) => {\n      console.log('📱 WhatsApp client disconnected:', reason);\n      this.isReady = false;\n      \n      if (!this.isShuttingDown) {\n        console.log('🔄 Attempting to reconnect...');\n        setTimeout(() => {\n          this.client.initialize().catch(console.error);\n        }, 5000);\n      }\n    });\n\n    this.client.on('message', async (message) => {\n      try {\n        await this.handleMessage(message);\n      } catch (error) {\n        console.error('❌ Error handling message:', error);\n      }\n    });\n\n    this.client.on('message_create', async (message) => {\n      try {\n        // Handle sent messages (from this account)\n        if (message.fromMe) {\n          await this.handleMessage(message);\n        }\n      } catch (error) {\n        console.error('❌ Error handling sent message:', error);\n      }\n    });\n  }\n\n  async handleMessage(message) {\n    if (!this.isReady) {\n      return;\n    }\n\n    try {\n      // Get chat and contact info\n      const chat = await message.getChat();\n      const contact = await message.getContact();\n      \n      // Process the message\n      const processedMessage = await this.messageProcessor.processMessage(message, chat, contact);\n      \n      if (processedMessage) {\n        // Save to database\n        await this.database.saveMessage(processedMessage);\n        \n        // Add to vector store for semantic search\n        await this.vectorStore.addMessage(processedMessage);\n        \n        console.log(`📝 Indexed message from ${processedMessage.senderName}: ${processedMessage.content.substring(0, 50)}...`);\n      }\n    } catch (error) {\n      console.error('❌ Error processing message:', error);\n    }\n  }\n\n  async getChats() {\n    if (!this.isReady) {\n      throw new Error('WhatsApp client is not ready');\n    }\n    \n    return await this.client.getChats();\n  }\n\n  async getChatById(chatId) {\n    if (!this.isReady) {\n      throw new Error('WhatsApp client is not ready');\n    }\n    \n    return await this.client.getChatById(chatId);\n  }\n\n  async getContactById(contactId) {\n    if (!this.isReady) {\n      throw new Error('WhatsApp client is not ready');\n    }\n    \n    return await this.client.getContactById(contactId);\n  }\n\n  async sendMessage(chatId, message) {\n    if (!this.isReady) {\n      throw new Error('WhatsApp client is not ready');\n    }\n    \n    const chat = await this.getChatById(chatId);\n    return await chat.sendMessage(message);\n  }\n\n  async shutdown() {\n    console.log('🛑 Shutting down WhatsApp Listener Service...');\n    this.isShuttingDown = true;\n    \n    try {\n      if (this.client) {\n        await this.client.destroy();\n      }\n      \n      if (this.database) {\n        await this.database.close();\n      }\n      \n      console.log('✅ WhatsApp Listener Service shut down successfully');\n    } catch (error) {\n      console.error('❌ Error during shutdown:', error);\n    }\n  }\n\n  // Health check method\n  getStatus() {\n    return {\n      isReady: this.isReady,\n      isShuttingDown: this.isShuttingDown,\n      clientState: this.client?.info?.wid ? 'authenticated' : 'not_authenticated',\n    };\n  }\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', async () => {\n  console.log('\\n🛑 Received SIGINT, shutting down gracefully...');\n  if (global.whatsappListener) {\n    await global.whatsappListener.shutdown();\n  }\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', async () => {\n  console.log('\\n🛑 Received SIGTERM, shutting down gracefully...');\n  if (global.whatsappListener) {\n    await global.whatsappListener.shutdown();\n  }\n  process.exit(0);\n});\n\n// Start the listener service if this file is run directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const listener = new WhatsAppListener();\n  global.whatsappListener = listener;\n  \n  listener.initialize().catch(error => {\n    console.error('❌ Failed to start WhatsApp Listener Service:', error);\n    process.exit(1);\n  });\n}\n\nexport default WhatsAppListener;",
                "command": "create"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_Ztqjax4ASIO_syJVHVVcxw",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "4c2a4c36-9a09-4924-8265-4378e1a827d3",
          "content": "Now let me update the vector store to include the missing `addMessage` method:",
          "tool_uses": [
            {
              "id": "tooluse_bLGmOvz9SXeNYlJnfs7ldQ",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/local-vector-store.js",
                "start_line": 200,
                "end_line": 300
              },
              "orig_args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/local-vector-store.js",
                "start_line": 200,
                "end_line": 300
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_bLGmOvz9SXeNYlJnfs7ldQ",
                "content": [
                  {
                    "Text": "      \n      // Generate embedding for query\n      const queryEmbedding = await this.generateEmbedding(query);\n      \n      // Search in FAISS index - FAISS expects regular arrays\n      const searchResults = this.index.search(queryEmbedding, Math.min(topK * 3, this.metadata.length));\n      \n      // Process results and apply filters\n      const results = [];\n      \n      for (let i = 0; i < searchResults.labels.length && results.length < topK; i++) {\n        const idx = searchResults.labels[i];\n        const score = searchResults.distances[i];\n        \n        if (idx >= 0 && idx < this.metadata.length && score >= threshold) {\n          const metadata = this.metadata[idx];\n          \n          // Skip deleted messages\n          if (metadata.deleted) continue;\n          \n          // Apply filters\n          if (senderFilter && !metadata.senderName.toLowerCase().includes(senderFilter.toLowerCase())) {\n            continue;\n          }\n          \n          if (dateRange && (metadata.timestamp < dateRange.start || metadata.timestamp > dateRange.end)) {\n            continue;\n          }\n          \n          if (includeUrls !== null && metadata.hasUrls !== includeUrls) {\n            continue;\n          }\n          \n          results.push({\n            id: metadata.messageId,\n            score: score,\n            ...metadata,\n          });\n        }\n      }\n      \n      // Sort by score (higher is better for cosine similarity)\n      results.sort((a, b) => b.score - a.score);\n      \n      return results;\n    } catch (error) {\n      console.error('Error searching vectors:', error);\n      throw error;\n    }\n  }\n\n  async deleteMessage(messageId) {\n    try {\n      const index = this.metadata.findIndex(meta => meta.messageId === messageId);\n      if (index !== -1) {\n        // Mark as deleted (FAISS doesn't support direct removal)\n        this.metadata[index].deleted = true;\n        await this.saveIndex();\n        console.log(`🗑️ Marked message ${messageId} as deleted`);\n      }\n    } catch (error) {\n      console.error('Error deleting message from vector store:', error);\n      throw error;\n    }\n  }\n\n  async cleanup() {\n    // Periodically rebuild index to remove deleted items\n    const activeMetadata = this.metadata.filter(meta => !meta.deleted);\n    \n    if (activeMetadata.length < this.metadata.length * 0.8) {\n      console.log('🧹 Rebuilding index to remove deleted items...');\n      \n      // Create new index\n      const newIndex = new IndexFlatIP(config.vectorStore.dimension);\n      const newMetadata = [];\n      \n      // Re-add active vectors\n      for (const meta of activeMetadata) {\n        if (!meta.deleted) {\n          // Re-generate embedding and add to new index\n          const searchableText = `${meta.content} from ${meta.senderName}`;\n          const embedding = await this.generateEmbedding(searchableText);\n          \n          newIndex.add(embedding);\n          meta.indexPosition = newMetadata.length;\n          newMetadata.push(meta);\n        }\n      }\n      \n      // Replace old index\n      this.index = newIndex;\n      this.metadata = newMetadata;\n      \n      await this.saveIndex();\n      console.log(`✅ Index rebuilt: ${newMetadata.length} active vectors`);\n    }\n  }\n\n  async getStats() {\n    const activeCount = this.metadata.filter(meta => !meta.deleted).length;"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "9cd5f2ff-f822-484b-a311-021fad094d6b",
          "content": "Let me check if there's an `addMessage` method already:",
          "tool_uses": [
            {
              "id": "tooluse_pi14Vj9hR7S1exx9d2jxKg",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Search",
                "path": "./whatsapp-indexer/src/local-vector-store.js",
                "pattern": "addMessage"
              },
              "orig_args": {
                "mode": "Search",
                "path": "./whatsapp-indexer/src/local-vector-store.js",
                "pattern": "addMessage"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_pi14Vj9hR7S1exx9d2jxKg",
                "content": [
                  {
                    "Text": "[]"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "545a962c-9afc-4511-ba03-f76e60d6f76f",
          "content": "I need to add the `addMessage` method to the vector store:",
          "tool_uses": [
            {
              "id": "tooluse_y7HN5zrGRFCXhQZZ_MoR1g",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/local-vector-store.js",
                "start_line": 150,
                "end_line": 200
              },
              "orig_args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/local-vector-store.js",
                "start_line": 150,
                "end_line": 200
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_y7HN5zrGRFCXhQZZ_MoR1g",
                "content": [
                  {
                    "Text": "        senderName,\n        senderNumber,\n        chatId,\n        timestamp,\n        content: content.substring(0, 1000), // Limit content size in metadata\n        hasUrls: urls.length > 0,\n        urlCount: urls.length,\n        deleted: false,\n        indexPosition: this.metadata.length, // Track position in FAISS index\n      };\n      \n      // Add URL information to metadata if present\n      if (urls.length > 0) {\n        metadata.urls = urls.map(u => u.url).join('|');\n        metadata.domains = [...new Set(urls.map(u => u.domain))].join('|');\n      }\n      \n      // Add to FAISS index - FAISS expects regular arrays\n      console.log(`📊 Adding vector to FAISS index (dimension: ${embedding.length})...`);\n      this.index.add(embedding); // Pass the embedding array directly\n      \n      // Add metadata\n      this.metadata.push(metadata);\n      \n      // Save periodically (every 10 messages)\n      if (this.metadata.length % 10 === 0) {\n        await this.saveIndex();\n      }\n      \n      console.log(`✅ Indexed message from ${senderName} (total: ${this.metadata.length})`);\n    } catch (error) {\n      console.error('Error indexing message:', error);\n      console.error('Message data:', { id, senderName, contentLength: content?.length });\n      throw error;\n    }\n  }\n\n  async searchSimilar(query, options = {}) {\n    const {\n      topK = 10,\n      senderFilter = null,\n      dateRange = null,\n      includeUrls = null,\n      threshold = 0.1, // Minimum similarity threshold\n    } = options;\n    \n    try {\n      if (!this.isInitialized) {\n        throw new Error('Vector store not initialized');\n      }\n      "
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "029dc964-d035-4517-86f7-1973a307bbbc",
          "content": "I can see there's already an indexing method. Let me find the correct method name:",
          "tool_uses": [
            {
              "id": "tooluse_AR4WqsRsRn6p_GilrfsRlw",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "pattern": "async.*\\(.*message",
                "mode": "Search",
                "path": "./whatsapp-indexer/src/local-vector-store.js"
              },
              "orig_args": {
                "pattern": "async.*\\(.*message",
                "mode": "Search",
                "path": "./whatsapp-indexer/src/local-vector-store.js"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_AR4WqsRsRn6p_GilrfsRlw",
                "content": [
                  {
                    "Text": "[]"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "d7bd8ee5-645a-47f8-a201-f90253ce763d",
          "content": "Let me search for the method that adds messages:",
          "tool_uses": [
            {
              "id": "tooluse_ahvgv545QSO9bj0HqppFUg",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "pattern": "async.*index",
                "mode": "Search",
                "path": "./whatsapp-indexer/src/local-vector-store.js"
              },
              "orig_args": {
                "pattern": "async.*index",
                "mode": "Search",
                "path": "./whatsapp-indexer/src/local-vector-store.js"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_ahvgv545QSO9bj0HqppFUg",
                "content": [
                  {
                    "Text": "[]"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "5609bfa4-d9a7-4573-b00b-234055595999",
          "content": "Let me look at the full vector store file to understand the structure:",
          "tool_uses": [
            {
              "id": "tooluse_JFO1h9sSTNCPh8yIqplCyQ",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/local-vector-store.js",
                "start_line": 100,
                "end_line": 150
              },
              "orig_args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/src/local-vector-store.js",
                "start_line": 100,
                "end_line": 150
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_JFO1h9sSTNCPh8yIqplCyQ",
                "content": [
                  {
                    "Text": "        throw new Error('Embedder not initialized');\n      }\n      \n      // Generate embedding\n      const output = await this.embedder(text, { pooling: 'mean', normalize: true });\n      \n      // Convert to array and ensure correct dimensions\n      const embedding = Array.from(output.data);\n      \n      if (embedding.length !== config.vectorStore.dimension) {\n        throw new Error(`Embedding dimension mismatch: expected ${config.vectorStore.dimension}, got ${embedding.length}`);\n      }\n      \n      return embedding;\n    } catch (error) {\n      console.error('Error generating embedding:', error);\n      throw error;\n    }\n  }\n\n  async indexMessage(messageData) {\n    const { id, content, senderName, senderNumber, timestamp, chatId, urls = [] } = messageData;\n    \n    try {\n      // Create searchable text combining message content and context\n      const searchableText = `${content} from ${senderName}`;\n      \n      // Generate embedding\n      console.log(`🔄 Generating embedding for message from ${senderName}...`);\n      const embedding = await this.generateEmbedding(searchableText);\n      \n      if (!Array.isArray(embedding) || embedding.length !== config.vectorStore.dimension) {\n        throw new Error(`Invalid embedding: expected array of length ${config.vectorStore.dimension}, got ${typeof embedding} of length ${embedding?.length}`);\n      }\n      \n      // Check if message already exists\n      const existingIndex = this.metadata.findIndex(meta => meta.messageId === id);\n      \n      if (existingIndex !== -1) {\n        // Update existing message\n        console.log(`🔄 Updating existing message from ${senderName}`);\n        \n        // Remove old vector\n        // Note: FAISS doesn't support direct removal, so we'll mark as deleted\n        this.metadata[existingIndex].deleted = true;\n      }\n      \n      // Prepare metadata\n      const metadata = {\n        messageId: id,\n        senderName,"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "2a822566-3655-44ab-b591-4edf74b21e78",
          "content": "Perfect! I can see the method is called `indexMessage`. Let me update the WhatsApp listener to use the correct method name:",
          "tool_uses": [
            {
              "id": "tooluse_17RE6vvmRbKzbjomaYflvw",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Fix method name from addMessage to indexMessage in WhatsApp listener",
                "path": "./whatsapp-indexer/src/whatsapp-listener.js",
                "old_str": "        // Add to vector store for semantic search\n        await this.vectorStore.addMessage(processedMessage);",
                "new_str": "        // Add to vector store for semantic search\n        await this.vectorStore.indexMessage(processedMessage);",
                "command": "str_replace"
              },
              "orig_args": {
                "summary": "Fix method name from addMessage to indexMessage in WhatsApp listener",
                "path": "./whatsapp-indexer/src/whatsapp-listener.js",
                "old_str": "        // Add to vector store for semantic search\n        await this.vectorStore.addMessage(processedMessage);",
                "new_str": "        // Add to vector store for semantic search\n        await this.vectorStore.indexMessage(processedMessage);",
                "command": "str_replace"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_17RE6vvmRbKzbjomaYflvw",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "85e5e062-8da7-4765-983a-7126258f0dd1",
          "content": "Now let me check if the vector store has a `search` method or if it's called something else:",
          "tool_uses": [
            {
              "id": "tooluse_ZekL8uQGQceQE-ajSkO-AQ",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Search",
                "pattern": "async.*search",
                "path": "./whatsapp-indexer/src/local-vector-store.js"
              },
              "orig_args": {
                "mode": "Search",
                "pattern": "async.*search",
                "path": "./whatsapp-indexer/src/local-vector-store.js"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_ZekL8uQGQceQE-ajSkO-AQ",
                "content": [
                  {
                    "Text": "[]"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "78cca577-dad4-4e02-b827-3766956176b1",
          "content": "",
          "tool_uses": [
            {
              "id": "tooluse_tMpItYhDTOKZLEEqPtplUg",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "pattern": "searchSimilar",
                "mode": "Search",
                "path": "./whatsapp-indexer/src/local-vector-store.js"
              },
              "orig_args": {
                "pattern": "searchSimilar",
                "mode": "Search",
                "path": "./whatsapp-indexer/src/local-vector-store.js"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_tMpItYhDTOKZLEEqPtplUg",
                "content": [
                  {
                    "Text": "[{\"line_number\":187,\"context\":\"  185:   }\\n  186: \\n→ 187:   async searchSimilar(query, options = {}) {\\n  188:     const {\\n  189:       topK = 10,\\n\"}]"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "794ace28-a47e-4149-89fc-8c058e7acdf2",
          "content": "I need to update the MCP server to use the correct method name:",
          "tool_uses": [
            {
              "id": "tooluse_9Uswn6IUSsaTQihVmzUpSw",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Fix method name from search to searchSimilar in MCP server",
                "path": "./whatsapp-indexer/src/mcp-server-standalone.js",
                "new_str": "      const results = await this.vectorStore.searchSimilar(query, { topK: limit });",
                "old_str": "      const results = await this.vectorStore.search(query, limit);",
                "command": "str_replace"
              },
              "orig_args": {
                "summary": "Fix method name from search to searchSimilar in MCP server",
                "path": "./whatsapp-indexer/src/mcp-server-standalone.js",
                "new_str": "      const results = await this.vectorStore.searchSimilar(query, { topK: limit });",
                "old_str": "      const results = await this.vectorStore.search(query, limit);",
                "command": "str_replace"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_9Uswn6IUSsaTQihVmzUpSw",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "c6301f69-d6d5-4a01-aeba-e4f25fe1ee99",
          "content": "",
          "tool_uses": [
            {
              "id": "tooluse_nmGT0k3BRTqw-wlWceahXA",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Fix method name from search to searchSimilar in MCP server for scheduling search",
                "path": "./whatsapp-indexer/src/mcp-server-standalone.js",
                "new_str": "      const results = await this.vectorStore.searchSimilar(schedulingQuery, { topK: 20 });",
                "old_str": "      const results = await this.vectorStore.search(schedulingQuery, 20);",
                "command": "str_replace"
              },
              "orig_args": {
                "summary": "Fix method name from search to searchSimilar in MCP server for scheduling search",
                "path": "./whatsapp-indexer/src/mcp-server-standalone.js",
                "new_str": "      const results = await this.vectorStore.searchSimilar(schedulingQuery, { topK: 20 });",
                "old_str": "      const results = await this.vectorStore.search(schedulingQuery, 20);",
                "command": "str_replace"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_nmGT0k3BRTqw-wlWceahXA",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "9d016e55-80ee-44ba-a8e6-08014332a4e4",
          "content": "",
          "tool_uses": [
            {
              "id": "tooluse_93xHr6O5SiKKm5MIXOBsPw",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Fix method name from search to searchSimilar in MCP server for plans search",
                "path": "./whatsapp-indexer/src/mcp-server-standalone.js",
                "new_str": "      const results = await this.vectorStore.searchSimilar(planQuery, { topK: 50 });",
                "old_str": "      const results = await this.vectorStore.search(planQuery, 50);",
                "command": "str_replace"
              },
              "orig_args": {
                "summary": "Fix method name from search to searchSimilar in MCP server for plans search",
                "path": "./whatsapp-indexer/src/mcp-server-standalone.js",
                "new_str": "      const results = await this.vectorStore.searchSimilar(planQuery, { topK: 50 });",
                "old_str": "      const results = await this.vectorStore.search(planQuery, 50);",
                "command": "str_replace"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_93xHr6O5SiKKm5MIXOBsPw",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "1604d280-7bcd-4d1a-bb48-beb33e71df94",
          "content": "Now let me create updated startup scripts for the new architecture:",
          "tool_uses": [
            {
              "id": "tooluse_xi882H4IQoOb5Hz2ohRlSA",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Create startup script for the standalone MCP server",
                "path": "./whatsapp-indexer/start-mcp-standalone.sh",
                "file_text": "#!/bin/bash\n\n# Start the standalone WhatsApp MCP Server\n# This server only reads from the database/vector store and doesn't connect to WhatsApp\n\necho \"🚀 Starting WhatsApp MCP Server (Standalone)...\"\necho \"📝 This server only reads from the indexed data and doesn't connect to WhatsApp\"\necho \"🔄 Make sure the WhatsApp Listener Service is running separately to index new messages\"\necho \"\"\n\n# Set NODE_ENV if not set\nexport NODE_ENV=${NODE_ENV:-production}\n\n# Start the MCP server\nnode src/mcp-server-standalone.js",
                "command": "create"
              },
              "orig_args": {
                "summary": "Create startup script for the standalone MCP server",
                "path": "./whatsapp-indexer/start-mcp-standalone.sh",
                "file_text": "#!/bin/bash\n\n# Start the standalone WhatsApp MCP Server\n# This server only reads from the database/vector store and doesn't connect to WhatsApp\n\necho \"🚀 Starting WhatsApp MCP Server (Standalone)...\"\necho \"📝 This server only reads from the indexed data and doesn't connect to WhatsApp\"\necho \"🔄 Make sure the WhatsApp Listener Service is running separately to index new messages\"\necho \"\"\n\n# Set NODE_ENV if not set\nexport NODE_ENV=${NODE_ENV:-production}\n\n# Start the MCP server\nnode src/mcp-server-standalone.js",
                "command": "create"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_xi882H4IQoOb5Hz2ohRlSA",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "5488ec56-2365-4964-b2d8-f4cc0ba13c7e",
          "content": "",
          "tool_uses": [
            {
              "id": "tooluse_ATMs0UTRQEujOFcldi5SxA",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Create startup script for the WhatsApp listener service",
                "path": "./whatsapp-indexer/start-listener.sh",
                "file_text": "#!/bin/bash\n\n# Start the WhatsApp Listener Service\n# This service connects to WhatsApp, receives messages, and updates the index\n\necho \"🚀 Starting WhatsApp Listener Service...\"\necho \"📱 This service will connect to WhatsApp and index new messages\"\necho \"🔍 The MCP server can be run separately to query the indexed data\"\necho \"\"\n\n# Set NODE_ENV if not set\nexport NODE_ENV=${NODE_ENV:-production}\n\n# Start the listener service\nnode src/whatsapp-listener.js",
                "command": "create"
              },
              "orig_args": {
                "summary": "Create startup script for the WhatsApp listener service",
                "path": "./whatsapp-indexer/start-listener.sh",
                "file_text": "#!/bin/bash\n\n# Start the WhatsApp Listener Service\n# This service connects to WhatsApp, receives messages, and updates the index\n\necho \"🚀 Starting WhatsApp Listener Service...\"\necho \"📱 This service will connect to WhatsApp and index new messages\"\necho \"🔍 The MCP server can be run separately to query the indexed data\"\necho \"\"\n\n# Set NODE_ENV if not set\nexport NODE_ENV=${NODE_ENV:-production}\n\n# Start the listener service\nnode src/whatsapp-listener.js",
                "command": "create"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_ATMs0UTRQEujOFcldi5SxA",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "7ee4112c-b5cf-4cce-af1d-c250e5c8640e",
          "content": "",
          "tool_uses": [
            {
              "id": "tooluse_0IbAIBTBTB6GAPIaBnJnPQ",
              "name": "execute_bash",
              "orig_name": "execute_bash",
              "args": {
                "summary": "Make the new startup scripts executable",
                "command": "chmod +x ./whatsapp-indexer/start-mcp-standalone.sh ./whatsapp-indexer/start-listener.sh"
              },
              "orig_args": {
                "summary": "Make the new startup scripts executable",
                "command": "chmod +x ./whatsapp-indexer/start-mcp-standalone.sh ./whatsapp-indexer/start-listener.sh"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_0IbAIBTBTB6GAPIaBnJnPQ",
                "content": [
                  {
                    "Json": {
                      "exit_status": "0",
                      "stdout": "",
                      "stderr": ""
                    }
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "f9cc5b1b-8d81-4a1b-82d4-2395cd40230d",
          "content": "Now let me update the README to document the new architecture:",
          "tool_uses": [
            {
              "id": "tooluse_3Ex5OHx1TGOeJO5EENWbhw",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Update README to document the new decoupled architecture",
                "path": "./whatsapp-indexer/README.md",
                "new_str": "# WhatsApp Indexer\n\nA WhatsApp message indexer that provides semantic search capabilities through a Model Context Protocol (MCP) server. The system is designed with a decoupled architecture where the MCP server only reads from the indexed data, while a separate service handles WhatsApp message listening and indexing.\n\n## Architecture\n\nThe system consists of two main components:\n\n### 1. WhatsApp Listener Service (`whatsapp-listener.js`)\n- Connects to WhatsApp Web using `whatsapp-web.js`\n- Receives and processes incoming/outgoing messages\n- Extracts URLs and metadata from messages\n- Stores messages in SQLite database\n- Indexes messages in a local vector store for semantic search\n- Runs independently and continuously processes messages\n\n### 2. MCP Server (`mcp-server-standalone.js`)\n- Provides MCP tools for querying indexed messages\n- Only reads from the database and vector store\n- Does not connect to WhatsApp directly\n- Can run independently of the WhatsApp connection\n- Provides semantic search, URL extraction, and date-based queries\n\n## Features\n\n- **Semantic Search**: Find messages using natural language queries\n- **URL Extraction**: Automatically extract and index URLs from messages\n- **Date-based Queries**: Search messages by date ranges\n- **Sender Filtering**: Filter messages by specific senders\n- **Schedule Detection**: Find scheduling-related conversations\n- **Plan Checking**: Check for plans on specific days\n- **Persistent Storage**: SQLite database with full-text search\n- **Vector Search**: Local FAISS-based semantic search using Transformers.js\n\n## Installation\n\n1. Clone the repository\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Copy the environment configuration:\n   ```bash\n   cp .env.example .env\n   ```\n\n4. Edit `.env` with your preferred settings (optional - defaults work fine)\n\n## Usage\n\n### Option 1: Run Both Services (Recommended)\n\n1. **Start the WhatsApp Listener Service** (in one terminal):\n   ```bash\n   ./start-listener.sh\n   ```\n   - Scan the QR code with your WhatsApp mobile app\n   - Wait for \"WhatsApp client is ready!\" message\n   - Leave this running to continuously index new messages\n\n2. **Start the MCP Server** (in another terminal):\n   ```bash\n   ./start-mcp-standalone.sh\n   ```\n   - This provides the MCP tools for querying messages\n   - Can be restarted without affecting WhatsApp connection\n\n### Option 2: MCP Server Only (Query Existing Data)\n\nIf you already have indexed messages and just want to query them:\n\n```bash\n./start-mcp-standalone.sh\n```\n\n### Option 3: Legacy Combined Mode (Not Recommended)\n\nFor backward compatibility, you can still run the old combined mode:\n\n```bash\n./start-mcp.sh\n```\n\n## MCP Tools\n\nThe MCP server provides the following tools:\n\n### `whatsapp_status`\nCheck the status of the WhatsApp indexer service\n- Shows total indexed messages\n- Shows last message timestamp\n- Indicates if the system is ready\n\n### `search_messages`\nSearch messages using natural language queries\n- **query** (required): Natural language search query\n- **limit** (optional): Maximum results to return (default: 10)\n\nExample: \"find the restaurant recommendation from John\"\n\n### `get_urls_by_sender`\nGet all URLs shared by a specific person\n- **sender_name** (required): Name of the sender\n- **limit** (optional): Maximum URLs to return (default: 20)\n\n### `get_messages_by_date`\nGet messages from a specific date or date range\n- **date_query** (required): Date in natural language (e.g., \"today\", \"last Monday\")\n- **sender_name** (optional): Filter by specific sender\n\n### `find_schedule_with_person`\nFind scheduling-related messages with a specific person\n- **person_name** (required): Name of the person\n- **time_period** (optional): Time period to search (default: \"this week\")\n\n### `check_plans_for_day`\nCheck for plans or appointments on a specific day\n- **day** (required): Day to check (e.g., \"Wednesday\", \"tomorrow\")\n\n## Configuration\n\nEdit `.env` to customize:\n\n```env\n# Database\nDATABASE_PATH=./data/messages.db\n\n# Vector Store\nVECTOR_STORE_PATH=./data/vectors\nVECTOR_MODEL=Xenova/all-MiniLM-L6-v2\nVECTOR_DIMENSION=384\n\n# Logging\nLOG_LEVEL=info\n```\n\n## Data Storage\n\n- **SQLite Database**: `./data/messages.db` - Stores message content, metadata, and URLs\n- **Vector Store**: `./data/vectors/` - FAISS index and metadata for semantic search\n- **WhatsApp Session**: `./.wwebjs_auth/` - WhatsApp Web authentication data\n\n## Architecture Benefits\n\n### Decoupled Design\n- MCP server can run without WhatsApp connection\n- WhatsApp listener can restart without affecting queries\n- Better reliability and maintainability\n\n### Scalability\n- Multiple MCP servers can read from the same data\n- WhatsApp listener runs independently\n- Easy to add more data sources\n\n### Development\n- Test MCP tools without WhatsApp setup\n- Develop features using existing data\n- Clear separation of concerns\n\n## Troubleshooting\n\n### WhatsApp Connection Issues\n- Make sure only the listener service connects to WhatsApp\n- Check QR code scanning in the listener terminal\n- Restart only the listener service if connection fails\n\n### MCP Server Issues\n- MCP server doesn't need WhatsApp connection\n- Check if database and vector store files exist\n- Restart MCP server independently\n\n### No Messages Found\n- Ensure WhatsApp listener service is running\n- Check that messages are being indexed (watch listener logs)\n- Verify database has data: check `./data/messages.db`\n\n### Performance\n- Vector search may be slow on first run (model download)\n- Subsequent searches are much faster\n- Consider adjusting `VECTOR_DIMENSION` for speed vs accuracy\n\n## Development\n\n### Project Structure\n```\nsrc/\n├── mcp-server-standalone.js    # Standalone MCP server\n├── whatsapp-listener.js        # WhatsApp message listener\n├── database.js                 # SQLite database operations\n├── local-vector-store.js       # FAISS vector store\n├── message-processor.js        # Message processing logic\n├── config.js                   # Configuration management\n└── mcp-server.js              # Legacy combined server\n```\n\n### Adding New Features\n1. Add database schema changes in `database.js`\n2. Update message processing in `message-processor.js`\n3. Add new MCP tools in `mcp-server-standalone.js`\n4. Update vector indexing if needed in `local-vector-store.js`\n\n## License\n\nMIT License",
                "old_str": "# WhatsApp Indexer\n\nA WhatsApp message indexer that provides semantic search capabilities through a Model Context Protocol (MCP) server.\n\n## Features\n\n- **Semantic Search**: Find messages using natural language queries\n- **URL Extraction**: Automatically extract and index URLs from messages\n- **Date-based Queries**: Search messages by date ranges\n- **Sender Filtering**: Filter messages by specific senders\n- **Schedule Detection**: Find scheduling-related conversations\n- **Plan Checking**: Check for plans on specific days\n- **Persistent Storage**: SQLite database with full-text search\n- **Vector Search**: Local FAISS-based semantic search using Transformers.js\n\n## Installation\n\n1. Clone the repository\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Copy the environment configuration:\n   ```bash\n   cp .env.example .env\n   ```\n\n4. Edit `.env` with your preferred settings (optional - defaults work fine)\n\n## Usage\n\n### Starting the MCP Server\n\n```bash\n./start-mcp.sh\n```\n\nOn first run:\n1. A QR code will appear in the terminal\n2. Scan it with your WhatsApp mobile app\n3. Wait for \"WhatsApp client is ready!\" message\n4. The MCP server will start and begin indexing messages\n\n### Starting the Indexer Only\n\nIf you want to run just the indexing service without the MCP server:\n\n```bash\n./start-indexer.sh\n```\n\n## MCP Tools\n\nThe MCP server provides the following tools:\n\n### `whatsapp_status`\nCheck the status of the WhatsApp client connection\n\n### `search_messages`\nSearch messages using natural language queries\n- **query** (required): Natural language search query\n- **limit** (optional): Maximum results to return (default: 10)\n\nExample: \"find the restaurant recommendation from John\"\n\n### `get_urls_by_sender`\nGet all URLs shared by a specific person\n- **sender_name** (required): Name of the sender\n- **limit** (optional): Maximum URLs to return (default: 20)\n\n### `get_messages_by_date`\nGet messages from a specific date or date range\n- **date_query** (required): Date in natural language (e.g., \"today\", \"last Monday\")\n- **sender_name** (optional): Filter by specific sender\n\n### `find_schedule_with_person`\nFind scheduling-related messages with a specific person\n- **person_name** (required): Name of the person\n- **time_period** (optional): Time period to search (default: \"this week\")\n\n### `check_plans_for_day`\nCheck for plans or appointments on a specific day\n- **day** (required): Day to check (e.g., \"Wednesday\", \"tomorrow\")\n\n## Configuration\n\nEdit `.env` to customize:\n\n```env\n# Database\nDATABASE_PATH=./data/messages.db\n\n# Vector Store\nVECTOR_STORE_PATH=./data/vectors\nVECTOR_MODEL=Xenova/all-MiniLM-L6-v2\nVECTOR_DIMENSION=384\n\n# Logging\nLOG_LEVEL=info\n```\n\n## Data Storage\n\n- **SQLite Database**: `./data/messages.db` - Stores message content, metadata, and URLs\n- **Vector Store**: `./data/vectors/` - FAISS index and metadata for semantic search\n- **WhatsApp Session**: `./.wwebjs_auth/` - WhatsApp Web authentication data\n\n## How It Works\n\n1. **WhatsApp Connection**: Uses `whatsapp-web.js` to connect to WhatsApp Web\n2. **Message Processing**: Extracts text, URLs, and metadata from messages\n3. **Database Storage**: Stores messages in SQLite with full-text search\n4. **Vector Indexing**: Creates embeddings using Transformers.js and stores in FAISS\n5. **MCP Interface**: Provides tools for semantic search and data retrieval\n\n## Troubleshooting\n\n### Authentication Issues\n- Delete `.wwebjs_auth` folder and restart\n- Make sure WhatsApp Web is not open in browser\n- Try scanning QR code again\n\n### Performance Issues\n- Vector search may be slow on first run (model download)\n- Subsequent searches are much faster\n- Consider adjusting `VECTOR_DIMENSION` for speed vs accuracy\n\n### No Messages Found\n- Wait for initial message indexing to complete\n- Check that WhatsApp client shows \"ready\" status\n- Verify messages exist in the specified date range\n\n## Development\n\n### Project Structure\n```\nsrc/\n├── index.js                 # Main entry point\n├── mcp-server.js           # MCP server implementation\n├── whatsapp-client.js      # WhatsApp client wrapper\n├── database.js             # SQLite database operations\n├── local-vector-store.js   # FAISS vector store\n├── message-processor.js    # Message processing logic\n└── config.js              # Configuration management\n```\n\n### Adding New Features\n1. Add new MCP tools in `mcp-server.js`\n2. Extend database schema in `database.js`\n3. Update message processing in `message-processor.js`\n4. Add vector search capabilities in `local-vector-store.js`\n\n## License\n\nMIT License",
                "command": "str_replace"
              },
              "orig_args": {
                "summary": "Update README to document the new decoupled architecture",
                "path": "./whatsapp-indexer/README.md",
                "new_str": "# WhatsApp Indexer\n\nA WhatsApp message indexer that provides semantic search capabilities through a Model Context Protocol (MCP) server. The system is designed with a decoupled architecture where the MCP server only reads from the indexed data, while a separate service handles WhatsApp message listening and indexing.\n\n## Architecture\n\nThe system consists of two main components:\n\n### 1. WhatsApp Listener Service (`whatsapp-listener.js`)\n- Connects to WhatsApp Web using `whatsapp-web.js`\n- Receives and processes incoming/outgoing messages\n- Extracts URLs and metadata from messages\n- Stores messages in SQLite database\n- Indexes messages in a local vector store for semantic search\n- Runs independently and continuously processes messages\n\n### 2. MCP Server (`mcp-server-standalone.js`)\n- Provides MCP tools for querying indexed messages\n- Only reads from the database and vector store\n- Does not connect to WhatsApp directly\n- Can run independently of the WhatsApp connection\n- Provides semantic search, URL extraction, and date-based queries\n\n## Features\n\n- **Semantic Search**: Find messages using natural language queries\n- **URL Extraction**: Automatically extract and index URLs from messages\n- **Date-based Queries**: Search messages by date ranges\n- **Sender Filtering**: Filter messages by specific senders\n- **Schedule Detection**: Find scheduling-related conversations\n- **Plan Checking**: Check for plans on specific days\n- **Persistent Storage**: SQLite database with full-text search\n- **Vector Search**: Local FAISS-based semantic search using Transformers.js\n\n## Installation\n\n1. Clone the repository\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Copy the environment configuration:\n   ```bash\n   cp .env.example .env\n   ```\n\n4. Edit `.env` with your preferred settings (optional - defaults work fine)\n\n## Usage\n\n### Option 1: Run Both Services (Recommended)\n\n1. **Start the WhatsApp Listener Service** (in one terminal):\n   ```bash\n   ./start-listener.sh\n   ```\n   - Scan the QR code with your WhatsApp mobile app\n   - Wait for \"WhatsApp client is ready!\" message\n   - Leave this running to continuously index new messages\n\n2. **Start the MCP Server** (in another terminal):\n   ```bash\n   ./start-mcp-standalone.sh\n   ```\n   - This provides the MCP tools for querying messages\n   - Can be restarted without affecting WhatsApp connection\n\n### Option 2: MCP Server Only (Query Existing Data)\n\nIf you already have indexed messages and just want to query them:\n\n```bash\n./start-mcp-standalone.sh\n```\n\n### Option 3: Legacy Combined Mode (Not Recommended)\n\nFor backward compatibility, you can still run the old combined mode:\n\n```bash\n./start-mcp.sh\n```\n\n## MCP Tools\n\nThe MCP server provides the following tools:\n\n### `whatsapp_status`\nCheck the status of the WhatsApp indexer service\n- Shows total indexed messages\n- Shows last message timestamp\n- Indicates if the system is ready\n\n### `search_messages`\nSearch messages using natural language queries\n- **query** (required): Natural language search query\n- **limit** (optional): Maximum results to return (default: 10)\n\nExample: \"find the restaurant recommendation from John\"\n\n### `get_urls_by_sender`\nGet all URLs shared by a specific person\n- **sender_name** (required): Name of the sender\n- **limit** (optional): Maximum URLs to return (default: 20)\n\n### `get_messages_by_date`\nGet messages from a specific date or date range\n- **date_query** (required): Date in natural language (e.g., \"today\", \"last Monday\")\n- **sender_name** (optional): Filter by specific sender\n\n### `find_schedule_with_person`\nFind scheduling-related messages with a specific person\n- **person_name** (required): Name of the person\n- **time_period** (optional): Time period to search (default: \"this week\")\n\n### `check_plans_for_day`\nCheck for plans or appointments on a specific day\n- **day** (required): Day to check (e.g., \"Wednesday\", \"tomorrow\")\n\n## Configuration\n\nEdit `.env` to customize:\n\n```env\n# Database\nDATABASE_PATH=./data/messages.db\n\n# Vector Store\nVECTOR_STORE_PATH=./data/vectors\nVECTOR_MODEL=Xenova/all-MiniLM-L6-v2\nVECTOR_DIMENSION=384\n\n# Logging\nLOG_LEVEL=info\n```\n\n## Data Storage\n\n- **SQLite Database**: `./data/messages.db` - Stores message content, metadata, and URLs\n- **Vector Store**: `./data/vectors/` - FAISS index and metadata for semantic search\n- **WhatsApp Session**: `./.wwebjs_auth/` - WhatsApp Web authentication data\n\n## Architecture Benefits\n\n### Decoupled Design\n- MCP server can run without WhatsApp connection\n- WhatsApp listener can restart without affecting queries\n- Better reliability and maintainability\n\n### Scalability\n- Multiple MCP servers can read from the same data\n- WhatsApp listener runs independently\n- Easy to add more data sources\n\n### Development\n- Test MCP tools without WhatsApp setup\n- Develop features using existing data\n- Clear separation of concerns\n\n## Troubleshooting\n\n### WhatsApp Connection Issues\n- Make sure only the listener service connects to WhatsApp\n- Check QR code scanning in the listener terminal\n- Restart only the listener service if connection fails\n\n### MCP Server Issues\n- MCP server doesn't need WhatsApp connection\n- Check if database and vector store files exist\n- Restart MCP server independently\n\n### No Messages Found\n- Ensure WhatsApp listener service is running\n- Check that messages are being indexed (watch listener logs)\n- Verify database has data: check `./data/messages.db`\n\n### Performance\n- Vector search may be slow on first run (model download)\n- Subsequent searches are much faster\n- Consider adjusting `VECTOR_DIMENSION` for speed vs accuracy\n\n## Development\n\n### Project Structure\n```\nsrc/\n├── mcp-server-standalone.js    # Standalone MCP server\n├── whatsapp-listener.js        # WhatsApp message listener\n├── database.js                 # SQLite database operations\n├── local-vector-store.js       # FAISS vector store\n├── message-processor.js        # Message processing logic\n├── config.js                   # Configuration management\n└── mcp-server.js              # Legacy combined server\n```\n\n### Adding New Features\n1. Add database schema changes in `database.js`\n2. Update message processing in `message-processor.js`\n3. Add new MCP tools in `mcp-server-standalone.js`\n4. Update vector indexing if needed in `local-vector-store.js`\n\n## License\n\nMIT License",
                "old_str": "# WhatsApp Indexer\n\nA WhatsApp message indexer that provides semantic search capabilities through a Model Context Protocol (MCP) server.\n\n## Features\n\n- **Semantic Search**: Find messages using natural language queries\n- **URL Extraction**: Automatically extract and index URLs from messages\n- **Date-based Queries**: Search messages by date ranges\n- **Sender Filtering**: Filter messages by specific senders\n- **Schedule Detection**: Find scheduling-related conversations\n- **Plan Checking**: Check for plans on specific days\n- **Persistent Storage**: SQLite database with full-text search\n- **Vector Search**: Local FAISS-based semantic search using Transformers.js\n\n## Installation\n\n1. Clone the repository\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Copy the environment configuration:\n   ```bash\n   cp .env.example .env\n   ```\n\n4. Edit `.env` with your preferred settings (optional - defaults work fine)\n\n## Usage\n\n### Starting the MCP Server\n\n```bash\n./start-mcp.sh\n```\n\nOn first run:\n1. A QR code will appear in the terminal\n2. Scan it with your WhatsApp mobile app\n3. Wait for \"WhatsApp client is ready!\" message\n4. The MCP server will start and begin indexing messages\n\n### Starting the Indexer Only\n\nIf you want to run just the indexing service without the MCP server:\n\n```bash\n./start-indexer.sh\n```\n\n## MCP Tools\n\nThe MCP server provides the following tools:\n\n### `whatsapp_status`\nCheck the status of the WhatsApp client connection\n\n### `search_messages`\nSearch messages using natural language queries\n- **query** (required): Natural language search query\n- **limit** (optional): Maximum results to return (default: 10)\n\nExample: \"find the restaurant recommendation from John\"\n\n### `get_urls_by_sender`\nGet all URLs shared by a specific person\n- **sender_name** (required): Name of the sender\n- **limit** (optional): Maximum URLs to return (default: 20)\n\n### `get_messages_by_date`\nGet messages from a specific date or date range\n- **date_query** (required): Date in natural language (e.g., \"today\", \"last Monday\")\n- **sender_name** (optional): Filter by specific sender\n\n### `find_schedule_with_person`\nFind scheduling-related messages with a specific person\n- **person_name** (required): Name of the person\n- **time_period** (optional): Time period to search (default: \"this week\")\n\n### `check_plans_for_day`\nCheck for plans or appointments on a specific day\n- **day** (required): Day to check (e.g., \"Wednesday\", \"tomorrow\")\n\n## Configuration\n\nEdit `.env` to customize:\n\n```env\n# Database\nDATABASE_PATH=./data/messages.db\n\n# Vector Store\nVECTOR_STORE_PATH=./data/vectors\nVECTOR_MODEL=Xenova/all-MiniLM-L6-v2\nVECTOR_DIMENSION=384\n\n# Logging\nLOG_LEVEL=info\n```\n\n## Data Storage\n\n- **SQLite Database**: `./data/messages.db` - Stores message content, metadata, and URLs\n- **Vector Store**: `./data/vectors/` - FAISS index and metadata for semantic search\n- **WhatsApp Session**: `./.wwebjs_auth/` - WhatsApp Web authentication data\n\n## How It Works\n\n1. **WhatsApp Connection**: Uses `whatsapp-web.js` to connect to WhatsApp Web\n2. **Message Processing**: Extracts text, URLs, and metadata from messages\n3. **Database Storage**: Stores messages in SQLite with full-text search\n4. **Vector Indexing**: Creates embeddings using Transformers.js and stores in FAISS\n5. **MCP Interface**: Provides tools for semantic search and data retrieval\n\n## Troubleshooting\n\n### Authentication Issues\n- Delete `.wwebjs_auth` folder and restart\n- Make sure WhatsApp Web is not open in browser\n- Try scanning QR code again\n\n### Performance Issues\n- Vector search may be slow on first run (model download)\n- Subsequent searches are much faster\n- Consider adjusting `VECTOR_DIMENSION` for speed vs accuracy\n\n### No Messages Found\n- Wait for initial message indexing to complete\n- Check that WhatsApp client shows \"ready\" status\n- Verify messages exist in the specified date range\n\n## Development\n\n### Project Structure\n```\nsrc/\n├── index.js                 # Main entry point\n├── mcp-server.js           # MCP server implementation\n├── whatsapp-client.js      # WhatsApp client wrapper\n├── database.js             # SQLite database operations\n├── local-vector-store.js   # FAISS vector store\n├── message-processor.js    # Message processing logic\n└── config.js              # Configuration management\n```\n\n### Adding New Features\n1. Add new MCP tools in `mcp-server.js`\n2. Extend database schema in `database.js`\n3. Update message processing in `message-processor.js`\n4. Add vector search capabilities in `local-vector-store.js`\n\n## License\n\nMIT License",
                "command": "str_replace"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_3Ex5OHx1TGOeJO5EENWbhw",
                "content": [
                  {
                    "Text": "An error occurred processing the tool: \nno occurrences of \"# WhatsApp Indexer\n\nA WhatsApp message indexer that provides semantic search capabilities through a Model Context Protocol (MCP) server.\n\n## Features\n\n- **Semantic Search**: Find messages using natural language queries\n- **URL Extraction**: Automatically extract and index URLs from messages\n- **Date-based Queries**: Search messages by date ranges\n- **Sender Filtering**: Filter messages by specific senders\n- **Schedule Detection**: Find scheduling-related conversations\n- **Plan Checking**: Check for plans on specific days\n- **Persistent Storage**: SQLite database with full-text search\n- **Vector Search**: Local FAISS-based semantic search using Transformers.js\n\n## Installation\n\n1. Clone the repository\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Copy the environment configuration:\n   ```bash\n   cp .env.example .env\n   ```\n\n4. Edit `.env` with your preferred settings (optional - defaults work fine)\n\n## Usage\n\n### Starting the MCP Server\n\n```bash\n./start-mcp.sh\n```\n\nOn first run:\n1. A QR code will appear in the terminal\n2. Scan it with your WhatsApp mobile app\n3. Wait for \"WhatsApp client is ready!\" message\n4. The MCP server will start and begin indexing messages\n\n### Starting the Indexer Only\n\nIf you want to run just the indexing service without the MCP server:\n\n```bash\n./start-indexer.sh\n```\n\n## MCP Tools\n\nThe MCP server provides the following tools:\n\n### `whatsapp_status`\nCheck the status of the WhatsApp client connection\n\n### `search_messages`\nSearch messages using natural language queries\n- **query** (required): Natural language search query\n- **limit** (optional): Maximum results to return (default: 10)\n\nExample: \"find the restaurant recommendation from John\"\n\n### `get_urls_by_sender`\nGet all URLs shared by a specific person\n- **sender_name** (required): Name of the sender\n- **limit** (optional): Maximum URLs to return (default: 20)\n\n### `get_messages_by_date`\nGet messages from a specific date or date range\n- **date_query** (required): Date in natural language (e.g., \"today\", \"last Monday\")\n- **sender_name** (optional): Filter by specific sender\n\n### `find_schedule_with_person`\nFind scheduling-related messages with a specific person\n- **person_name** (required): Name of the person\n- **time_period** (optional): Time period to search (default: \"this week\")\n\n### `check_plans_for_day`\nCheck for plans or appointments on a specific day\n- **day** (required): Day to check (e.g., \"Wednesday\", \"tomorrow\")\n\n## Configuration\n\nEdit `.env` to customize:\n\n```env\n# Database\nDATABASE_PATH=./data/messages.db\n\n# Vector Store\nVECTOR_STORE_PATH=./data/vectors\nVECTOR_MODEL=Xenova/all-MiniLM-L6-v2\nVECTOR_DIMENSION=384\n\n# Logging\nLOG_LEVEL=info\n```\n\n## Data Storage\n\n- **SQLite Database**: `./data/messages.db` - Stores message content, metadata, and URLs\n- **Vector Store**: `./data/vectors/` - FAISS index and metadata for semantic search\n- **WhatsApp Session**: `./.wwebjs_auth/` - WhatsApp Web authentication data\n\n## How It Works\n\n1. **WhatsApp Connection**: Uses `whatsapp-web.js` to connect to WhatsApp Web\n2. **Message Processing**: Extracts text, URLs, and metadata from messages\n3. **Database Storage**: Stores messages in SQLite with full-text search\n4. **Vector Indexing**: Creates embeddings using Transformers.js and stores in FAISS\n5. **MCP Interface**: Provides tools for semantic search and data retrieval\n\n## Troubleshooting\n\n### Authentication Issues\n- Delete `.wwebjs_auth` folder and restart\n- Make sure WhatsApp Web is not open in browser\n- Try scanning QR code again\n\n### Performance Issues\n- Vector search may be slow on first run (model download)\n- Subsequent searches are much faster\n- Consider adjusting `VECTOR_DIMENSION` for speed vs accuracy\n\n### No Messages Found\n- Wait for initial message indexing to complete\n- Check that WhatsApp client shows \"ready\" status\n- Verify messages exist in the specified date range\n\n## Development\n\n### Project Structure\n```\nsrc/\n├── index.js                 # Main entry point\n├── mcp-server.js           # MCP server implementation\n├── whatsapp-client.js      # WhatsApp client wrapper\n├── database.js             # SQLite database operations\n├── local-vector-store.js   # FAISS vector store\n├── message-processor.js    # Message processing logic\n└── config.js              # Configuration management\n```\n\n### Adding New Features\n1. Add new MCP tools in `mcp-server.js`\n2. Extend database schema in `database.js`\n3. Update message processing in `message-processor.js`\n4. Add vector search capabilities in `local-vector-store.js`\n\n## License\n\nMIT License\" were found"
                  }
                ],
                "status": "Error"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "61c70714-fbc1-4392-afd6-8625d1fec7ab",
          "content": "Let me rewrite the entire README file:",
          "tool_uses": [
            {
              "id": "tooluse_Kbhj0fZVQ2e7QrgI9-Wjag",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Rewrite the entire README with the new decoupled architecture documentation",
                "path": "./whatsapp-indexer/README.md",
                "file_text": "# WhatsApp Indexer\n\nA WhatsApp message indexer that provides semantic search capabilities through a Model Context Protocol (MCP) server. The system is designed with a decoupled architecture where the MCP server only reads from the indexed data, while a separate service handles WhatsApp message listening and indexing.\n\n## Architecture\n\nThe system consists of two main components:\n\n### 1. WhatsApp Listener Service (`whatsapp-listener.js`)\n- Connects to WhatsApp Web using `whatsapp-web.js`\n- Receives and processes incoming/outgoing messages\n- Extracts URLs and metadata from messages\n- Stores messages in SQLite database\n- Indexes messages in a local vector store for semantic search\n- Runs independently and continuously processes messages\n\n### 2. MCP Server (`mcp-server-standalone.js`)\n- Provides MCP tools for querying indexed messages\n- Only reads from the database and vector store\n- Does not connect to WhatsApp directly\n- Can run independently of the WhatsApp connection\n- Provides semantic search, URL extraction, and date-based queries\n\n## Features\n\n- **Semantic Search**: Find messages using natural language queries\n- **URL Extraction**: Automatically extract and index URLs from messages\n- **Date-based Queries**: Search messages by date ranges\n- **Sender Filtering**: Filter messages by specific senders\n- **Schedule Detection**: Find scheduling-related conversations\n- **Plan Checking**: Check for plans on specific days\n- **Persistent Storage**: SQLite database with full-text search\n- **Vector Search**: Local FAISS-based semantic search using Transformers.js\n\n## Installation\n\n1. Clone the repository\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Copy the environment configuration:\n   ```bash\n   cp .env.example .env\n   ```\n\n4. Edit `.env` with your preferred settings (optional - defaults work fine)\n\n## Usage\n\n### Option 1: Run Both Services (Recommended)\n\n1. **Start the WhatsApp Listener Service** (in one terminal):\n   ```bash\n   ./start-listener.sh\n   ```\n   - Scan the QR code with your WhatsApp mobile app\n   - Wait for \"WhatsApp client is ready!\" message\n   - Leave this running to continuously index new messages\n\n2. **Start the MCP Server** (in another terminal):\n   ```bash\n   ./start-mcp-standalone.sh\n   ```\n   - This provides the MCP tools for querying messages\n   - Can be restarted without affecting WhatsApp connection\n\n### Option 2: MCP Server Only (Query Existing Data)\n\nIf you already have indexed messages and just want to query them:\n\n```bash\n./start-mcp-standalone.sh\n```\n\n### Option 3: Legacy Combined Mode (Not Recommended)\n\nFor backward compatibility, you can still run the old combined mode:\n\n```bash\n./start-mcp.sh\n```\n\n## MCP Tools\n\nThe MCP server provides the following tools:\n\n### `whatsapp_status`\nCheck the status of the WhatsApp indexer service\n- Shows total indexed messages\n- Shows last message timestamp\n- Indicates if the system is ready\n\n### `search_messages`\nSearch messages using natural language queries\n- **query** (required): Natural language search query\n- **limit** (optional): Maximum results to return (default: 10)\n\nExample: \"find the restaurant recommendation from John\"\n\n### `get_urls_by_sender`\nGet all URLs shared by a specific person\n- **sender_name** (required): Name of the sender\n- **limit** (optional): Maximum URLs to return (default: 20)\n\n### `get_messages_by_date`\nGet messages from a specific date or date range\n- **date_query** (required): Date in natural language (e.g., \"today\", \"last Monday\")\n- **sender_name** (optional): Filter by specific sender\n\n### `find_schedule_with_person`\nFind scheduling-related messages with a specific person\n- **person_name** (required): Name of the person\n- **time_period** (optional): Time period to search (default: \"this week\")\n\n### `check_plans_for_day`\nCheck for plans or appointments on a specific day\n- **day** (required): Day to check (e.g., \"Wednesday\", \"tomorrow\")\n\n## Configuration\n\nEdit `.env` to customize:\n\n```env\n# Database\nDATABASE_PATH=./data/messages.db\n\n# Vector Store\nVECTOR_STORE_PATH=./data/vectors\nVECTOR_MODEL=Xenova/all-MiniLM-L6-v2\nVECTOR_DIMENSION=384\n\n# Logging\nLOG_LEVEL=info\n```\n\n## Data Storage\n\n- **SQLite Database**: `./data/messages.db` - Stores message content, metadata, and URLs\n- **Vector Store**: `./data/vectors/` - FAISS index and metadata for semantic search\n- **WhatsApp Session**: `./.wwebjs_auth/` - WhatsApp Web authentication data\n\n## Architecture Benefits\n\n### Decoupled Design\n- MCP server can run without WhatsApp connection\n- WhatsApp listener can restart without affecting queries\n- Better reliability and maintainability\n\n### Scalability\n- Multiple MCP servers can read from the same data\n- WhatsApp listener runs independently\n- Easy to add more data sources\n\n### Development\n- Test MCP tools without WhatsApp setup\n- Develop features using existing data\n- Clear separation of concerns\n\n## Troubleshooting\n\n### WhatsApp Connection Issues\n- Make sure only the listener service connects to WhatsApp\n- Check QR code scanning in the listener terminal\n- Restart only the listener service if connection fails\n\n### MCP Server Issues\n- MCP server doesn't need WhatsApp connection\n- Check if database and vector store files exist\n- Restart MCP server independently\n\n### No Messages Found\n- Ensure WhatsApp listener service is running\n- Check that messages are being indexed (watch listener logs)\n- Verify database has data: check `./data/messages.db`\n\n### Performance\n- Vector search may be slow on first run (model download)\n- Subsequent searches are much faster\n- Consider adjusting `VECTOR_DIMENSION` for speed vs accuracy\n\n## Development\n\n### Project Structure\n```\nsrc/\n├── mcp-server-standalone.js    # Standalone MCP server\n├── whatsapp-listener.js        # WhatsApp message listener\n├── database.js                 # SQLite database operations\n├── local-vector-store.js       # FAISS vector store\n├── message-processor.js        # Message processing logic\n├── config.js                   # Configuration management\n└── mcp-server.js              # Legacy combined server\n```\n\n### Adding New Features\n1. Add database schema changes in `database.js`\n2. Update message processing in `message-processor.js`\n3. Add new MCP tools in `mcp-server-standalone.js`\n4. Update vector indexing if needed in `local-vector-store.js`\n\n## License\n\nMIT License",
                "command": "create"
              },
              "orig_args": {
                "summary": "Rewrite the entire README with the new decoupled architecture documentation",
                "path": "./whatsapp-indexer/README.md",
                "file_text": "# WhatsApp Indexer\n\nA WhatsApp message indexer that provides semantic search capabilities through a Model Context Protocol (MCP) server. The system is designed with a decoupled architecture where the MCP server only reads from the indexed data, while a separate service handles WhatsApp message listening and indexing.\n\n## Architecture\n\nThe system consists of two main components:\n\n### 1. WhatsApp Listener Service (`whatsapp-listener.js`)\n- Connects to WhatsApp Web using `whatsapp-web.js`\n- Receives and processes incoming/outgoing messages\n- Extracts URLs and metadata from messages\n- Stores messages in SQLite database\n- Indexes messages in a local vector store for semantic search\n- Runs independently and continuously processes messages\n\n### 2. MCP Server (`mcp-server-standalone.js`)\n- Provides MCP tools for querying indexed messages\n- Only reads from the database and vector store\n- Does not connect to WhatsApp directly\n- Can run independently of the WhatsApp connection\n- Provides semantic search, URL extraction, and date-based queries\n\n## Features\n\n- **Semantic Search**: Find messages using natural language queries\n- **URL Extraction**: Automatically extract and index URLs from messages\n- **Date-based Queries**: Search messages by date ranges\n- **Sender Filtering**: Filter messages by specific senders\n- **Schedule Detection**: Find scheduling-related conversations\n- **Plan Checking**: Check for plans on specific days\n- **Persistent Storage**: SQLite database with full-text search\n- **Vector Search**: Local FAISS-based semantic search using Transformers.js\n\n## Installation\n\n1. Clone the repository\n2. Install dependencies:\n   ```bash\n   npm install\n   ```\n\n3. Copy the environment configuration:\n   ```bash\n   cp .env.example .env\n   ```\n\n4. Edit `.env` with your preferred settings (optional - defaults work fine)\n\n## Usage\n\n### Option 1: Run Both Services (Recommended)\n\n1. **Start the WhatsApp Listener Service** (in one terminal):\n   ```bash\n   ./start-listener.sh\n   ```\n   - Scan the QR code with your WhatsApp mobile app\n   - Wait for \"WhatsApp client is ready!\" message\n   - Leave this running to continuously index new messages\n\n2. **Start the MCP Server** (in another terminal):\n   ```bash\n   ./start-mcp-standalone.sh\n   ```\n   - This provides the MCP tools for querying messages\n   - Can be restarted without affecting WhatsApp connection\n\n### Option 2: MCP Server Only (Query Existing Data)\n\nIf you already have indexed messages and just want to query them:\n\n```bash\n./start-mcp-standalone.sh\n```\n\n### Option 3: Legacy Combined Mode (Not Recommended)\n\nFor backward compatibility, you can still run the old combined mode:\n\n```bash\n./start-mcp.sh\n```\n\n## MCP Tools\n\nThe MCP server provides the following tools:\n\n### `whatsapp_status`\nCheck the status of the WhatsApp indexer service\n- Shows total indexed messages\n- Shows last message timestamp\n- Indicates if the system is ready\n\n### `search_messages`\nSearch messages using natural language queries\n- **query** (required): Natural language search query\n- **limit** (optional): Maximum results to return (default: 10)\n\nExample: \"find the restaurant recommendation from John\"\n\n### `get_urls_by_sender`\nGet all URLs shared by a specific person\n- **sender_name** (required): Name of the sender\n- **limit** (optional): Maximum URLs to return (default: 20)\n\n### `get_messages_by_date`\nGet messages from a specific date or date range\n- **date_query** (required): Date in natural language (e.g., \"today\", \"last Monday\")\n- **sender_name** (optional): Filter by specific sender\n\n### `find_schedule_with_person`\nFind scheduling-related messages with a specific person\n- **person_name** (required): Name of the person\n- **time_period** (optional): Time period to search (default: \"this week\")\n\n### `check_plans_for_day`\nCheck for plans or appointments on a specific day\n- **day** (required): Day to check (e.g., \"Wednesday\", \"tomorrow\")\n\n## Configuration\n\nEdit `.env` to customize:\n\n```env\n# Database\nDATABASE_PATH=./data/messages.db\n\n# Vector Store\nVECTOR_STORE_PATH=./data/vectors\nVECTOR_MODEL=Xenova/all-MiniLM-L6-v2\nVECTOR_DIMENSION=384\n\n# Logging\nLOG_LEVEL=info\n```\n\n## Data Storage\n\n- **SQLite Database**: `./data/messages.db` - Stores message content, metadata, and URLs\n- **Vector Store**: `./data/vectors/` - FAISS index and metadata for semantic search\n- **WhatsApp Session**: `./.wwebjs_auth/` - WhatsApp Web authentication data\n\n## Architecture Benefits\n\n### Decoupled Design\n- MCP server can run without WhatsApp connection\n- WhatsApp listener can restart without affecting queries\n- Better reliability and maintainability\n\n### Scalability\n- Multiple MCP servers can read from the same data\n- WhatsApp listener runs independently\n- Easy to add more data sources\n\n### Development\n- Test MCP tools without WhatsApp setup\n- Develop features using existing data\n- Clear separation of concerns\n\n## Troubleshooting\n\n### WhatsApp Connection Issues\n- Make sure only the listener service connects to WhatsApp\n- Check QR code scanning in the listener terminal\n- Restart only the listener service if connection fails\n\n### MCP Server Issues\n- MCP server doesn't need WhatsApp connection\n- Check if database and vector store files exist\n- Restart MCP server independently\n\n### No Messages Found\n- Ensure WhatsApp listener service is running\n- Check that messages are being indexed (watch listener logs)\n- Verify database has data: check `./data/messages.db`\n\n### Performance\n- Vector search may be slow on first run (model download)\n- Subsequent searches are much faster\n- Consider adjusting `VECTOR_DIMENSION` for speed vs accuracy\n\n## Development\n\n### Project Structure\n```\nsrc/\n├── mcp-server-standalone.js    # Standalone MCP server\n├── whatsapp-listener.js        # WhatsApp message listener\n├── database.js                 # SQLite database operations\n├── local-vector-store.js       # FAISS vector store\n├── message-processor.js        # Message processing logic\n├── config.js                   # Configuration management\n└── mcp-server.js              # Legacy combined server\n```\n\n### Adding New Features\n1. Add database schema changes in `database.js`\n2. Update message processing in `message-processor.js`\n3. Add new MCP tools in `mcp-server-standalone.js`\n4. Update vector indexing if needed in `local-vector-store.js`\n\n## License\n\nMIT License",
                "command": "create"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_Kbhj0fZVQ2e7QrgI9-Wjag",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "de0b425c-7687-4642-814b-c1862f86bf7e",
          "content": "Now let me create a simple test script to verify the new architecture works:",
          "tool_uses": [
            {
              "id": "tooluse_wqBr3o9-TMeF8keRcJ7vNw",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Create a test script to verify the decoupled architecture",
                "path": "./whatsapp-indexer/test-standalone.js",
                "file_text": "#!/usr/bin/env node\n\n// Test script to verify the standalone MCP server works without WhatsApp connection\n\nimport Database from './src/database.js';\nimport LocalVectorStore from './src/local-vector-store.js';\n\nasync function testStandaloneComponents() {\n  console.log('🧪 Testing standalone components...\\n');\n\n  try {\n    // Test Database\n    console.log('📊 Testing Database...');\n    const database = new Database();\n    await database.initialize();\n    \n    const messageCount = await database.getMessageCount();\n    const lastMessageTime = await database.getLastMessageTime();\n    \n    console.log(`✅ Database initialized successfully`);\n    console.log(`   - Messages: ${messageCount}`);\n    console.log(`   - Last message: ${lastMessageTime ? new Date(lastMessageTime).toLocaleString() : 'None'}`);\n    \n    // Test Vector Store\n    console.log('\\n🔍 Testing Vector Store...');\n    const vectorStore = new LocalVectorStore();\n    await vectorStore.initialize();\n    \n    console.log(`✅ Vector store initialized successfully`);\n    \n    // Test a simple search if we have data\n    if (messageCount > 0) {\n      console.log('\\n🔎 Testing search functionality...');\n      const searchResults = await vectorStore.searchSimilar('hello', { topK: 3 });\n      console.log(`✅ Search completed: ${searchResults.length} results`);\n      \n      if (searchResults.length > 0) {\n        console.log('   Sample result:');\n        const sample = searchResults[0];\n        console.log(`   - From: ${sample.sender_name}`);\n        console.log(`   - Content: ${sample.content.substring(0, 50)}...`);\n        console.log(`   - Score: ${sample.score?.toFixed(3)}`);\n      }\n    } else {\n      console.log('⚠️  No messages found - start the WhatsApp listener to index messages');\n    }\n    \n    // Cleanup\n    await database.close();\n    \n    console.log('\\n✅ All tests passed! The standalone architecture is working correctly.');\n    console.log('\\n📝 Next steps:');\n    console.log('   1. Start the WhatsApp listener: ./start-listener.sh');\n    console.log('   2. Start the MCP server: ./start-mcp-standalone.sh');\n    \n  } catch (error) {\n    console.error('❌ Test failed:', error);\n    process.exit(1);\n  }\n}\n\n// Run the test\ntestStandaloneComponents();",
                "command": "create"
              },
              "orig_args": {
                "summary": "Create a test script to verify the decoupled architecture",
                "path": "./whatsapp-indexer/test-standalone.js",
                "file_text": "#!/usr/bin/env node\n\n// Test script to verify the standalone MCP server works without WhatsApp connection\n\nimport Database from './src/database.js';\nimport LocalVectorStore from './src/local-vector-store.js';\n\nasync function testStandaloneComponents() {\n  console.log('🧪 Testing standalone components...\\n');\n\n  try {\n    // Test Database\n    console.log('📊 Testing Database...');\n    const database = new Database();\n    await database.initialize();\n    \n    const messageCount = await database.getMessageCount();\n    const lastMessageTime = await database.getLastMessageTime();\n    \n    console.log(`✅ Database initialized successfully`);\n    console.log(`   - Messages: ${messageCount}`);\n    console.log(`   - Last message: ${lastMessageTime ? new Date(lastMessageTime).toLocaleString() : 'None'}`);\n    \n    // Test Vector Store\n    console.log('\\n🔍 Testing Vector Store...');\n    const vectorStore = new LocalVectorStore();\n    await vectorStore.initialize();\n    \n    console.log(`✅ Vector store initialized successfully`);\n    \n    // Test a simple search if we have data\n    if (messageCount > 0) {\n      console.log('\\n🔎 Testing search functionality...');\n      const searchResults = await vectorStore.searchSimilar('hello', { topK: 3 });\n      console.log(`✅ Search completed: ${searchResults.length} results`);\n      \n      if (searchResults.length > 0) {\n        console.log('   Sample result:');\n        const sample = searchResults[0];\n        console.log(`   - From: ${sample.sender_name}`);\n        console.log(`   - Content: ${sample.content.substring(0, 50)}...`);\n        console.log(`   - Score: ${sample.score?.toFixed(3)}`);\n      }\n    } else {\n      console.log('⚠️  No messages found - start the WhatsApp listener to index messages');\n    }\n    \n    // Cleanup\n    await database.close();\n    \n    console.log('\\n✅ All tests passed! The standalone architecture is working correctly.');\n    console.log('\\n📝 Next steps:');\n    console.log('   1. Start the WhatsApp listener: ./start-listener.sh');\n    console.log('   2. Start the MCP server: ./start-mcp-standalone.sh');\n    \n  } catch (error) {\n    console.error('❌ Test failed:', error);\n    process.exit(1);\n  }\n}\n\n// Run the test\ntestStandaloneComponents();",
                "command": "create"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_wqBr3o9-TMeF8keRcJ7vNw",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "7ba5d2df-b1e6-4e0c-bf27-a80e24493396",
          "content": "",
          "tool_uses": [
            {
              "id": "tooluse_pj68_hVLR6mVRapnf0vJVQ",
              "name": "execute_bash",
              "orig_name": "execute_bash",
              "args": {
                "summary": "Make the test script executable",
                "command": "chmod +x ./whatsapp-indexer/test-standalone.js"
              },
              "orig_args": {
                "summary": "Make the test script executable",
                "command": "chmod +x ./whatsapp-indexer/test-standalone.js"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_pj68_hVLR6mVRapnf0vJVQ",
                "content": [
                  {
                    "Json": {
                      "exit_status": "0",
                      "stdout": "",
                      "stderr": ""
                    }
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "81215720-9bf0-4bb3-bdc5-e34509489dd7",
          "content": "Now let me update the package.json to include the new scripts:",
          "tool_uses": [
            {
              "id": "tooluse_K3OVaJl0RTquXB1No10kQQ",
              "name": "fs_read",
              "orig_name": "fs_read",
              "args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/package.json"
              },
              "orig_args": {
                "mode": "Line",
                "path": "./whatsapp-indexer/package.json"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_K3OVaJl0RTquXB1No10kQQ",
                "content": [
                  {
                    "Text": "{\n  \"name\": \"whatsapp-indexer\",\n  \"version\": \"1.0.0\",\n  \"description\": \"WhatsApp message indexer with semantic search and MCP server\",\n  \"main\": \"src/index.js\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"start\": \"node src/index.js\",\n    \"dev\": \"node --watch src/index.js\",\n    \"mcp-server\": \"node src/mcp-server.js\",\n    \"setup\": \"node scripts/setup-local-store.js\"\n  },\n  \"dependencies\": {\n    \"whatsapp-web.js\": \"^1.23.0\",\n    \"qrcode-terminal\": \"^0.12.0\",\n    \"@modelcontextprotocol/sdk\": \"^0.4.0\",\n    \"sqlite3\": \"^5.1.6\",\n    \"node-cron\": \"^3.0.3\",\n    \"url-regex\": \"^5.0.0\",\n    \"chrono-node\": \"^2.7.0\",\n    \"dotenv\": \"^16.4.5\",\n    \"faiss-node\": \"^0.5.1\",\n    \"@xenova/transformers\": \"^2.17.1\",\n    \"fs-extra\": \"^11.2.0\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.3\"\n  },\n  \"keywords\": [\n    \"whatsapp\",\n    \"semantic-search\",\n    \"mcp\",\n    \"vector-database\",\n    \"ai\"\n  ],\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\"\n}"
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "1de3e968-6cdb-4676-96c5-8a2080359864",
          "content": "",
          "tool_uses": [
            {
              "id": "tooluse_XHbm7IHHR4W2ewlAijaxMw",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Update package.json with new scripts for the decoupled architecture",
                "path": "./whatsapp-indexer/package.json",
                "new_str": "  \"scripts\": {\n    \"start\": \"node src/index.js\",\n    \"dev\": \"node --watch src/index.js\",\n    \"mcp-server\": \"node src/mcp-server.js\",\n    \"mcp-standalone\": \"node src/mcp-server-standalone.js\",\n    \"listener\": \"node src/whatsapp-listener.js\",\n    \"test-standalone\": \"node test-standalone.js\",\n    \"setup\": \"node scripts/setup-local-store.js\"\n  },",
                "old_str": "  \"scripts\": {\n    \"start\": \"node src/index.js\",\n    \"dev\": \"node --watch src/index.js\",\n    \"mcp-server\": \"node src/mcp-server.js\",\n    \"setup\": \"node scripts/setup-local-store.js\"\n  },",
                "command": "str_replace"
              },
              "orig_args": {
                "summary": "Update package.json with new scripts for the decoupled architecture",
                "path": "./whatsapp-indexer/package.json",
                "new_str": "  \"scripts\": {\n    \"start\": \"node src/index.js\",\n    \"dev\": \"node --watch src/index.js\",\n    \"mcp-server\": \"node src/mcp-server.js\",\n    \"mcp-standalone\": \"node src/mcp-server-standalone.js\",\n    \"listener\": \"node src/whatsapp-listener.js\",\n    \"test-standalone\": \"node test-standalone.js\",\n    \"setup\": \"node scripts/setup-local-store.js\"\n  },",
                "old_str": "  \"scripts\": {\n    \"start\": \"node src/index.js\",\n    \"dev\": \"node --watch src/index.js\",\n    \"mcp-server\": \"node src/mcp-server.js\",\n    \"setup\": \"node scripts/setup-local-store.js\"\n  },",
                "command": "str_replace"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_XHbm7IHHR4W2ewlAijaxMw",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "ToolUse": {
          "message_id": "7d8a0d47-544f-4ef2-8f6e-53fbe8d4a84b",
          "content": "Finally, let me create a summary document explaining the changes:",
          "tool_uses": [
            {
              "id": "tooluse_DQlge5jBRgCDfKl3GwGmug",
              "name": "fs_write",
              "orig_name": "fs_write",
              "args": {
                "summary": "Create a migration guide explaining the changes from coupled to decoupled architecture",
                "path": "./whatsapp-indexer/MIGRATION.md",
                "file_text": "# Migration Guide: Decoupled Architecture\n\nThis document explains the changes made to decouple the WhatsApp MCP server from the WhatsApp client, creating a more robust and maintainable architecture.\n\n## What Changed\n\n### Before (Coupled Architecture)\n- Single `mcp-server.js` that both connected to WhatsApp AND served MCP requests\n- MCP server would fail if WhatsApp connection failed\n- Couldn't query messages without an active WhatsApp connection\n- Tight coupling between WhatsApp client and MCP functionality\n\n### After (Decoupled Architecture)\n- **WhatsApp Listener Service** (`whatsapp-listener.js`): Handles WhatsApp connection and message indexing\n- **Standalone MCP Server** (`mcp-server-standalone.js`): Only reads from database/vector store\n- Services can run independently\n- MCP server works even if WhatsApp is disconnected\n- Better reliability and maintainability\n\n## New Components\n\n### 1. WhatsApp Listener Service (`src/whatsapp-listener.js`)\n- Connects to WhatsApp Web\n- Processes incoming/outgoing messages\n- Updates database and vector store\n- Runs continuously in the background\n- Can be restarted without affecting MCP queries\n\n### 2. Standalone MCP Server (`src/mcp-server-standalone.js`)\n- Provides MCP tools for querying messages\n- Only reads from database and vector store\n- No WhatsApp client dependency\n- Can run multiple instances\n- Fast startup (no WhatsApp authentication needed)\n\n## New Startup Scripts\n\n### `./start-listener.sh`\nStarts the WhatsApp listener service:\n- Connects to WhatsApp\n- Indexes new messages\n- Runs continuously\n\n### `./start-mcp-standalone.sh`\nStarts the standalone MCP server:\n- Provides MCP tools\n- Reads from indexed data\n- No WhatsApp connection needed\n\n### `./test-standalone.js`\nTests the decoupled components:\n- Verifies database connectivity\n- Tests vector store functionality\n- Checks search capabilities\n\n## Migration Steps\n\n### For Existing Users\n\n1. **Stop the old combined server** if running:\n   ```bash\n   # Stop any running MCP server\n   pkill -f mcp-server.js\n   ```\n\n2. **Test the new architecture**:\n   ```bash\n   node test-standalone.js\n   ```\n\n3. **Start the new services**:\n   ```bash\n   # Terminal 1: Start WhatsApp listener\n   ./start-listener.sh\n   \n   # Terminal 2: Start MCP server\n   ./start-mcp-standalone.sh\n   ```\n\n### For New Users\n\nSimply follow the updated README instructions:\n1. Run `./start-listener.sh` and scan QR code\n2. Run `./start-mcp-standalone.sh` in another terminal\n\n## Benefits of the New Architecture\n\n### 1. Reliability\n- MCP server doesn't crash if WhatsApp disconnects\n- Can query existing messages even without WhatsApp\n- Independent service restarts\n\n### 2. Performance\n- MCP server starts instantly (no WhatsApp auth wait)\n- Dedicated processes for different concerns\n- Better resource utilization\n\n### 3. Development\n- Test MCP tools without WhatsApp setup\n- Develop features using existing data\n- Clear separation of concerns\n\n### 4. Scalability\n- Run multiple MCP servers reading same data\n- WhatsApp listener runs independently\n- Easy to add more data sources\n\n## Backward Compatibility\n\nThe old combined mode is still available:\n```bash\n./start-mcp.sh  # Uses the original mcp-server.js\n```\n\nHowever, the new decoupled approach is recommended for all new deployments.\n\n## File Changes Summary\n\n### New Files\n- `src/mcp-server-standalone.js` - Standalone MCP server\n- `src/whatsapp-listener.js` - WhatsApp message listener\n- `start-mcp-standalone.sh` - Startup script for MCP server\n- `start-listener.sh` - Startup script for WhatsApp listener\n- `test-standalone.js` - Test script for new architecture\n- `MIGRATION.md` - This migration guide\n\n### Modified Files\n- `README.md` - Updated with new architecture documentation\n- `package.json` - Added new npm scripts\n- `src/database.js` - Added `getMessageCount()` and `getLastMessageTime()` methods\n\n### Unchanged Files\n- `src/database.js` - Core database functionality unchanged\n- `src/local-vector-store.js` - Vector store functionality unchanged\n- `src/message-processor.js` - Message processing unchanged\n- `src/config.js` - Configuration unchanged\n- All existing data files and authentication remain compatible\n\n## Troubleshooting\n\n### \"WhatsApp indexer is not initialized\"\n- Make sure you're running `start-mcp-standalone.sh`, not the old script\n- Check that database and vector store files exist in `./data/`\n\n### \"No messages found\"\n- Ensure the WhatsApp listener service is running: `./start-listener.sh`\n- Check that messages are being indexed (watch listener logs)\n- Verify WhatsApp connection is active\n\n### MCP tools not working\n- Restart the MCP server: `./start-mcp-standalone.sh`\n- Check that the database file exists: `ls -la ./data/messages.db`\n- Run the test script: `node test-standalone.js`\n\n## Support\n\nIf you encounter issues with the migration:\n1. Run `node test-standalone.js` to verify components\n2. Check the logs from both services\n3. Ensure all dependencies are installed: `npm install`\n4. Try the legacy mode temporarily: `./start-mcp.sh`",
                "command": "create"
              },
              "orig_args": {
                "summary": "Create a migration guide explaining the changes from coupled to decoupled architecture",
                "path": "./whatsapp-indexer/MIGRATION.md",
                "file_text": "# Migration Guide: Decoupled Architecture\n\nThis document explains the changes made to decouple the WhatsApp MCP server from the WhatsApp client, creating a more robust and maintainable architecture.\n\n## What Changed\n\n### Before (Coupled Architecture)\n- Single `mcp-server.js` that both connected to WhatsApp AND served MCP requests\n- MCP server would fail if WhatsApp connection failed\n- Couldn't query messages without an active WhatsApp connection\n- Tight coupling between WhatsApp client and MCP functionality\n\n### After (Decoupled Architecture)\n- **WhatsApp Listener Service** (`whatsapp-listener.js`): Handles WhatsApp connection and message indexing\n- **Standalone MCP Server** (`mcp-server-standalone.js`): Only reads from database/vector store\n- Services can run independently\n- MCP server works even if WhatsApp is disconnected\n- Better reliability and maintainability\n\n## New Components\n\n### 1. WhatsApp Listener Service (`src/whatsapp-listener.js`)\n- Connects to WhatsApp Web\n- Processes incoming/outgoing messages\n- Updates database and vector store\n- Runs continuously in the background\n- Can be restarted without affecting MCP queries\n\n### 2. Standalone MCP Server (`src/mcp-server-standalone.js`)\n- Provides MCP tools for querying messages\n- Only reads from database and vector store\n- No WhatsApp client dependency\n- Can run multiple instances\n- Fast startup (no WhatsApp authentication needed)\n\n## New Startup Scripts\n\n### `./start-listener.sh`\nStarts the WhatsApp listener service:\n- Connects to WhatsApp\n- Indexes new messages\n- Runs continuously\n\n### `./start-mcp-standalone.sh`\nStarts the standalone MCP server:\n- Provides MCP tools\n- Reads from indexed data\n- No WhatsApp connection needed\n\n### `./test-standalone.js`\nTests the decoupled components:\n- Verifies database connectivity\n- Tests vector store functionality\n- Checks search capabilities\n\n## Migration Steps\n\n### For Existing Users\n\n1. **Stop the old combined server** if running:\n   ```bash\n   # Stop any running MCP server\n   pkill -f mcp-server.js\n   ```\n\n2. **Test the new architecture**:\n   ```bash\n   node test-standalone.js\n   ```\n\n3. **Start the new services**:\n   ```bash\n   # Terminal 1: Start WhatsApp listener\n   ./start-listener.sh\n   \n   # Terminal 2: Start MCP server\n   ./start-mcp-standalone.sh\n   ```\n\n### For New Users\n\nSimply follow the updated README instructions:\n1. Run `./start-listener.sh` and scan QR code\n2. Run `./start-mcp-standalone.sh` in another terminal\n\n## Benefits of the New Architecture\n\n### 1. Reliability\n- MCP server doesn't crash if WhatsApp disconnects\n- Can query existing messages even without WhatsApp\n- Independent service restarts\n\n### 2. Performance\n- MCP server starts instantly (no WhatsApp auth wait)\n- Dedicated processes for different concerns\n- Better resource utilization\n\n### 3. Development\n- Test MCP tools without WhatsApp setup\n- Develop features using existing data\n- Clear separation of concerns\n\n### 4. Scalability\n- Run multiple MCP servers reading same data\n- WhatsApp listener runs independently\n- Easy to add more data sources\n\n## Backward Compatibility\n\nThe old combined mode is still available:\n```bash\n./start-mcp.sh  # Uses the original mcp-server.js\n```\n\nHowever, the new decoupled approach is recommended for all new deployments.\n\n## File Changes Summary\n\n### New Files\n- `src/mcp-server-standalone.js` - Standalone MCP server\n- `src/whatsapp-listener.js` - WhatsApp message listener\n- `start-mcp-standalone.sh` - Startup script for MCP server\n- `start-listener.sh` - Startup script for WhatsApp listener\n- `test-standalone.js` - Test script for new architecture\n- `MIGRATION.md` - This migration guide\n\n### Modified Files\n- `README.md` - Updated with new architecture documentation\n- `package.json` - Added new npm scripts\n- `src/database.js` - Added `getMessageCount()` and `getLastMessageTime()` methods\n\n### Unchanged Files\n- `src/database.js` - Core database functionality unchanged\n- `src/local-vector-store.js` - Vector store functionality unchanged\n- `src/message-processor.js` - Message processing unchanged\n- `src/config.js` - Configuration unchanged\n- All existing data files and authentication remain compatible\n\n## Troubleshooting\n\n### \"WhatsApp indexer is not initialized\"\n- Make sure you're running `start-mcp-standalone.sh`, not the old script\n- Check that database and vector store files exist in `./data/`\n\n### \"No messages found\"\n- Ensure the WhatsApp listener service is running: `./start-listener.sh`\n- Check that messages are being indexed (watch listener logs)\n- Verify WhatsApp connection is active\n\n### MCP tools not working\n- Restart the MCP server: `./start-mcp-standalone.sh`\n- Check that the database file exists: `ls -la ./data/messages.db`\n- Run the test script: `node test-standalone.js`\n\n## Support\n\nIf you encounter issues with the migration:\n1. Run `node test-standalone.js` to verify components\n2. Check the logs from both services\n3. Ensure all dependencies are installed: `npm install`\n4. Try the legacy mode temporarily: `./start-mcp.sh`",
                "command": "create"
              }
            }
          ]
        }
      }
    ],
    [
      {
        "additional_context": "",
        "env_context": {
          "env_state": {
            "operating_system": "macos",
            "current_working_directory": "/Users/orrb/personal/workspace/personal-ai",
            "environment_variables": []
          }
        },
        "content": {
          "ToolUseResults": {
            "tool_use_results": [
              {
                "tool_use_id": "tooluse_DQlge5jBRgCDfKl3GwGmug",
                "content": [
                  {
                    "Text": ""
                  }
                ],
                "status": "Success"
              }
            ]
          }
        },
        "images": null
      },
      {
        "Response": {
          "message_id": "1d8d5667-a90a-41bb-8255-81edcaf98a37",
          "content": "Perfect! I've successfully refactored the WhatsApp indexer to have a decoupled architecture. Here's a summary of what I've done:\n\n## Key Changes Made\n\n### 1. **Decoupled Architecture**\n- **WhatsApp Listener Service** (`whatsapp-listener.js`): Handles WhatsApp connection and message indexing\n- **Standalone MCP Server** (`mcp-server-standalone.js`): Only reads from database/vector store, no WhatsApp dependency\n\n### 2. **New Files Created**\n- `src/mcp-server-standalone.js` - MCP server that only reads from indexed data\n- `src/whatsapp-listener.js` - Dedicated WhatsApp message listener service\n- `start-mcp-standalone.sh` - Startup script for standalone MCP server\n- `start-listener.sh` - Startup script for WhatsApp listener\n- `test-standalone.js` - Test script to verify the architecture\n- `MIGRATION.md` - Detailed migration guide\n\n### 3. **Enhanced Database**\n- Added `getMessageCount()` and `getLastMessageTime()` methods\n- Better status reporting for the MCP server\n\n### 4. **Updated Documentation**\n- Completely rewritten README with new architecture explanation\n- Added migration guide for existing users\n- Updated package.json with new scripts\n\n## Benefits of the New Architecture\n\n### ✅ **Reliability**\n- MCP server works even if WhatsApp is disconnected\n- Services can be restarted independently\n- No more \"WhatsApp client is not ready\" errors when querying\n\n### ✅ **Performance** \n- MCP server starts instantly (no WhatsApp authentication wait)\n- Dedicated processes for different concerns\n- Better resource utilization\n\n### ✅ **Development**\n- Test MCP tools without WhatsApp setup\n- Develop features using existing data\n- Clear separation of concerns\n\n### ✅ **Scalability**\n- Multiple MCP servers can read from the same data\n- WhatsApp listener runs independently\n- Easy to add more data sources\n\n## How to Use the New Architecture\n\n### Option 1: Run Both Services (Recommended)\n```bash\n# Terminal 1: Start WhatsApp listener\n./start-listener.sh\n\n# Terminal 2: Start MCP server  \n./start-mcp-standalone.sh\n```\n\n### Option 2: MCP Server Only (Query Existing Data)\n```bash\n./start-mcp-standalone.sh\n```\n\n### Test the Architecture\n```bash\nnode test-standalone.js\n```\n\nThe MCP server now only depends on the vector index and database, exactly as you requested. The WhatsApp message listening and indexing runs as a completely separate service, making the system much more robust and maintainable."
        }
      }
    ]
  ],
  "valid_history_range": [
    0,
    37
  ],
  "transcript": [
    "> what messages i recently got on whatsapp ?",
    "I'll check your recent WhatsApp messages for you.\n[Tool uses: whatsapp_indexer___get_messages_by_date]",
    "> t",
    "It looks like your WhatsApp client isn't authenticated yet. Let me check the status:\n[Tool uses: whatsapp_indexer___whatsapp_status]",
    "> t",
    "Your WhatsApp client is currently not ready - it's either still authenticating or disconnected. You'll need to authenticate your WhatsApp session first before I can retrieve your messages.\n\nTo set up WhatsApp access, you would typically need to:\n1. Ensure the WhatsApp indexer service is running\n2. Complete the authentication process (usually involves scanning a QR code with your phone)\n3. Wait for the connection to be established\n\nOnce the WhatsApp client is authenticated and ready, I'll be able to help you check your recent messages. Would you like me to try checking the status again in a moment, or do you need help with setting up the WhatsApp connection?\n[Tool uses: none]",
    "> the mcp server should not depened on the whats up client, it shouild pnly relay on the vector index and the service that listens to the whatsapp messages and updates the index will run seperatly , change the code accordingly. ",
    "You're absolutely right! The MCP server should be decoupled from the WhatsApp client and only interact with the vector index. The WhatsApp message listening and indexing should be a separate service. Let me examine the current code structure and refactor it accordingly.\n[Tool uses: fs_read]",
    "\n[Tool uses: fs_read]",
    "\n[Tool uses: fs_read]",
    "Let me examine the current MCP server implementation to understand how it's coupled with the WhatsApp client:\n[Tool uses: fs_read]",
    "Now let me check the WhatsApp client to understand the current coupling:\n[Tool uses: fs_read]",
    "Let me also check the database and vector store to understand the current architecture:\n[Tool uses: fs_read]",
    "Now let me check the local vector store:\n[Tool uses: fs_read]",
    "Perfect! Now I understand the current architecture. Let me refactor this to properly separate concerns. I'll create:\n\n1. A standalone MCP server that only interacts with the database/vector store\n2. A separate WhatsApp listener service that handles WhatsApp messages and updates the index\n3. A shared data access layer\n\nLet me start by creating the refactored MCP server:\n[Tool uses: fs_write]",
    "> t",
    "Now let me add the missing database methods that the MCP server needs:\n[Tool uses: fs_read]",
    "I need to add the missing methods to the database class:\n[Tool uses: fs_write]",
    "Now let me create a separate WhatsApp listener service that handles the WhatsApp client and updates the index:\n[Tool uses: fs_write]",
    "Now let me update the vector store to include the missing `addMessage` method:\n[Tool uses: fs_read]",
    "Let me check if there's an `addMessage` method already:\n[Tool uses: fs_read]",
    "I need to add the `addMessage` method to the vector store:\n[Tool uses: fs_read]",
    "I can see there's already an indexing method. Let me find the correct method name:\n[Tool uses: fs_read]",
    "Let me search for the method that adds messages:\n[Tool uses: fs_read]",
    "Let me look at the full vector store file to understand the structure:\n[Tool uses: fs_read]",
    "Perfect! I can see the method is called `indexMessage`. Let me update the WhatsApp listener to use the correct method name:\n[Tool uses: fs_write]",
    "Now let me check if the vector store has a `search` method or if it's called something else:\n[Tool uses: fs_read]",
    "\n[Tool uses: fs_read]",
    "I need to update the MCP server to use the correct method name:\n[Tool uses: fs_write]",
    "\n[Tool uses: fs_write]",
    "\n[Tool uses: fs_write]",
    "Now let me create updated startup scripts for the new architecture:\n[Tool uses: fs_write]",
    "\n[Tool uses: fs_write]",
    "\n[Tool uses: execute_bash]",
    "> t",
    "Now let me update the README to document the new architecture:\n[Tool uses: fs_write]",
    "Let me rewrite the entire README file:\n[Tool uses: fs_write]",
    "Now let me create a simple test script to verify the new architecture works:\n[Tool uses: fs_write]",
    "\n[Tool uses: execute_bash]",
    "Now let me update the package.json to include the new scripts:\n[Tool uses: fs_read]",
    "\n[Tool uses: fs_write]",
    "Finally, let me create a summary document explaining the changes:\n[Tool uses: fs_write]",
    "Perfect! I've successfully refactored the WhatsApp indexer to have a decoupled architecture. Here's a summary of what I've done:\n\n## Key Changes Made\n\n### 1. **Decoupled Architecture**\n- **WhatsApp Listener Service** (`whatsapp-listener.js`): Handles WhatsApp connection and message indexing\n- **Standalone MCP Server** (`mcp-server-standalone.js`): Only reads from database/vector store, no WhatsApp dependency\n\n### 2. **New Files Created**\n- `src/mcp-server-standalone.js` - MCP server that only reads from indexed data\n- `src/whatsapp-listener.js` - Dedicated WhatsApp message listener service\n- `start-mcp-standalone.sh` - Startup script for standalone MCP server\n- `start-listener.sh` - Startup script for WhatsApp listener\n- `test-standalone.js` - Test script to verify the architecture\n- `MIGRATION.md` - Detailed migration guide\n\n### 3. **Enhanced Database**\n- Added `getMessageCount()` and `getLastMessageTime()` methods\n- Better status reporting for the MCP server\n\n### 4. **Updated Documentation**\n- Completely rewritten README with new architecture explanation\n- Added migration guide for existing users\n- Updated package.json with new scripts\n\n## Benefits of the New Architecture\n\n### ✅ **Reliability**\n- MCP server works even if WhatsApp is disconnected\n- Services can be restarted independently\n- No more \"WhatsApp client is not ready\" errors when querying\n\n### ✅ **Performance** \n- MCP server starts instantly (no WhatsApp authentication wait)\n- Dedicated processes for different concerns\n- Better resource utilization\n\n### ✅ **Development**\n- Test MCP tools without WhatsApp setup\n- Develop features using existing data\n- Clear separation of concerns\n\n### ✅ **Scalability**\n- Multiple MCP servers can read from the same data\n- WhatsApp listener runs independently\n- Easy to add more data sources\n\n## How to Use the New Architecture\n\n### Option 1: Run Both Services (Recommended)\n```bash\n# Terminal 1: Start WhatsApp listener\n./start-listener.sh\n\n# Terminal 2: Start MCP server  \n./start-mcp-standalone.sh\n```\n\n### Option 2: MCP Server Only (Query Existing Data)\n```bash\n./start-mcp-standalone.sh\n```\n\n### Test the Architecture\n```bash\nnode test-standalone.js\n```\n\nThe MCP server now only depends on the vector index and database, exactly as you requested. The WhatsApp message listening and indexing runs as a completely separate service, making the system much more robust and maintainable.\n[Tool uses: none]",
    "> /",
    "> /save personal-ai"
  ],
  "tools": {
    "whatsapp_indexer": [
      {
        "ToolSpecification": {
          "name": "whatsapp_indexer___find_schedule_with_person",
          "description": "Find scheduling-related messages with a specific person",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "person_name"
              ],
              "properties": {
                "person_name": {
                  "type": "string",
                  "description": "Name of the person to find scheduling messages with"
                },
                "time_period": {
                  "default": "this week",
                  "type": "string",
                  "description": "Time period to search (e.g., \"this week\", \"next week\", \"today\")"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "whatsapp_indexer___get_messages_by_date",
          "description": "Get messages from a specific date or date range",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "date_query": {
                  "description": "Date or date range in natural language (e.g., \"today\", \"this week\", \"last Monday\", \"January 15\")",
                  "type": "string"
                },
                "sender_name": {
                  "description": "Optional: filter by specific sender",
                  "type": "string"
                }
              },
              "required": [
                "date_query"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "whatsapp_indexer___whatsapp_status",
          "description": "Check the status of the WhatsApp client connection",
          "input_schema": {
            "json": {
              "properties": {},
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "whatsapp_indexer___search_messages",
          "description": "Search WhatsApp messages using natural language queries. Supports semantic search and filters by sender, date, and content type.",
          "input_schema": {
            "json": {
              "properties": {
                "limit": {
                  "description": "Maximum number of results to return (default: 10)",
                  "default": 10,
                  "type": "number"
                },
                "query": {
                  "description": "Natural language search query (e.g., \"get me the url Roni sent me for the thai restaurant\")",
                  "type": "string"
                }
              },
              "required": [
                "query"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "whatsapp_indexer___get_urls_by_sender",
          "description": "Get all URLs shared by a specific person",
          "input_schema": {
            "json": {
              "required": [
                "sender_name"
              ],
              "properties": {
                "limit": {
                  "type": "number",
                  "default": 20,
                  "description": "Maximum number of URLs to return (default: 20)"
                },
                "sender_name": {
                  "type": "string",
                  "description": "Name of the person who sent the URLs"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "whatsapp_indexer___check_plans_for_day",
          "description": "Check if there are any plans or appointments for a specific day",
          "input_schema": {
            "json": {
              "required": [
                "day"
              ],
              "type": "object",
              "properties": {
                "day": {
                  "type": "string",
                  "description": "Day to check for plans (e.g., \"Wednesday\", \"tomorrow\", \"January 20\")"
                }
              }
            }
          }
        }
      }
    ],
    "amzn_mcp": [
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pippin_get_project",
          "description": "Retrieves a Pippin design project by its ID",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "required": [
                "projectId"
              ],
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "projectId": {
                  "type": "string",
                  "description": "Project ID"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___andes_table",
          "description": "Access and manage Andes tables and their versions.",
          "input_schema": {
            "json": {
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "limit": {
                  "type": "number",
                  "description": "Maximum number of results to return"
                },
                "showDeleted": {
                  "type": "boolean",
                  "description": "Whether to include deleted tables in results"
                },
                "operation": {
                  "description": "The table operation to perform",
                  "type": "string",
                  "enum": [
                    "list_tables",
                    "get_table_details",
                    "list_table_versions",
                    "get_table_version_details",
                    "get_table_version_schema"
                  ]
                },
                "marker": {
                  "description": "Token for pagination",
                  "type": "string"
                },
                "providerId": {
                  "type": "string",
                  "description": "ID of the provider"
                },
                "tableName": {
                  "type": "string",
                  "description": "Name of the table (required for table-specific operations)"
                },
                "versionNumber": {
                  "type": "string",
                  "description": "Version number (required for version-specific operations)"
                }
              },
              "required": [
                "operation",
                "providerId"
              ],
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___get_katal_component",
          "description": "Get detailed information about a specific Katal component\n\nThis tool retrieves comprehensive documentation and usage information for a given Katal component,\nincluding properties, methods, examples, guidelines, and accessibility information.\n\nExamples:\n1. Get Button component info:\n```json\n{\n  \"name\": \"Button\"\n}\n```",
          "input_schema": {
            "json": {
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "name"
              ],
              "additionalProperties": false,
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Name of the Katal component to get information about"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___get_folder_quip",
          "description": "Get detailed information about a Quip folder\n\nThis tool retrieves detailed information about a specific folder,\nincluding its title, color, parent folder, and child folders.\n\nExample:\n```json\n{\n  \"folderId\": \"ABCDEF123456\"\n}\n```",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "folderId": {
                  "description": "The ID of the folder to retrieve information about",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "folderId"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sage_get_tag_details",
          "description": "Get detailed information about a specific tag on Sage (Amazon's internal Q&A platform).\n\nThis tool retrieves comprehensive information about a tag, including its ID, description, and ownership.\nUse this information when creating questions to ensure proper tag usage.\n\nAuthentication:\n- Requires valid Midway authentication (run `mwinit` if you encounter authentication errors)\n\nCommon use cases:\n- Verifying tag ownership before using it\n- Getting detailed descriptions of tags\n- Finding contact information for tag owners\n\nExample usage:\n{ \"tagName\": \"brazil\" }",
          "input_schema": {
            "json": {
              "required": [
                "tagName"
              ],
              "properties": {
                "tagName": {
                  "description": "Name of the tag to retrieve details for",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___remove_member_from_rotation",
          "description": "Remove a member from an OnCall rotation.\n\nFetches the full rotation object, removes the member, and updates the rotation.\n\nExample:\n```json\n{\n  \"teamName\": \"ft-itc\",\n  \"rotationName\": \"ft-itc-primary\",\n  \"memberToRemove\": \"inactiveUserAlias\"\n}\n```",
          "input_schema": {
            "json": {
              "required": [
                "teamName",
                "rotationName",
                "memberToRemove"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "memberToRemove": {
                  "description": "The username of the member to remove.",
                  "type": "string"
                },
                "teamName": {
                  "description": "The name of the OnCall team.",
                  "type": "string"
                },
                "rotationName": {
                  "type": "string",
                  "description": "The name of the rotation to modify."
                }
              },
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pippin_get_artifact",
          "description": "Retrieves a specific Pippin artifact by its ID",
          "input_schema": {
            "json": {
              "required": [
                "projectId",
                "designId"
              ],
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "designId": {
                  "type": "string",
                  "description": "Artifact ID"
                },
                "projectId": {
                  "type": "string",
                  "description": "Project ID"
                }
              },
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___eureka_web_search",
          "description": "Web Search using Amazon's internal web-scale search engine - Eureka\n\nGiven a query, this tool will search across the web and return relevant search results.\nThe tool returns top documents with content, url, title, and document_published_at_timestamp.\n\nExample:\n   { \"query\": \"recent supreme court ruling\" }",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "query"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "query": {
                  "description": "Search query",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___jira_add_comment",
          "description": "Add a comment to a JIRA issue",
          "input_schema": {
            "json": {
              "required": [
                "issueIdOrKey",
                "body"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "issueIdOrKey": {
                  "type": "string",
                  "minLength": 1,
                  "description": "The ID or key of the issue"
                },
                "body": {
                  "minLength": 1,
                  "type": "string",
                  "description": "The body of the comment"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___taskei_create_task",
          "description": "Create a new Taskei task with specified details. This tool allows you to create tasks with various attributes such as name, description, assignee, due dates, and more. Use this tool when you need to create new tasks for project management, tracking work items, or assigning work to team members.",
          "input_schema": {
            "json": {
              "properties": {
                "room": {
                  "description": "The room ID or name where the task should be created",
                  "type": "string"
                },
                "estimatedCompletionDate": {
                  "type": "string",
                  "description": "Estimated completion date (ISO format)"
                },
                "folder": {
                  "type": "string",
                  "description": "Folder ID or name to place the task in"
                },
                "name": {
                  "type": "string",
                  "description": "The name/title of the task (required)"
                },
                "description": {
                  "description": "Detailed description of the task",
                  "type": "string"
                },
                "estimate": {
                  "type": "number",
                  "description": "Estimated effort in story points"
                },
                "kanbanBoards": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "List of kanban board IDs to add the task to"
                },
                "assignee": {
                  "type": "string",
                  "description": "Username of the person to assign the task to"
                },
                "estimatedStartDate": {
                  "type": "string",
                  "description": "Estimated start date (ISO format)"
                },
                "classicPriority": {
                  "description": "Priority of the task (numeric value)",
                  "type": "number"
                },
                "sprints": {
                  "items": {
                    "type": "string"
                  },
                  "description": "List of sprint IDs to add the task to",
                  "type": "array"
                },
                "onBehalfOf": {
                  "type": "string",
                  "description": "Username to create the task on behalf of"
                },
                "needByDate": {
                  "type": "string",
                  "description": "Due date for the task (ISO format)"
                },
                "type": {
                  "description": "Type of task (e.g., 'Bug', 'Feature', 'Task')",
                  "type": "string"
                },
                "planningEstimate": {
                  "type": "number",
                  "description": "Planning estimate in story points"
                },
                "labels": {
                  "description": "List of labels to apply to the task",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "parentTask": {
                  "type": "string",
                  "description": "ID of the parent task"
                },
                "classicRank": {
                  "description": "Classic rank value for the task",
                  "type": "number"
                },
                "workflowAction": {
                  "type": "string",
                  "description": "Workflow action to apply to the task"
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "required": [
                "name"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___genai_poweruser_get_knowledge_structure",
          "description": "Map the hierarchical organization of your knowledge repository by generating a complete directory structure. This tool provides a navigable overview of how folders and documents are organized, with configurable depth settings to control detail level. Essential for understanding knowledge base architecture and relationships between document collections.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "depth": {
                  "type": "number",
                  "description": "How many levels deep to traverse"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___prompt_farm_prompt_content",
          "description": "A tool designed to fetch prompt content directly by specifying the repository name. This tool leverages repository identifiers to locate, extract, and deliver prompt templates or prompt from PromptFarm prompt repositories. It simplifies accessing prompt definitions without manual browsing, enabling users to quickly integrate or customize prompts by referencing the exact repository source.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "repositoryName": {
                  "type": "string",
                  "description": "The name of the PromptFarm repository to retrieve the prompt from"
                }
              },
              "required": [
                "repositoryName"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___read_kingpin_goal",
          "description": "Read a Kingpin goal by ID, retrieving comprehensive details including metadata, description, status comments, and path to green information. Now supports goal history tracking with the includeHistory parameter, showing how status comments and path to green have changed over time. Path to Green represents specific actions needed to get at-risk goals back on track. Use maxVersions parameter to control the amount of history data returned. Kingpin is Amazon's internal source of truth for planning and commitments.",
          "input_schema": {
            "json": {
              "required": [
                "goalId"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "includeHistory": {
                  "description": "Whether to include the goal's history in the response, showing changes to statusComments and pathToGreen fields over time (default: false)",
                  "type": "boolean",
                  "default": false
                },
                "maxVersions": {
                  "default": 10,
                  "description": "Maximum number of versions to include in the history, used to limit returned information size for goals with extensive history (default: 10)",
                  "type": "number"
                },
                "goalId": {
                  "description": "The ID of the Kingpin goal to read (numeric ID only, not the full URL)",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_run_job",
          "description": "Run a job with specified profile ID, job ID and dataset date.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "jobId": {
                  "type": "string",
                  "description": "UUID of the job"
                },
                "jobRunParameters": {
                  "type": "object",
                  "additionalProperties": {},
                  "description": "Optional additional job run parameters to customize job execution. Can include fields like 'serviceTier', 'marketplace', 'region', or a nested 'variables' object with key-value pairs. Example: {serviceTier: 'premium', variables: {clusterSize: 'large'}}. The datasetDate parameter will always be included automatically."
                },
                "datasetDate": {
                  "type": "string",
                  "description": "Dataset date in format YYYYMMDDTHH:MM:SS+ZZZZ"
                },
                "profileId": {
                  "type": "string",
                  "description": "UUID of the job profile"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "profileId",
                "jobId",
                "datasetDate"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___policy_engine_get_user_dashboard",
          "description": "Access Amazon Policy Engine dashboard information for a specific user alias. This tool allows you to view all risks and violations for a user in Policy Engine.",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "username": {
                  "type": "string",
                  "description": "Username to view dashboard for (e.g., 'jingzhoh')"
                }
              },
              "additionalProperties": false,
              "required": [
                "username"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sage_create_question",
          "description": "Create a new question on Sage (Amazon's internal Q&A platform).\n\nThis tool allows you to post new questions to Sage through the MCP interface.\nQuestions require at least one tag or packageTag to categorize them properly.\nThe question content supports Markdown formatting for rich text, code blocks, and links.\n\nAuthentication:\n- Requires valid Midway authentication (run `mwinit` if you encounter authentication errors)\n\nCommon use cases:\n- Asking technical questions about Amazon internal tools and services\n- Seeking help with troubleshooting issues\n- Requesting best practices or guidance\n\nExample usage:\n{ \"title\": \"How to resolve Brazil dependency conflicts?\", \"contents\": \"I'm getting the following error when building my package:\\n\\n```\\nCannot resolve dependency X\\n```\\n\\nHow can I fix this?\", \"tags\": [\"brazil\", \"build-system\"] }",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "packageTags": {
                  "type": "array",
                  "description": "Package tags to categorize the question (at least one tag or packageTag is required)",
                  "items": {
                    "type": "string"
                  }
                },
                "contents": {
                  "description": "Content of the question in Markdown format",
                  "type": "string"
                },
                "title": {
                  "type": "string",
                  "description": "Title of the question"
                },
                "tags": {
                  "items": {
                    "type": "string"
                  },
                  "description": "Tags to categorize the question (at least one tag or packageTag is required)",
                  "type": "array"
                }
              },
              "type": "object",
              "required": [
                "title",
                "contents"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___plantuml",
          "description": "Create and decode PlantUML diagrams using Amazon's internal PlantUML server.\nPlantUML allows creating UML diagrams from text descriptions.\n\nSupported operations:\n- encode: Convert PlantUML text to an encoded URL\n- decode: Extract PlantUML text from an encoded URL",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "additionalProperties": false,
              "required": [
                "operation"
              ],
              "properties": {
                "operation": {
                  "enum": [
                    "encode",
                    "decode"
                  ],
                  "description": "The operation to perform",
                  "type": "string"
                },
                "content": {
                  "description": "PlantUML content for encode operation",
                  "type": "string"
                },
                "url": {
                  "format": "uri",
                  "type": "string",
                  "description": "PlantUML URL for decode operation"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pipeline_current_blockers",
          "description": "Lists all active blockers on a pipeline, including disabled promotions, alarms in alert, and fitness summary",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "pipelineName": {
                  "type": "string",
                  "description": "Name of the pipeline to check for blockers"
                }
              },
              "type": "object",
              "required": [
                "pipelineName"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___genai_poweruser_read_knowledge",
          "description": "Access and retrieve the full content of knowledge documents using either a file path or document title. This tool enables direct retrieval of stored knowledge resources from the configured knowledge base, supporting both absolute and relative paths. Returns the document content along with path and title metadata.",
          "input_schema": {
            "json": {
              "properties": {
                "title": {
                  "description": "The title of the document to find",
                  "type": "string"
                },
                "path": {
                  "type": "string",
                  "description": "The path to the document file"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___taskei_get_room_identities",
          "description": "Fetch assignees from Taskei Rooms where the user has write permissions. Use this to find potential assignees when creating or updating tasks.",
          "input_schema": {
            "json": {
              "required": [
                "roomId"
              ],
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "maxResults": {
                  "type": "number",
                  "description": "Maximum number of results to return (default: 100)",
                  "exclusiveMinimum": 0
                },
                "cursor": {
                  "type": "string",
                  "description": "Optional pagination cursor for fetching next page of results"
                },
                "roomId": {
                  "description": "Room ID to get identities from",
                  "type": "string",
                  "minLength": 1
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pippin_sync_project_to_remote",
          "description": "Synchronizes local files to a Pippin project as artifacts",
          "input_schema": {
            "json": {
              "properties": {
                "createMissing": {
                  "type": "boolean",
                  "default": true,
                  "description": "Create artifacts if they don't exist"
                },
                "inputDirectory": {
                  "type": "string",
                  "description": "Local directory containing files to upload"
                },
                "nameFormat": {
                  "type": "string",
                  "description": "How to name artifacts",
                  "enum": [
                    "use_filename",
                    "use_id"
                  ]
                },
                "projectId": {
                  "type": "string",
                  "description": "Project ID"
                }
              },
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "projectId",
                "inputDirectory"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___tod_download_logs",
          "description": "Download ToD logs to a file",
          "input_schema": {
            "json": {
              "required": [
                "url"
              ],
              "additionalProperties": false,
              "properties": {
                "timeoutMs": {
                  "type": "number",
                  "description": "Custom timeout in milliseconds (default: 5000)"
                },
                "url": {
                  "type": "string",
                  "description": "URL of the ToD test run"
                },
                "outputPath": {
                  "description": "Custom output path for the log file",
                  "type": "string"
                }
              },
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___edit_quip",
          "description": "Edit Quip documents\n\nThis tool allows you to make targeted edits to specific sections of a Quip document\nusing section IDs obtained from the read_quip tool when using HTML format.\n\nWorkflow:\n1. Use read_quip with HTML format to get the document with section IDs\n2. Identify the section ID you want to modify (e.g., 'temp:C:SAf3351f25e51434479864cf71ce')\n3. Use edit_quip with the section ID and appropriate location parameter\n\nLocations:\n0: APPEND - Add to end of document (default)\n1: PREPEND - Add to beginning of document\n2: AFTER_SECTION - Insert after section_id\n3: BEFORE_SECTION - Insert before section_id\n4: REPLACE_SECTION - Replace section_id content\n5: DELETE_SECTION - Delete section_id (no content required)\n6: AFTER_DOCUMENT_RANGE - Insert after document_range\n7: BEFORE_DOCUMENT_RANGE - Insert before document_range\n8: REPLACE_DOCUMENT_RANGE - Replace document_range content\n9: DELETE_DOCUMENT_RANGE - Delete document_range (no content required)\n\nOptional Parameters:\n- returnFullDocument: Set to true to receive the full document content in addition to the status information\n\nExamples:\n1. Append to document:\n```json\n{\n  \"documentId\": \"https://quip-amazon.com/abc/Doc\",\n  \"content\": \"New content\",\n  \"format\": \"markdown\"\n}\n```\n\n2. Prepend to document:\n```json\n{\n  \"documentId\": \"https://quip-amazon.com/abc/Doc\",\n  \"content\": \"New content\",\n  \"format\": \"markdown\",\n  \"location\": 1\n}\n```\n\n3. Insert after section:\n```json\n{\n  \"documentId\": \"https://quip-amazon.com/abc/Doc\",\n  \"content\": \"New content\",\n  \"format\": \"markdown\",\n  \"location\": 2,\n  \"sectionId\": \"temp:C:SAf3351f25e51434479864cf71ce\"\n}\n```\n\n4. Replace section content:\n```json\n{\n  \"documentId\": \"https://quip-amazon.com/abc/Doc\",\n  \"content\": \"### New heading\",\n  \"format\": \"markdown\",\n  \"location\": 4,\n  \"sectionId\": \"temp:C:SAf3351f25e51434479864cf71ce\"\n}\n```\n\n5. Delete section:\n```json\n{\n  \"documentId\": \"https://quip-amazon.com/abc/Doc\",\n  \"content\": \"\",\n  \"format\": \"markdown\",\n  \"location\": 5,\n  \"sectionId\": \"temp:C:SAf3351f25e51434479864cf71ce\"\n}\n```\n\n6. Edit with concise response:\n```json\n{\n  \"documentId\": \"https://quip-amazon.com/abc/Doc\",\n  \"content\": \"New content\",\n  \"format\": \"markdown\",\n  \"location\": 4,\n  \"sectionId\": \"temp:C:SAf3351f25e51434479864cf71ce\",\n  \"returnFullDocument\": false\n}\n```",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "returnFullDocument": {
                  "type": "boolean",
                  "description": "Whether to return the full document content after editing (default: false)"
                },
                "content": {
                  "description": "The new content to write to the document",
                  "type": "string"
                },
                "format": {
                  "description": "The format of the content",
                  "default": "markdown",
                  "enum": [
                    "html",
                    "markdown"
                  ],
                  "type": "string"
                },
                "documentId": {
                  "description": "The Quip document URL or ID to edit",
                  "type": "string"
                },
                "sectionId": {
                  "type": "string",
                  "description": "Section ID for section operations"
                },
                "documentRange": {
                  "description": "Document range for range operations",
                  "type": "string"
                },
                "location": {
                  "maximum": 9,
                  "minimum": 0,
                  "type": "number",
                  "description": "Location for content insertion"
                }
              },
              "additionalProperties": false,
              "required": [
                "documentId",
                "content"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___andes_search",
          "description": "Search for Andes tables and providers.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "lifecycleStates": {
                  "description": "Filter by lifecycle states (comma-separated)",
                  "type": "string"
                },
                "exactMatch": {
                  "type": "boolean",
                  "description": "Whether to perform an exact match search"
                },
                "query": {
                  "description": "Search query for table searches",
                  "type": "string"
                },
                "limit": {
                  "description": "Maximum number of results to return",
                  "type": "number"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "required": [
                "query"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sim_search_issues",
          "description": "Search for SIM issues using a structured query syntax.\nThis tool allows searching for issues with various filters including status, assignee, requester, folder, date ranges, and ticket severity.\n\n\nQuery syntax examples:\n\n* Basic search: Lambda cold start\n\n* Filter by status: status:(Open)\n\n* Filter by assignee: assignee:(username)\n\n* Filter by requester: requester:(username)\n\n* Filter by folder: containingFolder:(folder-uuid)\n\n* Filter by date range: createDate:([2023-06-01T07:00:00.000Z TO 2025-03-01T08:00:00.000Z])\n\n* Filter by severity: extensions.tt.impact:(2) (severity must be a numerical value between 1-5)\n\n* Combine filters: status:(Open) assignee:(username) createDate:([2023-06-01T07:00:00.000Z TO 2025-03-01T08:00:00.000Z])\n\n\n\nSort options:\n\n* Sort by last updated: sort=lastUpdatedDate desc\n\n* Sort by creation date: sort=createDate asc\n\n\nRows options (a.k.a. how many SIMs to return per query):\n\n* Retrieve 10 results at a time: (rows=10)\n* Retrieve 35 results at a time: (rows=35)\nStart options:\n\n* Retrieve SIMs starting at the first result matching your query: start=0\n* Retrieve SIMs starting with the twentieth result matching your query: start=19\n\n\nPagination examples:\n\n* Query the first page of results with `(rows=10, start=0)`, then the second page with `(rows=10, start=10)`\n\n* Query the first page of results with `(rows=15)`, then the second page with `(rows=15, start=15)`",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "required": [
                "query"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "query": {
                  "type": "string",
                  "description": "Search query using SIM query syntax"
                },
                "rows": {
                  "type": "number",
                  "exclusiveMinimum": 0,
                  "maximum": 1000,
                  "description": "Maximum number of issues to return (1-1000, default: 50)"
                },
                "start": {
                  "type": "number",
                  "minimum": 0,
                  "description": "Which result number to start from (>=0, default: 0)"
                },
                "sort": {
                  "description": "Optional sort parameter (e.g., \"lastUpdatedDate desc\")",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sage_accept_answer",
          "description": "Accept an answer to a question on Sage (Amazon's internal Q&A platform).\n\nThis tool allows you to mark an answer as accepted for a question.\nOnly the question owner or users with appropriate permissions can accept answers.\n\nAuthentication:\n- Requires valid Midway authentication (run `mwinit` if you encounter authentication errors)\n\nCommon use cases:\n- Marking the most helpful answer to your question\n- Indicating which solution resolved your issue\n- Helping others find the correct answer quickly\n\nExample usage:\n{ \"answerId\": 7654321 }",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "required": [
                "answerId"
              ],
              "properties": {
                "answerId": {
                  "description": "ID of the answer to accept",
                  "type": "number"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_sable",
          "description": "Search for Sable scope recode with region id, scope, key or key prefix. This tool allows you to search Sable record by key or key prefix.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "scope": {
                  "description": "Sable scope name",
                  "type": "string"
                },
                "region": {
                  "description": "Sable region that are going to query data, e.g.: NA, EU, FE, Integ",
                  "type": "string"
                },
                "keyPrefix": {
                  "description": "Sable record key or key prefix",
                  "type": "string"
                }
              },
              "required": [
                "region",
                "scope",
                "keyPrefix"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___reassign_ticket_by_cti",
          "description": "This tool reassigns a ticket by specifying a new CTI (Category/Type/Item) path.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "ticketId",
                "category",
                "type",
                "item"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "ticketId": {
                  "description": "The ID of the ticket to reassign (e.g., 'P12345678' or 'T12345678')",
                  "type": "string"
                },
                "item": {
                  "type": "string",
                  "description": "The CTI item"
                },
                "requestId": {
                  "type": [
                    "string",
                    "number"
                  ],
                  "description": "Optional request identifier for JSON-RPC correlation and debugging."
                },
                "category": {
                  "description": "The CTI category",
                  "type": "string"
                },
                "type": {
                  "description": "The CTI type",
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sim_get_issue",
          "description": "Get detailed information about a specific SIM issue.\nRetrieves full details of an issue including title, description, status, assignee, comments, and more.\nYou can use either the P-number (e.g., P12345678) or the alias (e.g., CFN-12345) as the issue ID.\nOptionally include a specific thread (e.g., 'Updates') to get its comments.\nSet includeCustomAttributes to true to fetch custom fields like Due Date, Metric Scope, etc.\nSet includeRelatedTasks to true to fetch parent and subtasks.\nsetExtensions to true to fetch extension metadata like estimated effort and points spent.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "required": [
                "id"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "includeRelatedTasks": {
                  "description": "Whether to include parent and subtasks",
                  "type": "boolean"
                },
                "id": {
                  "type": "string",
                  "description": "Issue ID or alias (e.g., P12345678 or CFN-12345)"
                },
                "includeExtensions": {
                  "type": "boolean",
                  "description": "Whether to include extensions like estimated and spent points"
                },
                "includeCustomAttributes": {
                  "type": "boolean",
                  "description": "Whether to include custom attributes like Due Date, Metric Scope, etc."
                },
                "includeThread": {
                  "description": "Name of the thread to include (e.g., \"Updates\")",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sage_add_comment",
          "description": "Add a comment to a post on Sage (Amazon's internal Q&A platform).\n\nThis tool allows you to comment on questions or answers on Sage through the MCP interface.\nComments are useful for requesting clarification, providing additional context, or suggesting improvements.\nComments use plain text format (no Markdown support).\n\nAuthentication:\n- Requires valid Midway authentication (run `mwinit` if you encounter authentication errors)\n\nCommon use cases:\n- Asking for clarification on a question or answer\n- Providing additional context or information\n- Suggesting improvements or alternatives\n\nExample usage:\n{ \"postId\": 1234567, \"contents\": \"Could you also explain how this works with custom dependencies?\" }",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "postId": {
                  "description": "ID of the post (question or answer) to comment on",
                  "type": "number"
                },
                "contents": {
                  "description": "Content of the comment in plain text",
                  "type": "string"
                }
              },
              "required": [
                "postId",
                "contents"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sage_post_answer",
          "description": "Post an answer to an existing question on Sage (Amazon's internal Q&A platform).\n\nThis tool allows you to contribute answers to questions on Sage through the MCP interface.\nThe answer content supports Markdown formatting for rich text, code blocks, and links.\n\nAuthentication:\n- Requires valid Midway authentication (run `mwinit` if you encounter authentication errors)\n\nCommon use cases:\n- Answering technical questions about Amazon internal tools and services\n- Providing code examples or troubleshooting steps\n- Sharing knowledge about internal processes\n\nExample usage:\n{ \"questionId\": 1234567, \"contents\": \"To solve this issue, you need to run:\\n\\n```bash\\nbrazil workspace merge\\n```\\n\\nThis will resolve the dependency conflicts.\" }",
          "input_schema": {
            "json": {
              "required": [
                "questionId",
                "contents"
              ],
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "contents": {
                  "description": "Content of the answer in Markdown format",
                  "type": "string"
                },
                "questionId": {
                  "type": "number",
                  "description": "ID of the question to answer"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___marshal_get_report",
          "description": "Retrieve Marshal Report.\nMarshal is an internal AWS application for collecting insights from Solutions Architects (SAs), and other field teams, and facilitating the reporting process for Weekly/Monthly/Quarterly Business Reports (WBR/MBR/QBR).\n",
          "input_schema": {
            "json": {
              "required": [
                "reportId"
              ],
              "additionalProperties": false,
              "properties": {
                "reportId": {
                  "type": "string",
                  "pattern": "^\\d+$",
                  "description": "The ID of the Marshal Report (numeric ID only, not the full URL)"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sfdc_list_tasks_activity",
          "description": "This tool is for listing SA Activities and tasks in AWS Salesforce (AFA AWSentral)",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "opportunity_id": {
                  "description": "The Salesforce Opportunity ID to filter by - this will return all activities/tasks on a opportunity",
                  "type": "string"
                },
                "account_id": {
                  "type": "string",
                  "description": "The Salesforce Account ID to filter by - this will return all activities/tasks on an account and it's opportunities"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___jira_transition_issue",
          "description": "Transition a JIRA issue to a new status",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "transitionId": {
                  "type": "string",
                  "minLength": 1,
                  "description": "The ID of the transition"
                },
                "comment": {
                  "type": "string",
                  "description": "Optional comment to add during transition"
                },
                "issueIdOrKey": {
                  "minLength": 1,
                  "description": "The ID or key of the issue",
                  "type": "string"
                },
                "fields": {
                  "type": "object",
                  "description": "Optional fields to update during transition",
                  "additionalProperties": {}
                }
              },
              "required": [
                "issueIdOrKey",
                "transitionId"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___add_comment_quip",
          "description": "Add a comment to a Quip document\n\nThis tool allows you to add a comment to a specified Quip document or thread.\nComments appear in the thread's conversation panel and are visible to all document collaborators.\nThe comment will be attributed to the owner of the API token.\n\nParameters:\n- threadIdOrUrl: (Required) The Quip document/thread ID or URL to add a comment to\n- content: (Required) The comment message text to add\n- section_id: ID of a document section to comment on\n\nNotes:\n- Plain text only, no formatting or HTML is supported\n- Comments cannot be edited or deleted through the Quip API: These operations are not supported\n- Maximum length is 1MB (though practical messages are typically much shorter)\n- Only one of section_id or annotation_id can be provided\n- annotation_id is retrieved as a response of the get_recent_messages_quip tool\n- Manually creating a link to a quip section gives a response like : https://quip-amazon.com/bpVtAZ8LB0b4/Quip-Commenting-Capabilities-Test#fND9CAsTr5B\n- Where bpVtAZ8LB0b4 is the threadId, and fND9CAsTr5B is the section_id.\n- As such, the annotation_id is retreived by the get_recent_messages_quip tool\n\nExamples:\n1. Add a simple comment:\n```json\n{\n  \"threadIdOrUrl\": \"https://quip-amazon.com/abc/Doc\",\n  \"content\": \"Great document! I have a few suggestions.\"\n}\n```\n\n2. Add a comment to a specific section:\n```json\n{\n  \"threadIdOrUrl\": \"https://quip-amazon.com/abc/Doc\",\n  \"content\": \"This section needs more detail.\",\n  \"section_id\": \"SAf3351f25e51434479864cf71ce\"\n}\n```\n\n3. Reply to an existing comment:\n```json\n{\n  \"threadIdOrUrl\": \"https://quip-amazon.com/abc/Doc\",\n  \"content\": \"I agree with your comment.\",\n  \"annotation_id\": \"fND9CAeEYiG\"\n}\n```",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "threadIdOrUrl",
                "content"
              ],
              "additionalProperties": false,
              "properties": {
                "section_id": {
                  "type": "string",
                  "description": "ID of a document section to comment on"
                },
                "annotation_id": {
                  "type": "string",
                  "description": "ID of a document comment to reply to"
                },
                "threadIdOrUrl": {
                  "description": "The thread ID or Quip URL to add a comment to",
                  "type": "string"
                },
                "content": {
                  "type": "string",
                  "description": "The comment message content to add to the thread"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sim_update_issue",
          "description": "Update an existing SIM issue.\nThis tool allows updating various attributes of an existing issue including title, description, status, assignee, assigned folder, category, type, item, and assigned group.\nAt least one update parameter must be provided.\nThe issue ID can be either the P-number (e.g., P12345678) or the alias (e.g., CFN-12345).\nThe assignee should be a valid kerberos username without the @ANT.AMAZON.COM suffix.",
          "input_schema": {
            "json": {
              "required": [
                "issueId"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "title": {
                  "description": "New title for the issue",
                  "type": "string"
                },
                "category": {
                  "type": "string",
                  "description": "Category for the issue (e.g., \"Alexa\")"
                },
                "description": {
                  "description": "New description for the issue",
                  "type": "string"
                },
                "status": {
                  "description": "New status for the issue (e.g., Open, Closed, Pending)",
                  "type": "string"
                },
                "issueId": {
                  "type": "string",
                  "description": "Issue ID or alias (e.g., P12345678 or CFN-12345)"
                },
                "item": {
                  "description": "Item for the issue (e.g., \"Voice Routines - Bug\")",
                  "type": "string"
                },
                "assignedGroup": {
                  "type": "string",
                  "description": "Assigned group for the issue (e.g., \"Alexa-Routines-LLM\")"
                },
                "assignee": {
                  "type": "string",
                  "description": "New assignee kerberos username"
                },
                "type": {
                  "type": "string",
                  "description": "Type for the issue (e.g., \"Routines\")"
                },
                "assignedFolder": {
                  "description": "New assigned folder ID for the issue",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___read_internal_website",
          "description": "Read content from internal Amazon websites.\n\nSupported websites and their purposes:\n\nDocumentation & Knowledge:\n- docs.hub.amazon.dev: Internal technical documentation\n- hub.cx.aws.dev: Internal technical documentation for building an experience in the AWS Management Console\n- btdocs.builder-tools.aws.dev: BuilderHub contributor documentation\n- docs.ctps.amazon.dev: CTPS technical documentation\n- docs.paystation.amazon.dev: PayStation technical documentation\n- skb.highcastle.a2z: Security knowledge base docs\n- aristotle.a2z.com: AWS Security Knowledge Base Docs\n- docs.aws.amazon.com: External AWS documentation\n- documentation.skynet.aws.dev: Skynet documentation\n- sage.amazon.dev: Engineering Q&A platform\n- datacentral.a2z.com/cradle: DataCentral Cradle job runs\n- oldfart.tools.amazon.dev: Important user tenure information and cohort statistics\n- sidekick.aka.amazon.com: Help users perform redundant tasks of aggregating trouble ticket or SIM data by creating custom oncall reports\n\nDocument Storage & Sharing:\n- workdocs.amazon.com: Amazon WorkDocs (PDFs, Word Docs, Excel)\n- drive-render.corp.amazon.com: Amazon Drive content\n- quip-amazon.com: Collaborative documents\n- paste.amazon.com: Raw content sharing\n- w.amazon.com: Internal MediaWiki\n- noogle-eu.amazon.com: Noogle EU customer information system\n- noogle-na.amazon.com: Noogle NA customer information system\n- noogle-fe.amazon.com: Noogle FE customer information system\n- apttool.amazon.com: Weblab APT report\n- confluence.collab.games.aws.dev: Amazon Games internal confluence page\n\nDevelopment & Build Tools:\n- code.amazon.com: Internal code repository\n- build.amazon.com: Build fleet and net-gapped builds\n- pipelines.amazon.com: Pipeline information\n- tod.amazon.com: TOD Test run information\n- apollo.amazon.com: Apollo Environment information\n- artifact-browser.brazil.aws.dev: Artifact content browser\n- bindles.amazon.com: Permissions information\n- katal.amazon.dev: UI Components library named Katal (via CloudFront presigned URLs)\n- digicon.amazon.com: Digital Order Console for order information\n- grass-*.aka.amazon.com: Grass - Primary tool for exploring Ordering data (NA, EU, FE, CN regions)\n- grass.integ.amazon.com: Grass Integration environment for testing\n- cloudscape.aws.dev: Internal Cloudscape System Design documentation\n\nProject Management & Tickets:\n- taskei.amazon.dev: Task and project management, manage tasks, sprints, kanban boards, planning and scrum processes.\n- t.corp.amazon.com: Ticket system to manage urgent work through severity, routed based on CTI.\n- sim.amazon.com: Legacy issue management system. Used to manage Issues.\n- issues.amazon.com: Legacy issue management system. Used to manage Issues.\n- mcm.amazon.dev: Manual-change-management checklists\n- retro.corp.amazon.com: Sprint retrospectives\n- board.amazon.com: Organize tasks in cards in a board\n- kingpin.amazon.com: Amazon's internal system for managing and reporting goals\n- weblab.amazon.com: Weblab experiment details, configuration settings, and any weblabs flagged as risks.\n\nSecurity & Operations:\n- myappsecdashboard.corp.amazon.com: AppSec affinity contacts\n- cti.amazon.com: CTI and resolver group information\n- design-inspector.a2z.com: Design diagrams and threat models\n- redfort.amazon.com: Public Key Infrastructure for Amazon\n- f2p-visualizer.corp.amazon.com: F2P (Fulfill-to-Promise) visualizer for Amazon order planning information such as https://f2p-visualizer.corp.amazon.com/export/($ORDER_ID)\n- marts-gfs-ui-finuat.corp.amazon.com: MARTS (General AR Invoice Status Dashboard for FINUAT)\n- theauditor.amazon.com: LTRA (Lite Technical Risk Assessment) audit information\n\nTeam & Organization:\n- phonetool.amazon.com: Employee roster and details\n\nMedia & Communications:\n- broadcast.amazon.com: Internal broadcasts and videos with transcripts\n\nPolicy Documents:\n- policy.a2z.com: Amazon internal policy documents\nMonitoring\n- monitorportal.amazon.com: iGraph tool\n- carnaval.amazon.com: Monitoring and alarm management\n- deeops.aka.amazon.com: DeeOps STO Health monitoring for user statistics including current over SLA tickets, incoming/open/resolved tickets, MTTR, and ticket age metrics\n- lyrebird.corp.amazon.com: Lyrebird test reports and traffic test details\n\nAnalytics & Dashboards:\n- quicksight.aws.amazon.com: Amazon QuickSight dashboards and analytics\n\nConcurrency Control:\n- This tool supports processing multiple URLs concurrently with a configurable concurrency limit",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "useGenericStrategy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Use generic HTML to Markdown conversion instead of specific matchers"
                },
                "concurrencyLimit": {
                  "type": "number",
                  "description": "Maximum number of concurrent requests"
                },
                "tailingLineCount": {
                  "description": "Number of most recent log lines to return",
                  "type": "number"
                },
                "url": {
                  "description": "URL of the internal website to read. For backward compatibility with older clients.",
                  "type": "string",
                  "format": "uri"
                },
                "urls": {
                  "type": "array",
                  "items": {
                    "format": "uri",
                    "type": "string"
                  },
                  "description": "Array of internal website URLs to read. Multiple URLs will be processed concurrently based on the concurrencyLimit parameter."
                }
              },
              "type": "object",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___slack_send_message",
          "description": "Send a message to a specified Slack channel",
          "input_schema": {
            "json": {
              "properties": {
                "message": {
                  "type": "string",
                  "minLength": 1
                },
                "channelId": {
                  "type": "string",
                  "minLength": 1
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "channelId",
                "message"
              ],
              "type": "object",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___imr_costs_search_fleet",
          "description": "Search for fleets based on a query term, matching either fleet name or fleet owner.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "query"
              ],
              "properties": {
                "query": {
                  "description": "Query term could be a partial fleet name or one of the owners",
                  "type": "string"
                },
                "includeDeleted": {
                  "description": "Include deleted fleets",
                  "default": false,
                  "type": "boolean"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___policy_engine_get_risk",
          "description": "Access Amazon Policy Engine risk information for a specific entity. This tool allows you to retrieve detailed information about a specific risk or violation from Policy Engine.",
          "input_schema": {
            "json": {
              "required": [
                "entityId"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "entityId": {
                  "type": "string",
                  "description": "Entity ID of the risk/violation to view details for"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_symphony",
          "description": "Search for Symphony CREATIVE/PLACEMENT/EVENT/TAG with region id and query, this tool allows you to search Symphony objects by many dimensions, including Symphony creative owner, id, displayName etc.",
          "input_schema": {
            "json": {
              "properties": {
                "query": {
                  "type": "string",
                  "description": "Stringified query and sort key from the Elasticsearch DSL."
                },
                "type": {
                  "type": "string",
                  "description": "Content Symphony CREATIVE/PLACEMENT/EVENT/TAG"
                },
                "pageSize": {
                  "type": "number",
                  "description": "minimum: 1, maximum: 50"
                },
                "region": {
                  "type": "string",
                  "description": "Symphony region that are going to query data, e.g.: NA, EU, FE, Integ"
                }
              },
              "required": [
                "region",
                "type",
                "query"
              ],
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sim_add_label",
          "description": "Add a label to an existing SIM issue.\nThe issue ID can be either the P-number (e.g., P12345678) or the alias (e.g., CFN-12345).\nLabels help categorize issues and can be used for filtering and organization.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "required": [
                "issueId",
                "label"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "label": {
                  "type": "string",
                  "description": "Label to add to the issue"
                },
                "issueId": {
                  "type": "string",
                  "description": "Issue ID or alias (e.g., P12345678 or CFN-12345)"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___genai_poweruser_agent_script_get",
          "description": "Access the complete content and metadata of specific agentic scripts using either file paths or script names. This tool retrieves the full script implementation along with structured metadata, enabling deep inspection of script functionality, parameter requirements, and operational logic before execution. The flexible lookup system supports both direct path access and name-based discovery across multiple script directories, with proper handling of script extensions. Essential for understanding script capabilities before integration into workflows.",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "path": {
                  "description": "Path to the script file",
                  "type": "string"
                },
                "name": {
                  "type": "string",
                  "description": "Name of the script (with or without .script.md extension)"
                }
              },
              "additionalProperties": false,
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___read_quip",
          "description": "Read Quip document content\n\nThis tool retrieves the content of a Quip document in either HTML or Markdown format:\n\n- HTML format: More verbose but contains section IDs and additional metadata.\n  These unique section IDs (for h1, h2, h3, p, etc.) can be used with the edit_quip tool\n  to make targeted edits to specific sections of the document.\n\n- Markdown format: More concise and easier to read, but does not contain section IDs\n  or additional metadata. Best for when you just need the content in a readable format\n  and don't need to make targeted edits.\n\nWorkflow:\n1. Use read_quip to get the document content\n2. Identify the section ID you want to modify (when using HTML format)\n3. Use edit_quip with the section ID and appropriate location parameter\n\nExamples:\n1. Read document in HTML format (default):\n```json\n{\n  \"documentId\": \"https://quip-amazon.com/abc/Doc\"\n}\n```\n\n2. Read document in Markdown format:\n```json\n{\n  \"documentId\": \"https://quip-amazon.com/abc/Doc\",\n  \"format\": \"markdown\"\n}\n```",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "documentId"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "format": {
                  "type": "string",
                  "description": "Format to return the content in (html or markdown)",
                  "enum": [
                    "html",
                    "markdown"
                  ]
                },
                "documentId": {
                  "description": "The Quip document URL or ID to read",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___list_katal_components",
          "description": "List all available Katal components\n\nThis tool returns a list of all available components in the Katal library,\norganized by category with basic information about each component.\n\nExample usage:\n```json\n{}\n```",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {},
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pippin_update_artifact",
          "description": "Updates an existing artifact within a Pippin project",
          "input_schema": {
            "json": {
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Updated artifact name"
                },
                "designId": {
                  "description": "Artifact ID",
                  "type": "string"
                },
                "content": {
                  "description": "Updated artifact content (provide this OR contentPath)",
                  "type": "string"
                },
                "contentPath": {
                  "description": "Path to a file containing the artifact content (provide this OR content)",
                  "type": "string"
                },
                "description": {
                  "type": "string",
                  "description": "Updated artifact description"
                },
                "projectId": {
                  "description": "Project ID",
                  "type": "string"
                }
              },
              "required": [
                "projectId",
                "designId"
              ],
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___g2s2_create_cr",
          "description": "Creates a code review for a specified G2S2 stage version",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "description": {
                  "description": "A CR description to add",
                  "type": "string"
                },
                "stageVersion": {
                  "type": "string",
                  "description": "The stage version to create a code review for"
                },
                "crId": {
                  "type": "string",
                  "description": "Existing CR ID to update (optional)"
                }
              },
              "required": [
                "stageVersion",
                "description"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___prompt_farm_search_prompts",
          "description": "A specialized search tool designed to efficiently discover and retrieve tested prompt templates from Amazon internal PromptFarm, enabling developers to leverage community-vetted prompts for reducing LLM hallucinations and optimizing AI outputs. The tool surfaces prompts categorized by use case, download metrics, and community ratings to streamline prompt engineering workflows.",
          "input_schema": {
            "json": {
              "required": [
                "searchQuery"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "searchQuery": {
                  "type": "string",
                  "description": "The search query for PromptFarm"
                }
              },
              "additionalProperties": false,
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___jira_config_helper",
          "description": "Get help configuring JIRA tools for Q CLI",
          "input_schema": {
            "json": {
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "jira_url": {
                  "description": "Your JIRA instance URL (optional - for validation)",
                  "type": "string"
                },
                "token": {
                  "description": "Your JIRA token (optional - for validation)",
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___orca_get_latest_error_details",
          "description": "Get detailed error information from an Orca workflow run URL.\n\nThis tool extracts error details including stack traces from Orca Studio execution pages.\n\nExample:\n```json\n{ \"url\": \"https://us-east-1.studio.orca.amazon.dev/#/clients/MyClient/execution/12345\" }\n```",
          "input_schema": {
            "json": {
              "properties": {
                "url": {
                  "description": "The Orca Studio URL of the execution to analyze",
                  "type": "string"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "required": [
                "url"
              ],
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___mosaic_list_controls",
          "description": "\nThe AWS Control Library is the authoritative source of controls that AWS \nuses to manage operational risk. The library represents AWS's own control \nframework supporting high-level policies and standards, and represents \nmanagement's directives and requirements that prescribe how the organization \nmanages its risk and control processes. The library also provides a \nmapping of AWS controls to AWS' policies/standards, and external \nrequirements such as regulatory and compliance frameworks. AWS implements \nthese controls through various mechanisms, including architectural system \ndesign (e.g., region isolation), system enforced guardrails (e.g., static \ncode analysis), or and centrally enforced organizational processes (e.g., \napplication security reviews). Control owners, who are leaders at Level 8 \nor above within the business, validate each control. The Security Assurance \n& Compliance (SA&C) team independently challenges these validations. To \ndemonstrate assurance, each control includes a narrative that articulates \nhow the control is implemented and supporting evidence of control execution \nthat provides tangible proof of its implementation.\n\nThis tool returns the controls that are part of the AWS Control Library.",
          "input_schema": {
            "json": {
              "properties": {},
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___write_internal_website",
          "description": "Write to Amazon internal websites.\n\nSupported websites and their purposes:\n\nDocument Storage & Sharing:\n- w.amazon.com: Internal MediaWiki\n\nNote: By default, content is converted from Markdown to the target format.\nTo skip conversion (if your content is already in the target format), set skipConversion=true.",
          "input_schema": {
            "json": {
              "properties": {
                "title": {
                  "type": "string",
                  "description": "Title for the page (required for create operations)"
                },
                "versionSummary": {
                  "description": "Summary message for the version history",
                  "type": "string"
                },
                "skipConversion": {
                  "description": "Skip content format conversion",
                  "type": "boolean",
                  "default": false
                },
                "content": {
                  "type": "string",
                  "description": "Content to write in Markdown format"
                },
                "operation": {
                  "type": "string",
                  "enum": [
                    "update",
                    "append",
                    "prepend",
                    "create"
                  ],
                  "description": "Operation to perform"
                },
                "url": {
                  "format": "uri",
                  "type": "string",
                  "description": "Website URL to write to"
                },
                "format": {
                  "default": "XWiki",
                  "type": "string",
                  "description": "Format to write in",
                  "enum": [
                    "Markdown",
                    "XWiki",
                    "XHTML",
                    "HTML",
                    "Plain",
                    "MediaWiki"
                  ]
                }
              },
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "url",
                "content",
                "operation"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_internal_code",
          "description": "Search across files in Amazon's internal code repositories using code.amazon.com search. You can search across all packages or filter your search based on specific packages, file paths, or groups. To get all results for packages, file paths or groups, leave the query parameter blank.\n\nCOMMON USE CASES:\n• Find packages by name pattern and owner: Use filters.packages='*Service' and filters.group='my-team'\n• Find code in specific packages: Use filters.packages='MyPackage' with query='function name'\n• Find team's packages: Use filters.group='team-name' with empty query\n\nEXAMPLES:\n• Packages ending in 'Service' owned by 'my-team': {query: '', filters: {packages: '*Service', group: 'my-team'}}\n• All packages owned by a team: {query: '', filters: {group: 'team-name'}}\n• Code search in specific packages: {query: 'function', filters: {packages: 'MyPackage,OtherPackage'}}",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "query": {
                  "type": "string",
                  "description": "Search query. Leave this field blank for doing broad searches using packages, file paths or groups."
                },
                "type": {
                  "description": "Type of code search, can be (default|user). When search by 'user', query should be the user's login.",
                  "type": "string"
                },
                "exact": {
                  "type": "string",
                  "description": "Search for the exact text match. When provided, this will perform an exact text search in the code repository."
                },
                "params": {
                  "additionalProperties": false,
                  "description": "Parameters for the search, key should be the type, value is an object with type specific params inside",
                  "type": "object",
                  "properties": {
                    "user": {
                      "type": "object",
                      "additionalProperties": false,
                      "properties": {
                        "startTime": {
                          "type": "string",
                          "description": "Start date for user's code activity in YYYY-MM-DD format"
                        },
                        "endTime": {
                          "type": "string",
                          "description": "End date for user's code activity in YYYY-MM-DD format"
                        }
                      }
                    }
                  }
                },
                "filters": {
                  "type": "object",
                  "properties": {
                    "filePath": {
                      "type": "string",
                      "description": "Filepath for the code search. Supports wildcards. Multiple values can be separated by commas. Example: src/*.java,*.json,Config"
                    },
                    "group": {
                      "description": "Owning group for package. If the user is looking for code associated with a team then use this field. Multiple groups can be separated by commas. You can only search for names that do NOT contain whitespace. Example: mcp-community",
                      "type": "string"
                    },
                    "packages": {
                      "type": "string",
                      "description": "Package name without version. Supports wildcards. Multiple values can be separated by commas. Example: AMZN_AKI,*InternalMCPServer"
                    }
                  },
                  "additionalProperties": false,
                  "description": "Filters to narrow down search results"
                },
                "graphType": {
                  "type": "string",
                  "description": "Type of dependency or consumer graph to display. Valid values include consumer graphs (full_consumers, runtime_consumers, library_consumers, testrun_consumers, tool_consumers, direct_consumers) and dependency graphs (full_dependencies, all_dependencies, runtime_dependencies, library_dependencies, testrun_dependencies, tool_dependencies, direct_dependencies). Defaults to 'full_dependencies' when versionSetName is provided.",
                  "enum": [
                    "full_consumers",
                    "runtime_consumers",
                    "library_consumers",
                    "testrun_consumers",
                    "tool_consumers",
                    "direct_consumers",
                    "full_dependencies",
                    "all_dependencies",
                    "runtime_dependencies",
                    "library_dependencies",
                    "testrun_dependencies",
                    "tool_dependencies",
                    "direct_dependencies"
                  ]
                },
                "versionSetName": {
                  "description": "Version set name in the format GroupName/ChildName. Example: CASE/mainline",
                  "type": "string"
                },
                "packageTarget": {
                  "type": "string",
                  "description": "Package target in the format PackageName-Version. Example: MyPackage-1.0"
                }
              },
              "required": [
                "query"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sim_add_tag",
          "description": "Add a tag to an existing SIM issue.\nThe issue ID can be either the P-number (e.g., P12345678) or the alias (e.g., CFN-12345).\nThe assignee should be a valid kerberos username without the @ANT.AMAZON.COM suffix.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "issueId",
                "tag"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "properties": {
                "issueId": {
                  "description": "Issue ID or alias (e.g., P12345678 or CFN-12345)",
                  "type": "string"
                },
                "tag": {
                  "type": "string",
                  "description": "Tag to add to the issue"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___datanet_search",
          "description": "Search for Datanet (also known as ETLM) resources and get database information. Use this tool when users mention 'Datanet', 'ETLM', or need to search for ETL jobs in the Datanet service. This tool allows you to search across all Datanet resources (job profiles, jobs, publishers) using text queries, and retrieve logical database information for specific users. Search operations support pagination and can be filtered by size. The search functionality requires valid Midway authentication and returns structured results grouped by resource type. Database information retrieval requires appropriate permissions for the specified user.",
          "input_schema": {
            "json": {
              "properties": {
                "searchTerm": {
                  "description": "Search term for resource searches. Required for search_datanet_resources.",
                  "type": "string"
                },
                "start": {
                  "description": "Starting index for paginated search results",
                  "type": "number"
                },
                "username": {
                  "description": "Username (alias) for user-specific queries. Required for get_logical_dbs_for_user.",
                  "type": "string"
                },
                "size": {
                  "type": "number",
                  "description": "Number of results to return in search"
                },
                "operation": {
                  "type": "string",
                  "description": "The search operation to perform",
                  "enum": [
                    "search_datanet_resources",
                    "get_logical_dbs_for_user"
                  ]
                }
              },
              "required": [
                "operation"
              ],
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___taskei_get_task",
          "description": "Fetch a Taskei task by its ID. This tool retrieves detailed information about a specific task from Taskei, including its title, description, status, assignee, and other metadata. Use this tool when you need comprehensive information about a particular task for project tracking, status updates, or task management purposes. The tool requires a valid Taskei task ID either in a UUID format, or a short ID that is a combination of letters and numbers. Do not use this tool for other project management tools different than Taskei.",
          "input_schema": {
            "json": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "taskId": {
                  "description": "The ID of the Taskei task to fetch. Can be provided as either a UUID (e.g., '123e4567-e89b-12d3-a456-426614174000') or a short ID format (e.g., 'Taskei-1234' or 'ABC123')",
                  "type": "string"
                },
                "includeAttachments": {
                  "default": false,
                  "type": "boolean",
                  "description": "Whether to include the task's attachments in the response (default: false)"
                }
              },
              "required": [
                "taskId"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___create_folder_quip",
          "description": "Create a new Quip folder\n\nThis tool creates a new folder in Quip.\nYou can optionally specify a parent folder to create a subfolder.\n\nExamples:\n1. Create a root-level folder:\n```json\n{\n  \"title\": \"New Project Folder\"\n}\n```\n\n2. Create a subfolder:\n```json\n{\n  \"title\": \"Documentation\",\n  \"parentFolderId\": \"ABCDEF123456\"\n}\n```\n",
          "input_schema": {
            "json": {
              "properties": {
                "parentFolderId": {
                  "description": "ID of parent folder (if not provided, creates at root level)",
                  "type": "string"
                },
                "title": {
                  "description": "Title of the new folder",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "required": [
                "title"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___g2s2_import_stage_version",
          "description": "Imports ion file into a specified G2S2 stage version",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "stageVersion": {
                  "description": "The stage version to import into",
                  "type": "string"
                },
                "filepath": {
                  "description": "The ion file path to import",
                  "type": "string"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "stageVersion",
                "filepath"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___mosaic_list_risks",
          "description": "\nThe AWS Risk Library is an extensible reference library that contains potential risk events\nthat may impact AWS and/or its customers and the risk scenarios that could trigger them. The\nlibrary contains high-level risk categories (Level 1), (e.g., availability, security, third\nparty, etc.); sub-categories of risk events (Level 2) for each level 1 risk (e.g., network\nfailure, service failure, infrastructure failure); and plausible risk causes (Level 3) that\ncan result in a risk event (e.g., inadequate capacity planning, lack of governance oversight,\npower outages, etc.). The level 2 risk events are the central element of the risk library.\n\nThis tool returns the risks that are part of the AWS Risk Library.",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {}
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sfdc_opportunity_lookup",
          "description": "This tool is for looking up opportunities on the AWS Salesforce AKA AWSentral",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "account_name": {
                  "description": "the name of the account with the opportunities, this will pull all opportunities that may be related to an account, but not directly associated.",
                  "type": "string"
                },
                "opportunity_name": {
                  "type": "string",
                  "description": "the name of the opportunity to search for"
                },
                "opportunity_id": {
                  "description": "the id of the opportunity - this will only pull the 1 opportunity",
                  "type": "string"
                },
                "account_id": {
                  "type": "string",
                  "description": "the id of the account associated with the opportunity, this will pull all opportunities on an account, its best to use just the account_id"
                }
              },
              "type": "object",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_list_job_runs",
          "description": "List execution runs for a specific Cradle job.",
          "input_schema": {
            "json": {
              "required": [
                "profileId",
                "jobId"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "statusFilter": {
                  "type": "string",
                  "description": "Filter job runs by status (all|active|completed|failed|cancelled)"
                },
                "latestRunOnly": {
                  "type": "boolean",
                  "description": "Get only latest run for each job"
                },
                "pageToken": {
                  "description": "Token for pagination",
                  "type": "string"
                },
                "endTime": {
                  "type": "string",
                  "description": "End time for job run queries (milliseconds since epoch)"
                },
                "profileId": {
                  "type": "string",
                  "description": "UUID of the job profile"
                },
                "startTime": {
                  "description": "Start time for job run queries (milliseconds since epoch)",
                  "type": "string"
                },
                "jobId": {
                  "type": "string",
                  "description": "UUID of the job"
                },
                "pageSize": {
                  "description": "Number of items per page",
                  "type": "number"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sfdc_sa_activity",
          "description": "This tool is logging/creating, reading, updating or deleting SA Activities on AWS SFDC AKA AWSentral. You must have either account id or opportunity id to create",
          "input_schema": {
            "json": {
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "activity_status": {
                  "enum": [
                    "Not Started",
                    "In Progress",
                    "Completed",
                    "Waiting on someone else",
                    "Deferred",
                    "Unresponsive",
                    "Disqualified",
                    "Cancelled",
                    "Completed with Global Support",
                    "Sales handoff to BDM completed",
                    "Completed with sales handoff to BDM",
                    "Completed with funding program handoff to ATP Mgr"
                  ],
                  "type": "string",
                  "default": "Completed",
                  "description": "The activity Status. Default status is Completed."
                },
                "operation": {
                  "type": "string",
                  "description": "The operation to perform: create, read, update, or delete (always read before deleting, confirm with the user)",
                  "enum": [
                    "create",
                    "read",
                    "update",
                    "delete"
                  ]
                },
                "activity_id": {
                  "type": "string",
                  "description": "The ID of the SA Activity (required for read, update, and delete operations)"
                },
                "date": {
                  "description": "the date in MM-DD-YYYY, if left empty will be today's date, if you are unsure about today's date, leave this blank",
                  "type": "string"
                },
                "activity_description": {
                  "description": "A description of the activity, around 1 paragraph, rewrite the user's input to be more descriptive and professional, unless the user says not to.",
                  "type": "string"
                },
                "account_id": {
                  "type": "string",
                  "description": "the SFDC id of the account, use the sfdc_account_lookup tool to retrieve before submitting."
                },
                "activity_type": {
                  "type": "string",
                  "description": "The type of activity, one of Account Planning, Meeting, Architecture Review, Demo, Partner, or Workshop"
                },
                "activity_subject": {
                  "type": "string",
                  "description": "The title of the activity, keep it short"
                },
                "opportunity_id": {
                  "type": "string",
                  "description": "the SFDC id of the opportunity, use the sfdc_opportunity_lookup tool to retrieve before submitting."
                },
                "activity_assigned_to": {
                  "description": "The name of the user to which the activity should be assigned.",
                  "type": "string"
                }
              },
              "required": [
                "operation"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___g2s2_list_stage_version",
          "description": "Lists contents of a specified G2S2 stage version",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "stageVersion"
              ],
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "stageVersion": {
                  "type": "string",
                  "description": "The stage version to list"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_MCMs",
          "description": "Search and filter Change Management (CM) records by various criteria:\n        • Personnel: requesters, technicians, resolver groups\n        • Status: CM status and closure codes\n        • Time-based: creation, updates, scheduling, and execution dates\n        • Results: configurable result limits",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "actualStart": {
                  "additionalProperties": false,
                  "type": "object",
                  "description": "the actual start of the cm",
                  "properties": {
                    "between": {
                      "type": "object",
                      "additionalProperties": false,
                      "required": [
                        "start",
                        "end"
                      ],
                      "properties": {
                        "end": {
                          "type": "number"
                        },
                        "start": {
                          "type": "number"
                        }
                      },
                      "description": "provide this predicate to find Cms that have actual start time between the two values"
                    },
                    "greaterThan": {
                      "required": [
                        "value"
                      ],
                      "description": "provide this predicate to find Cms that have actual start time greater than the given value",
                      "type": "object",
                      "additionalProperties": false,
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      }
                    },
                    "greaterThanOrEqualTo": {
                      "required": [
                        "value"
                      ],
                      "additionalProperties": false,
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "description": "provide this predicate to find Cms that have actual start time greater than or equal to the given value",
                      "type": "object"
                    },
                    "lessThanOrEqualTo": {
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "type": "object",
                      "required": [
                        "value"
                      ],
                      "additionalProperties": false,
                      "description": "provide this predicate to find Cms that have actual start time less than or equal to the given value"
                    },
                    "lessThan": {
                      "required": [
                        "value"
                      ],
                      "additionalProperties": false,
                      "type": "object",
                      "description": "provide this predicate to find Cms that have actual start time less than the given value",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      }
                    }
                  }
                },
                "createdAt": {
                  "description": "the time the Cm was created",
                  "properties": {
                    "lessThanOrEqualTo": {
                      "additionalProperties": false,
                      "description": "provide this predicate to find Cms that have created at time less than or equal to the given value",
                      "type": "object",
                      "required": [
                        "value"
                      ],
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      }
                    },
                    "greaterThanOrEqualTo": {
                      "description": "provide this predicate to find Cms that have created at time greater than or equal to the given value",
                      "type": "object",
                      "additionalProperties": false,
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "required": [
                        "value"
                      ]
                    },
                    "between": {
                      "description": "provide this predicate to find Cms that have created at time between the two values",
                      "type": "object",
                      "properties": {
                        "end": {
                          "type": "number"
                        },
                        "start": {
                          "type": "number"
                        }
                      },
                      "required": [
                        "start",
                        "end"
                      ],
                      "additionalProperties": false
                    },
                    "lessThan": {
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "required": [
                        "value"
                      ],
                      "description": "provide this predicate to find Cms that have created at time less than the given value",
                      "type": "object",
                      "additionalProperties": false
                    },
                    "greaterThan": {
                      "description": "provide this predicate to find Cms that have created at time greater than the given value",
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "required": [
                        "value"
                      ],
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false,
                  "type": "object"
                },
                "scheduledStart": {
                  "additionalProperties": false,
                  "description": "the scheduled start of the cm",
                  "type": "object",
                  "properties": {
                    "greaterThanOrEqualTo": {
                      "additionalProperties": false,
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "required": [
                        "value"
                      ],
                      "description": "provide this predicate to find Cms that have scheduled end time greater than or equal to the given value"
                    },
                    "lessThan": {
                      "description": "provide this predicate to find Cms that have scheduled end time less than the given value",
                      "additionalProperties": false,
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "required": [
                        "value"
                      ],
                      "type": "object"
                    },
                    "greaterThan": {
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "required": [
                        "value"
                      ],
                      "additionalProperties": false,
                      "description": "provide this predicate to find Cms that have scheduled end time greater than the given value"
                    },
                    "lessThanOrEqualTo": {
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "required": [
                        "value"
                      ],
                      "description": "provide this predicate to find Cms that have scheduled end time less than or equal to the given value",
                      "additionalProperties": false
                    },
                    "between": {
                      "description": "provide this predicate to find Cms that have scheduled end time between the two values",
                      "additionalProperties": false,
                      "type": "object",
                      "required": [
                        "start",
                        "end"
                      ],
                      "properties": {
                        "end": {
                          "type": "number"
                        },
                        "start": {
                          "type": "number"
                        }
                      }
                    }
                  }
                },
                "actualEnd": {
                  "type": "object",
                  "properties": {
                    "greaterThan": {
                      "additionalProperties": false,
                      "description": "provide this predicate to find Cms that have actual end time greater than the given value",
                      "required": [
                        "value"
                      ],
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      }
                    },
                    "lessThanOrEqualTo": {
                      "additionalProperties": false,
                      "required": [
                        "value"
                      ],
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "type": "object",
                      "description": "provide this predicate to find Cms that have actual end time less than or equal to the given value"
                    },
                    "between": {
                      "description": "provide this predicate to find Cms that have actual end time between the two values",
                      "additionalProperties": false,
                      "type": "object",
                      "required": [
                        "start",
                        "end"
                      ],
                      "properties": {
                        "start": {
                          "type": "number"
                        },
                        "end": {
                          "type": "number"
                        }
                      }
                    },
                    "greaterThanOrEqualTo": {
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "required": [
                        "value"
                      ],
                      "additionalProperties": false,
                      "description": "provide this predicate to find Cms that have actual end time greater than or equal to the given value"
                    },
                    "lessThan": {
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "description": "provide this predicate to find Cms that have actual end time less than the given value",
                      "type": "object",
                      "required": [
                        "value"
                      ],
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false,
                  "description": "the actual end of the cm"
                },
                "updatedAt": {
                  "properties": {
                    "greaterThanOrEqualTo": {
                      "required": [
                        "value"
                      ],
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "description": "provide this predicate to find Cms that have updated at time greater than or equal to the given value",
                      "additionalProperties": false
                    },
                    "lessThan": {
                      "additionalProperties": false,
                      "required": [
                        "value"
                      ],
                      "description": "provide this predicate to find Cms that have updated at time less than the given value",
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      }
                    },
                    "greaterThan": {
                      "required": [
                        "value"
                      ],
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "description": "provide this predicate to find Cms that have updated at time greater than the given value",
                      "additionalProperties": false,
                      "type": "object"
                    },
                    "lessThanOrEqualTo": {
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "additionalProperties": false,
                      "description": "provide this predicate to find Cms that have updated at time less than or equal to the given value",
                      "type": "object",
                      "required": [
                        "value"
                      ]
                    },
                    "between": {
                      "required": [
                        "start",
                        "end"
                      ],
                      "properties": {
                        "start": {
                          "type": "number"
                        },
                        "end": {
                          "type": "number"
                        }
                      },
                      "additionalProperties": false,
                      "description": "provide this predicate to find Cms that have updated at time between the two values",
                      "type": "object"
                    }
                  },
                  "type": "object",
                  "additionalProperties": false,
                  "description": "the time the Cm was updated"
                },
                "cmStatus": {
                  "type": "array",
                  "items": {
                    "enum": [
                      "Draft",
                      "PendingApproval",
                      "Scheduled",
                      "Modified",
                      "Rejected",
                      "Cancelled",
                      "Completed",
                      "Paused",
                      "Aborted",
                      "Discarded",
                      "Rework Required",
                      "Scheduled with Comments",
                      "In Progress",
                      "Pending Reapproval",
                      "Modified after Execution",
                      "Pending Reapproval after Execution",
                      "Preflight"
                    ],
                    "type": "string"
                  },
                  "description": "the status of the Cm"
                },
                "cmOwnerCtiResolverGroup": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "description": "List of Resolver groups for the CMs"
                  }
                },
                "scheduledEnd": {
                  "properties": {
                    "greaterThanOrEqualTo": {
                      "additionalProperties": false,
                      "required": [
                        "value"
                      ],
                      "description": "provide this predicate to find Cms that have scheduled end time greater than or equal to the given value",
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      }
                    },
                    "lessThan": {
                      "additionalProperties": false,
                      "required": [
                        "value"
                      ],
                      "description": "provide this predicate to find Cms that have scheduled end time less than the given value",
                      "type": "object",
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      }
                    },
                    "lessThanOrEqualTo": {
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "additionalProperties": false,
                      "type": "object",
                      "description": "provide this predicate to find Cms that have scheduled end time less than or equal to the given value",
                      "required": [
                        "value"
                      ]
                    },
                    "greaterThan": {
                      "properties": {
                        "value": {
                          "type": "number"
                        }
                      },
                      "additionalProperties": false,
                      "required": [
                        "value"
                      ],
                      "type": "object",
                      "description": "provide this predicate to find Cms that have scheduled end time greater than the given value"
                    },
                    "between": {
                      "required": [
                        "start",
                        "end"
                      ],
                      "additionalProperties": false,
                      "description": "provide this predicate to find Cms that have scheduled end time between the two values",
                      "type": "object",
                      "properties": {
                        "start": {
                          "type": "number"
                        },
                        "end": {
                          "type": "number"
                        }
                      }
                    }
                  },
                  "additionalProperties": false,
                  "type": "object",
                  "description": "the scheduled end of the cm"
                },
                "closureCode": {
                  "type": "array",
                  "description": "the closure code of the CMs",
                  "items": {
                    "type": "string",
                    "enum": [
                      "Successful",
                      "Successful - Off Script",
                      "Unsuccessful"
                    ]
                  }
                },
                "numResults": {
                  "type": "number",
                  "description": "Number of results to return",
                  "default": 100
                },
                "requesters": {
                  "items": {
                    "type": "string",
                    "description": "List of requesters of the CMs"
                  },
                  "type": "array"
                },
                "technician": {
                  "type": "array",
                  "items": {
                    "description": "List of technicians of the CMs",
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___get_recent_messages_quip",
          "description": "Get recent messages from a Quip thread\n\nThis tool retrieves the most recent messages for a given Quip thread.\nYou can filter and sort the messages using various parameters.\n\nExamples:\n1. Get recent messages:\n```json\n{\n  \"threadIdOrUrl\": \"https://quip-amazon.com/abc/Doc\"\n}\n```\n\n2. Get recent messages with count:\n```json\n{\n  \"threadIdOrUrl\": \"https://quip-amazon.com/abc/Doc\",\n  \"count\": 10\n}\n```\n\n3. Get recent edit messages:\n```json\n{\n  \"threadIdOrUrl\": \"https://quip-amazon.com/abc/Doc\",\n  \"messageType\": \"edit\"\n}\n```",
          "input_schema": {
            "json": {
              "properties": {
                "count": {
                  "type": "number",
                  "description": "Number of messages to return (1-100, default 25)"
                },
                "lastUpdatedSinceUsec": {
                  "type": "number",
                  "description": "UNIX timestamp in microseconds for messages updated before"
                },
                "threadIdOrUrl": {
                  "description": "The thread ID or Quip URL to get messages from",
                  "type": "string"
                },
                "sortBy": {
                  "type": "string",
                  "description": "Alias for sortedBy",
                  "enum": [
                    "ASC",
                    "DESC"
                  ]
                },
                "messageType": {
                  "type": "string",
                  "description": "Type of messages to return",
                  "enum": [
                    "message",
                    "edit"
                  ]
                },
                "updatedSinceUsec": {
                  "type": "number",
                  "description": "UNIX timestamp in microseconds for messages updated at and after"
                },
                "maxCreatedUsec": {
                  "description": "UNIX timestamp in microseconds for messages created at and before",
                  "type": "number"
                },
                "sortedBy": {
                  "type": "string",
                  "enum": [
                    "ASC",
                    "DESC"
                  ],
                  "description": "Sort order for messages"
                }
              },
              "type": "object",
              "required": [
                "threadIdOrUrl"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___g2s2_create_stage_version",
          "description": "Creates a new stage version in G2S2 with the specified parent stage version",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "parentStageVersion": {
                  "type": "string",
                  "description": "The parent stage version for the stage version"
                },
                "stageVersion": {
                  "type": "string",
                  "description": "The stage version to create"
                }
              },
              "additionalProperties": false,
              "required": [
                "stageVersion",
                "parentStageVersion"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___imr_costs_get_fleet_summary",
          "description": "Presents the internal costs (IMR) for a fleet or AWS account. Retrieves the information from the tool Cerberus and monthly statements api.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "fleetType": {
                  "enum": [
                    "CONTAINER",
                    "AWS_ACCOUNT"
                  ],
                  "default": "CONTAINER",
                  "type": "string",
                  "description": "Container type, either CONTAINER or AWS_ACCOUNT"
                },
                "scenario": {
                  "description": "Scenario name",
                  "default": "Default CPT++",
                  "type": "string"
                },
                "month": {
                  "description": "Month in YYYY-MM-01 format",
                  "default": "2025-07-01",
                  "type": "string"
                },
                "rateCard": {
                  "type": "string",
                  "default": "yearly",
                  "description": "Rate card identifier (e.g. 2025)"
                },
                "resourceId": {
                  "description": "Resource identifier, fleetId or aws account",
                  "type": "string"
                },
                "period": {
                  "default": "YEAR_TO_DATE",
                  "type": "string",
                  "description": "Time period for the summary",
                  "enum": [
                    "MONTH",
                    "YEAR_TO_DATE",
                    "FULL_YEAR"
                  ]
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "resourceId"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_internal_websites",
          "description": "Search using Amazon's internal search engine is.amazon.com\n\nAvailable scopes:\n- ALL: Search across all resources (default)\n- WIKI: Internal Wiki (Amazon's central tribal knowledge repository on w.amazon.com, historically the main knowledge source containing team wikis, product documentation, personal knowledge, and experiences across various roles)\n- AWS_DOCS: AWS Documentation (official AWS service documentation and guides)\n- SAGE_HORDE: Sage/Q&A Sites (technical questions, answers, and discussions from Amazon's internal knowledge sharing platform)\n- BUILDER_HUB: BuilderHub (documentation for Amazon's internal developer tools and resources)\n- INSIDE: Inside Amazon (company news, HR policies, employee resources, and corporate information)\n- BROADCAST: Broadcast (company-wide announcements and communications)\n- IT: IT Services (IT support documentation, guides, and resources)\n- APGL: APG Library (AWS Prescriptive Guidance Library for AWS Professional Services delivery guidance)\n- EVERGREEN: Evergreen documentation platform (Specifically documentation for Amazon API or AAPI, API references, guides, etc.) hosted on console.harmony.a2z.com\n- IVY: Ivy Help (guidance for Amazon's internal talent management system, including hiring and promotions)\n- LIST_ARCHIVE: Email List Archive (archived email communications from internal mailing lists)\n- tool: Search internal tools on Spyglass (Community recommended tools, services, and content)\n\nSorting options:\n- SCORE (Default, sorts by relevance)\n- MODIFICATION_DATE (Last Modified, use with sortOrder)\n\nExamples:\n1. Basic search:\n   { \"query\": \"lambda\" }\n\n2. Search AWS docs sorted by newest first:\n   { \"query\": \"lambda\", \"scope\": \"AWS_DOCS\", \"sortBy\": \"MODIFICATION_DATE\", \"sortOrder\": \"DESC\" }\n\n3. Search Wiki with pagination:\n   { \"query\": \"brazil\", \"scope\": \"WIKI\", \"page\": \"2\" }\n\n4. Search Evergreen documentation for API guides:\n   { \"query\": \"Cards getting started\", \"scope\": \"EVERGREEN\" }\n\n5. Search Sage for technical questions about a specific topic:\n   { \"query\": \"lambda function scope stack\", \"scope\": \"SAGE_HORDE\" }\n\n6. Get detailed information about a specific scope:\n   { \"query\": \"about-scope:SAGE_HORDE\" }\n\n7. Search Wiki for team documentation:\n   { \"query\": \"Mirai team onboarding\", \"scope\": \"WIKI\" }\n\n8. Search BuilderHub for developer tools:\n   { \"query\": \"Brazil workspace setup\", \"scope\": \"BUILDER_HUB\" }\n\n9. Search Inside Amazon for HR policies:\n   { \"query\": \"remote work policy\", \"scope\": \"INSIDE\" }\n\n10. Search APG Library for AWS implementation guides:\n   { \"query\": \"migration best practices\", \"scope\": \"APGL\" }\n\n11. Search Ivy Help for promotion information:\n   { \"query\": \"promotion cycle timeline\", \"scope\": \"IVY\" }\n12. Search Internal Tools for Badge Report:\n   { \"query\": \"badge report\", \"scope\": \"tool\" }\n13. Search PCS on internal tools\n   { \"query\": \"PCS\", \"scope\": \"tool\" }\n14. Search JSON Prettifier internal tool\n   { \"query\": \"JSON Prettifier\", \"scope\": \"tool\" }\n15. Search Design Inspector in internal tools\n   { \"query\": \"Design Inspector\", \"scope\": \"tool\" }\n16. Search useful plantUML tools\n   { \"query\": \"plantUML\", \"scope\": \"tool\" }\n17. Search helpful tools for interviews on Spyglass\n   { \"query\": \"interviews\", \"scope\": \"tool\" }\n\nTips:\n- Start with the ALL scope to get a general sense of available information across all resources\n- Once you identify the likely location of information, use a specific scope for more focused results\n- Use sortBy: \"MODIFICATION_DATE\" with sortOrder: \"DESC\" to find the most recently updated content\n- For pagination, increment the page parameter to see additional results beyond the first page\n- For detailed information about a specific scope, use the query \"about-scope:<SCOPE_NAME>\" (e.g., \"about-scope:SAGE_HORDE\")",
          "input_schema": {
            "json": {
              "required": [
                "query"
              ],
              "properties": {
                "scope": {
                  "description": "Scope to search in (e.g., ALL, AWS_DOCS, WIKI, tool)",
                  "type": "string"
                },
                "page": {
                  "description": "Page of the search result, starting from 1",
                  "type": "string"
                },
                "sortBy": {
                  "description": "Sort field (SCORE, MODIFICATION_DATE)",
                  "type": "string"
                },
                "query": {
                  "type": "string",
                  "description": "Search query"
                },
                "sortOrder": {
                  "type": "string",
                  "enum": [
                    "ASC",
                    "DESC"
                  ],
                  "description": "Sort order (ASC for oldest first, DESC for newest first)"
                }
              },
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___mox_console",
          "description": "Access the MOX console to fetch order data from MORSE service",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "merchantCustomerId": {
                  "description": "The merchant customer ID (e.g., 994273326)",
                  "type": [
                    "string",
                    "number"
                  ]
                },
                "retrieveOrderReportData": {
                  "type": "boolean",
                  "description": "Whether to retrieve order report data",
                  "default": true
                },
                "orderIds": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    }
                  ],
                  "description": "The order ID(s) to retrieve. Can be a single order ID or an array of order IDs."
                },
                "retrievePromotions": {
                  "description": "Whether to retrieve promotions",
                  "default": true,
                  "type": "boolean"
                },
                "hostname": {
                  "type": "string",
                  "description": "Optional custom hostname for the API endpoint"
                },
                "retrieveExtendedItemFields": {
                  "type": "boolean",
                  "description": "Whether to retrieve extended item fields",
                  "default": true
                },
                "region": {
                  "default": "USAmazon",
                  "enum": [
                    "USAmazon",
                    "EUAmazon",
                    "JPAmazon"
                  ],
                  "type": "string",
                  "description": "The region to use for the API endpoint (USAmazon, EUAmazon, JPAmazon)"
                },
                "operation": {
                  "type": "string",
                  "enum": [
                    "getOrderDetailsNonUCI"
                  ],
                  "description": "The operation to perform. Available operations: getOrderDetailsNonUCI"
                }
              },
              "required": [
                "operation",
                "merchantCustomerId",
                "orderIds"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pippin_list_artifacts",
          "description": "Lists all artifacts for a specific Pippin project",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "properties": {
                "projectId": {
                  "type": "string",
                  "description": "Project ID"
                },
                "nextToken": {
                  "description": "Pagination token",
                  "type": "string"
                },
                "maxResults": {
                  "type": "number",
                  "description": "Maximum number of results to return"
                }
              },
              "required": [
                "projectId"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sim_get_folders",
          "description": "Get a list of available SIM folders.\nThis tool retrieves all folders that the authenticated user has access to.\nFolders are used to organize issues in SIM and are required when creating new issues.",
          "input_schema": {
            "json": {
              "properties": {},
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_search_profiles",
          "description": "Search for Cradle profiles by name or other criteria.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "searchTerm"
              ],
              "properties": {
                "searchTerm": {
                  "type": "string",
                  "description": "Search term for profile name searches"
                },
                "pageToken": {
                  "description": "Token for pagination",
                  "type": "string"
                },
                "limit": {
                  "description": "Maximum number of results to return",
                  "type": "number"
                },
                "pageSize": {
                  "description": "Number of items per page",
                  "type": "number"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___orca_list_runs_for_objectId",
          "description": "List all runs for a specific objectId in Orca Studio.\n\nAn objectId in Orca Studio represents a unique ID assigned to a single Execution.\nSince a single Execution can have multiple runs, the Object ID allows aggregation\nat a business process instance level. Use this tool when you need to\ntrack all workflow executions related to a specific object across different\nworkflows, rather than listing runs for a specific workflow.\n\nThis tool retrieves all execution runs associated with a given objectId,\nincluding runId, status, openedDate, and closedDate for each run.\n\nLimitations:\n- Results are limited to the most recent runs that haven't been deleted by retention policies (typically last 100)\n- Large datasets may experience timeout issues (default 60s timeout)\n\nParameters:\n- objectId: (required) The object ID to query runs for\n- clientId: (required) The Orca client ID\n- region: (optional) AWS region (defaults to us-east-1)\n\nExample:\n```json\n{ \"objectId\": \"d7f71182-d7b8-4886-8d07-15c404a82583\", \"clientId\": \"SafrReportingSILServiceBeta\" }\n```",
          "input_schema": {
            "json": {
              "required": [
                "objectId",
                "clientId"
              ],
              "properties": {
                "region": {
                  "description": "AWS region (defaults to us-east-1)",
                  "type": "string"
                },
                "clientId": {
                  "type": "string",
                  "description": "The Orca client ID"
                },
                "objectId": {
                  "type": "string",
                  "description": "The object ID to query runs for"
                }
              },
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___g2s2_create_label",
          "description": "Creates a new G2S2 label with the specified parent label",
          "input_schema": {
            "json": {
              "required": [
                "labelName",
                "stageVersion"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "labelName": {
                  "description": "The label name to create",
                  "type": "string"
                },
                "stageVersion": {
                  "description": "The stage version for the new label",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___genai_poweruser_agent_script_search",
          "description": "Perform comprehensive keyword searches across the entire agentic script library, examining script names, content bodies, and metadata fields simultaneously. This tool returns contextually-rich results with relevant text snippets surrounding each match, highlighting where and how search terms appear within scripts. Results include file locations, match types (filename, content, or description matches), and properly handles duplicate scripts with consolidated results. Perfect for discovering scripts based on functionality, implementation details, or descriptive elements rather than exact names.",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "query": {
                  "description": "Search query to find matching scripts",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "required": [
                "query"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pippin_list_projects",
          "description": "Lists all available Pippin design projects",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "nextToken": {
                  "description": "Pagination token",
                  "type": "string"
                },
                "maxResults": {
                  "description": "Maximum number of results to return",
                  "type": "number"
                },
                "user": {
                  "description": "User to filter by",
                  "type": "string"
                },
                "statuses": {
                  "type": "string",
                  "description": "Project statuses to filter by"
                }
              },
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___fetch_oncall_schedule",
          "description": "Fetches the OnCall schedule for the specified team and time range.\n\nReturns the matching schedule for the specified team within the given time range.\n\nExample:\n```json\n{\n  \"teamName\": \"ft-itc\",\n  \"from\": \"2025-06-01\",\n  \"to\": \"2025-06-07\"\n}\n```",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "additionalProperties": false,
              "required": [
                "teamName",
                "from",
                "to"
              ],
              "properties": {
                "to": {
                  "pattern": "\\d{4}-\\d{2}-\\d{2}",
                  "description": "End date (YYYY-MM-DD) of the schedule. Must not be earlier than the start date.",
                  "type": "string"
                },
                "from": {
                  "pattern": "\\d{4}-\\d{2}-\\d{2}",
                  "description": "Start date (YYYY-MM-DD) of the schedule.",
                  "type": "string"
                },
                "teamName": {
                  "type": "string",
                  "description": "The name of the OnCall team to fetch the schedule for."
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___orca_get_execution_data",
          "description": "Get execution data for a specific run in Orca Studio.\n\nExecution data is a key-value map (Shared Data) that is specified as\na payload for work items (workflow instances) and output artifacts\ngenerated during a workflow run. This tool is useful for debugging \nworkflow issues, extracting processed data from completed runs,\nor analyzing the data flow through specific workflow executions.\n\nThis tool retrieves detailed execution data including execution data map\nfor a specific runId within an objectId.\n\nLimitations:\n- If the Execution data is large it could cause performance issues\n- Supported classification of data is until orange\n- Large datasets may experience timeout issues (default 60s timeout)\n\nParameters:\n- objectId: (required) The object ID\n- workflowName: (required) The workflow name\n- runId: (required) The specific run ID to get data for\n- clientId: (required) The Orca client ID\n- region: (optional) AWS region (defaults to us-east-1)\n\nExample:\n```json\n{ \"objectId\": \"d7f71182-d7b8-4886-8d07-15c404a82583\", \"workflowName\": \"GenerateReportForNCA-beta\", \"runId\": \"b9d9c02a-d3f0-4da8-9601-1740f1aaaeae\", \"clientId\": \"SafrReportingSILServiceBeta\" }\n```",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "required": [
                "objectId",
                "workflowName",
                "runId",
                "clientId"
              ],
              "properties": {
                "workflowName": {
                  "type": "string",
                  "description": "The workflow name"
                },
                "region": {
                  "description": "AWS region (defaults to us-east-1)",
                  "type": "string"
                },
                "objectId": {
                  "description": "The object ID",
                  "type": "string"
                },
                "runId": {
                  "description": "The specific run ID to get data for",
                  "type": "string"
                },
                "clientId": {
                  "description": "The Orca client ID",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___marshal_search_insights",
          "description": "Search Marshal Insights.\nMarshal is an internal AWS application for collecting insights from Solutions Architects (SAs), and other field teams, and facilitating the reporting process for Weekly/Monthly/Quarterly Business Reports (WBR/MBR/QBR).\n",
          "input_schema": {
            "json": {
              "properties": {
                "managerAlias": {
                  "description": "Manager Alias - returns all employees below",
                  "type": "string"
                },
                "relativeDateRangeMs": {
                  "type": "string",
                  "pattern": "^\\d+$",
                  "description": "Relative date range for search (e.g. last 1 hour, last 1 week) in milliseconds"
                },
                "absoluteDateRangeStartDate": {
                  "description": "Absolute date range for search start date in milliseconds since 1/1/1970",
                  "pattern": "^\\d+$",
                  "type": "string"
                },
                "absoluteDateRangeEndDate": {
                  "type": "string",
                  "description": "Absolute date range for search end date in milliseconds since 1/1/1970",
                  "pattern": "^\\d+$"
                },
                "category": {
                  "type": "string",
                  "description": "Insight Category"
                }
              },
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___taskei_get_rooms",
          "description": "\n    Fetch user's Rooms from Taskei.\n    This tool retrieves detailed information about the Rooms the user has write permissions.\n    Use this tool when the user asks to fetch their rooms, but also when you need to understand user's context. All the tasks belong to a room, so if you need to do other actions where the room is needed, you can obtain them from this tool.\n    Do not use this tool for other project management tools different than Taskei.",
          "input_schema": {
            "json": {
              "properties": {
                "nameContains": {
                  "type": "string",
                  "description": "Search query string that filters results to only include Rooms where the name contains this text. Case-insensitive matching is applied to find partial or complete matches within Room names."
                },
                "maxResults": {
                  "description": "The maximum number of results that we want to fetch. The lesser the best, as the query will be faster. (default: 25)",
                  "type": "number",
                  "default": 25
                }
              },
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___jira_search_issues",
          "description": "Search for JIRA issues using JQL",
          "input_schema": {
            "json": {
              "properties": {
                "startAt": {
                  "minimum": 0,
                  "description": "The index of the first result to return (0-based)",
                  "type": "integer"
                },
                "validateQuery": {
                  "description": "Whether to validate the JQL query",
                  "type": "string"
                },
                "expand": {
                  "type": "string",
                  "description": "The additional information to include in the response"
                },
                "jql": {
                  "description": "JQL search query",
                  "minLength": 1,
                  "type": "string"
                },
                "maxResults": {
                  "minimum": 1,
                  "description": "The maximum number of results to return (default: 50)",
                  "maximum": 1000,
                  "type": "integer"
                },
                "fields": {
                  "type": "array",
                  "description": "The list of fields to return",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "required": [
                "jql"
              ],
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_get_job_details",
          "description": "Get detailed information about a specific Cradle job.",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "jobId": {
                  "description": "UUID of the job",
                  "type": "string"
                },
                "profileId": {
                  "description": "UUID of the job profile",
                  "type": "string"
                }
              },
              "required": [
                "profileId",
                "jobId"
              ],
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___genai_poweruser_agent_script_list",
          "description": "Discover and browse the complete collection of available agentic scripts with customizable filtering options. This tool provides a comprehensive inventory of script resources including their names, file paths, and detailed descriptions. Results are organized to help quickly identify relevant scripts for specific tasks, with automatic handling of duplicate scripts across different directories. Ideal for exploring the script library or finding scripts based on filename patterns. Returns script names, paths, and descriptions to help users discover relevant scripts for their tasks. Categorize the scripts based on description.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "filter": {
                  "description": "Filter to apply to script list",
                  "type": "string"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___marshal_get_insight",
          "description": "Retrieve Marshal Insights.\nMarshal is an internal AWS application for collecting insights from Solutions Architects (SAs), and other field teams, and facilitating the reporting process for Weekly/Monthly/Quarterly Business Reports (WBR/MBR/QBR).\n",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "insightId": {
                  "description": "The ID of the Marshal insight (numeric ID only, not the full URL)",
                  "type": "string",
                  "pattern": "^\\d+$"
                }
              },
              "required": [
                "insightId"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sfdc_contact_lookup",
          "description": "This tool is for looking up contacts on the AWS Salesforce AKA AWSentral",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "contact_name": {
                  "type": "string",
                  "description": "the name of the contact"
                },
                "contact_id": {
                  "description": "the id of the contact",
                  "type": "string"
                },
                "email": {
                  "type": "string",
                  "description": "the email address of the contact"
                },
                "account_name": {
                  "description": "the name of the account associated with the contact",
                  "type": "string"
                },
                "phone": {
                  "type": "string",
                  "description": "the phone number of the contact"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___mermaid",
          "description": "Create and decode Mermaid diagrams using Amazon's internal Mermaid editor.\nMermaid allows creating flowcharts, sequence diagrams, and more using text descriptions.\n\nSupported operations:\n- encode: Convert Mermaid text to an encoded URL\n- decode: Extract Mermaid text from an encoded URL",
          "input_schema": {
            "json": {
              "properties": {
                "operation": {
                  "enum": [
                    "encode",
                    "decode"
                  ],
                  "type": "string",
                  "description": "The operation to perform"
                },
                "content": {
                  "type": "string",
                  "description": "Mermaid content for encode operation"
                },
                "url": {
                  "type": "string",
                  "format": "uri",
                  "description": "Mermaid URL for decode operation"
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "operation"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___datanet_writer",
          "description": "Create, update, and manage Datanet (also known as ETLM) resources including job profiles, jobs, and job runs. Use this tool when users mention 'Datanet', 'ETLM', or need to work with ETL jobs in the Datanet service. This tool allows you to create and edit job profiles (TRANSFORM, DATA_FEED, LOAD, METRICS, ANDES_LOAD), create and edit jobs based on these profiles, run jobs, and download job run outputs. Write operations require appropriate permissions to the specified database users, logical databases, and host groups. Job creation requires a valid profile ID, and job runs require a valid job ID. Different operations have specific required parameters and formatting requirements as detailed in the parameter descriptions.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "priority": {
                  "type": "string",
                  "description": "Job priority (NORMAL, LOW, HIGH)"
                },
                "jobProfileId": {
                  "description": "ID of the job profile. Required for edit_job_profile.",
                  "type": "string"
                },
                "mimeType": {
                  "type": "string",
                  "description": "Format of the output (plain, text, excel, html). Default: plain"
                },
                "description": {
                  "type": "string",
                  "description": "Job description"
                },
                "scheduleType": {
                  "type": "string",
                  "description": "Schedule type (NOT_SCHEDULED, DAILY, CRON)"
                },
                "timezone": {
                  "type": "string",
                  "description": "Timezone (e.g., America/Los_Angeles)"
                },
                "dayPreferencesJson": {
                  "description": "JSON string of day preferences for DAILY schedule",
                  "type": "string"
                },
                "logicalDB": {
                  "description": "Logical database",
                  "type": "string"
                },
                "generateNFiles": {
                  "type": "number",
                  "description": "Generate N Files (METRICS jobs)"
                },
                "jobDataJson": {
                  "type": "string",
                  "description": "Additional job data as JSON string (ANDES_LOAD jobs)"
                },
                "mapping": {
                  "description": "Mapping configuration (METRICS jobs)",
                  "type": "string"
                },
                "jobId": {
                  "type": "string",
                  "description": "ID of the job. Required for edit_job and run_job."
                },
                "outputPath": {
                  "type": "string",
                  "description": "File path to save the output. Required for download_job_run_output."
                },
                "partitionKeysJson": {
                  "description": "Partition keys as JSON string",
                  "type": "string"
                },
                "allowZeroRowsJson": {
                  "description": "JSON string for allow zero rows configuration (LOAD jobs)",
                  "type": "string"
                },
                "profileType": {
                  "description": "Type of the profile (e.g., TRANSFORM, DATA_FEED, LOAD, METRICS, ANDES_LOAD). Required for profile operations.",
                  "type": "string"
                },
                "profileData": {
                  "description": "JSON string containing the profile data. Required for create_job_profile and edit_job_profile.\n      \nFor create_job_profile operation, the profileData must include:\n\n1. Required fields for all profile types:\n   - __type: Must match the profile type (see mapping below)\n   - type: Profile type (e.g., \"TRANSFORM\", \"DATA_FEED\", \"LOAD\")\n   - description: Profile description\n   - status: Profile status (\"ACTIVE\", \"INACTIVE\")\n   - group: Group name for permissions\n\n2. Profile type specific fields:\n   - TRANSFORM/DATA_FEED: \n     - __type: \"TransformJobProfile:http://internal.amazon.com/coral/com.amazon.datanet.model/\" or \"DataFeedJobProfile:http://internal.amazon.com/coral/com.amazon.datanet.model/\"\n     - sql: SQL query for the profile (e.g., \"SELECT customer_id, UPPER(customer_name) as customer_name_upper FROM customers;\")\n     - output: (Optional) Output configuration object, for example:\n       {\n         \"__type\": \"FileTemplate:http://internal.amazon.com/coral/com.amazon.datanet.model/\",\n         \"fileTemplate\": \"/path/to/output/file_{JOBRUN_DETAILS}.txt\"\n       }\n   \n   - LOAD:\n     - __type: \"FileLoadJobProfile:http://internal.amazon.com/coral/com.amazon.datanet.model/\"\n     - logicalDb: Logical database name (e.g., \"findbrs01\")\n     - qualifiedTable: Object with tableName and tableOwner, for example:\n       {\n         \"tableName\": \"TARGET_TABLE\",\n         \"tableOwner\": \"TABLE_OWNER\",\n         \"tableVariant\": null\n       }\n     - inputs: Array of input file templates, for example:\n       [{\n         \"__type\": \"FileTemplate:http://internal.amazon.com/coral/com.amazon.datanet.model/\",\n         \"fileTemplate\": \"/path/to/input/data_{JOBRUN_DETAILS}.txt\"\n       }]\n     - loadOption: Load option configuration, for example:\n       {\n         \"__type\": \"InsertLoadOption:http://internal.amazon.com/coral/com.amazon.datanet.model/\",\n         \"loadSequential\": false,\n         \"replaceOption\": \"PARTITION\"\n       }\n     - filterSql: SQL filter (can be \"1=1\" if not needed)\n   \n   - METRICS:\n     - __type: \"MetricsJobProfile:http://internal.amazon.com/coral/com.amazon.datanet.model/\"\n     - inputFileTemplate: Template file path (e.g., \"METRICS_TEMPLATE.xlsx\")\n     - outputDataset: Output dataset path (e.g., \"Metrics_Report_{JOBRUN_DETAILS}.xlsx\")\n     - output: Output configuration object, for example:\n       {\n         \"__type\": \"FileTemplate:http://internal.amazon.com/coral/com.amazon.datanet.model/\",\n         \"fileTemplate\": \"Metrics_Report_{JOBRUN_DETAILS}.xlsx\"\n       }\n   \n   - ANDES_LOAD:\n     - type: \"ANDES_LOAD\"\n     - profileData: JSON string with Andes table configuration, for example:\n       \"{\"tableOwner\":\"andes-provider-uuid\",\"tableName\":\"target-table-name\",\"partitionSchemeName\":\"partition-scheme-uuid\",\"loadType\":\"APPEND\",\"loadOption\":\"UPSERT\",\"inputFileTemplates\":[\"/path/to/input_{JOBRUN_DETAILS}.tsv\"]}\"\n\nExample for creating a TRANSFORM profile:\n{\n  \"__type\": \"TransformJobProfile:http://internal.amazon.com/coral/com.amazon.datanet.model/\",\n  \"type\": \"TRANSFORM\",\n  \"description\": \"Transform customer data\",\n  \"sql\": \"SELECT customer_id, UPPER(customer_name) as customer_name_upper FROM customers;\",\n  \"status\": \"ACTIVE\",\n  \"group\": \"your-group-name\"\n}",
                  "type": "string"
                },
                "datasetDate": {
                  "type": "string",
                  "description": "Dataset date in YYYY-MM-DD format. Required for run_job."
                },
                "dbUser": {
                  "type": "string",
                  "description": "Database user"
                },
                "allowableRejects": {
                  "description": "Allowable rejects (LOAD jobs)",
                  "type": "number"
                },
                "jobRunId": {
                  "type": "string",
                  "description": "ID of the job run. Required for download_job_run_output."
                },
                "group": {
                  "description": "Job group",
                  "type": "string"
                },
                "status": {
                  "type": "string",
                  "description": "Job status (ACTIVE, INACTIVE)"
                },
                "hostGroup": {
                  "type": "string",
                  "description": "Host group"
                },
                "validateRowCount": {
                  "type": "boolean",
                  "description": "Validate row count (LOAD jobs)"
                },
                "owner": {
                  "type": "string",
                  "description": "Job owner"
                },
                "scheduled": {
                  "description": "Whether the job run is scheduled (defaults to false)",
                  "type": "boolean"
                },
                "cronExpression": {
                  "description": "Cron expression for CRON schedule",
                  "type": "string"
                },
                "encoding": {
                  "description": "Character encoding for the output (UTF8, SJIS, ISO8859_1). Default: UTF8",
                  "type": "string"
                },
                "profileId": {
                  "type": "string",
                  "description": "Profile ID for the job"
                },
                "operation": {
                  "enum": [
                    "create_job_profile",
                    "edit_job_profile",
                    "create_job",
                    "edit_job",
                    "run_job",
                    "download_job_run_output"
                  ],
                  "type": "string",
                  "description": "The operation to perform"
                },
                "jobType": {
                  "description": "Job type (TRANSFORM, DATA_FEED, LOAD, METRICS, ANDES_LOAD)",
                  "type": "string"
                },
                "jobData": {
                  "type": "string",
                  "description": "JSON string containing the job data. Must include required fields like profileId, type, description, owner, group, etc.\n      \nExample for TRANSFORM job:\n{\n  \"profileId\": 13401437,\n  \"type\": \"TRANSFORM\",\n  \"description\": \"TRANSFORM job description\",\n  \"owner\": \"your-alias\",\n  \"group\": \"your-group-name\",\n  \"dbUser\": \"your-db-user\",\n  \"logicalDB\": \"your-logical-db\",\n  \"timezone\": \"America/Los_Angeles\",\n  \"priority\": \"NORMAL\",\n  \"schedule\": {\n    \"type\": \"NOT_SCHEDULED\"\n  },\n  \"status\": \"ACTIVE\",\n  \"hostGroup\": \"GenericHosts\",\n  \"partitionKeys\": [\n    {\n      \"partitionTypeId\": \"REGION\",\n      \"partitionValue\": 1\n    }\n  ]\n}\n\nFor create_job operation, the jobData must include:\n\n1. Required fields for all job types:\n   - __type: Must match the job type (see mapping below)\n   - profileId: The profile ID to create the job from\n   - type: Job type (must match profile type, e.g., \"TRANSFORM\")\n   - description: Job description\n   - owner: Job owner (your alias)\n   - group: Group name for permissions\n   - timezone: Timezone (e.g., \"America/Los_Angeles\")\n   - priority: Job priority (\"LOW\", \"NORMAL\", \"HIGHEST\")\n   - schedule: Schedule configuration object with specific format based on schedule type:\n     - Not Scheduled: { \n         \"__type\": \"NotScheduled:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \n         \"type\": \"NOT_SCHEDULED\" \n       }\n     - Daily Schedule: { \n         \"__type\": \"Daily:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \n         \"type\": \"DAILY\", \n         \"dayPreferences\": [\n           {\n             \"datasetDay\": \"MONDAY\", \n             \"deliveryDay\": \"TUESDAY\", \n             \"deliveryTime\": \"08:00:00\"\n           }\n         ] \n       }\n     - Intraday Schedule: { \n         \"__type\": \"Intraday:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \n         \"type\": \"INTRADAY\", \n         \"time\": [\"02:00:00\", \"04:00:00\", \"06:00:00\", \"08:00:00\"]\n       }\n     - Monthly Schedule: { \n         \"__type\": \"Monthly:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \n         \"type\": \"MONTHLY\", \n         \"monthDay\": 5\n       }\n     - Cron Schedule: { \n         \"__type\": \"CronSchedule:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \n         \"type\": \"CRON\", \n         \"cronExpression\": \"0 17 * * 2\" \n       }\n   - status: Job status (\"ACTIVE\", \"INACTIVE\", \"DISABLED\")\n   - hostGroup: Host group (typically \"GenericHosts\")\n   - partitionKeys: Array of partition key objects, for example:\n     [\n       {\n         \"partitionTypeId\": \"REGION\",\n         \"partitionValue\": 1\n       },\n       {\n         \"partitionTypeId\": \"LEGAL_ENTITY_ID\",\n         \"partitionValue\": 101\n       }\n     ]\n\n2. Job type mapping by profile type:\n   - TRANSFORM/DATA_FEED: __type: \"ExtractJob:http://internal.amazon.com/coral/com.amazon.datanet.model/\"\n     Additional required fields:\n     - dbUser: Database user (e.g., \"amzn:cdo:datanet-dbuser:your_db_user\")\n     - logicalDB: Logical database name (e.g., \"findbrs01\")\n   \n   - LOAD: __type: \"LoadJob:http://internal.amazon.com/coral/com.amazon.datanet.model/\"\n     Additional required fields:\n     - dbUser: Database user (e.g., \"amzn:cdo:datanet-dbuser:your_db_user\")\n     - allowZeroRows: Object with days of week, for example:\n       {\n         \"MONDAY\": true, \"TUESDAY\": true, \"WEDNESDAY\": true, \"THURSDAY\": true,\n         \"FRIDAY\": true, \"SATURDAY\": true, \"SUNDAY\": true\n       }\n     - allowableRejects: Number (typically 0)\n     - validateRowCount: Boolean (typically false)\n   \n   - METRICS: __type: \"ConversionJob:http://internal.amazon.com/coral/com.amazon.datanet.model/\"\n     Additional required fields:\n     - generateNFiles: Number (typically 1)\n     - mapping: JSON string with tab mapping configuration, for example:\n       \"{\"tab mapping\":{\"Sample Tab\":333720},\"cutoff\":{},\"version\":1}\"\n   \n   - ANDES_LOAD: __type: \"ExtractJob:http://internal.amazon.com/coral/com.amazon.datanet.model/\"\n     Additional required fields:\n     - jobData: JSON string with configuration, for example:\n       \"{\"allowableRejects\":null,\"allowZeroRowsDays\":null}\"\n\n3. Schedule types:\n   - Not Scheduled: { \"__type\": \"NotScheduled:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \"type\": \"NOT_SCHEDULED\" }\n   - Daily: { \"__type\": \"Daily:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \"type\": \"DAILY\", \"dayPreferences\": [{\"datasetDay\": \"MONDAY\", \"deliveryDay\": \"TUESDAY\", \"deliveryTime\": \"00:00\"}] }\n   - Intraday: { \"__type\": \"Intraday:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \"type\": \"INTRADAY\", \"time\": [\"02:00:00\", \"04:00:00\", \"06:00:00\", \"08:00:00\"] }\n   - Monthly: { \"__type\": \"Monthly:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \"type\": \"MONTHLY\", \"monthDay\": 5 }\n   - Cron: { \"__type\": \"CronSchedule:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \"type\": \"CRON\", \"cronExpression\": \"0 17 * * 2\" }\n\nFor edit_job operation, the jobData must follow the correct structure:\n\n1. For schedule updates:\n   - Use a nested 'schedule' object with the correct __type and type fields\n   - For CRON schedules: { \"schedule\": { \"__type\": \"CronSchedule:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \"type\": \"CRON\", \"cronExpression\": \"0 17 * * 2\" } }\n   - For DAILY schedules: { \"schedule\": { \"__type\": \"DailySchedule:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \"type\": \"DAILY\", \"dayPreferences\": [{\"datasetDay\": \"MONDAY\", \"deliveryDay\": \"TUESDAY\", \"deliveryTime\": \"08:00:00\"}] } }\n   - For NOT_SCHEDULED: { \"schedule\": { \"__type\": \"NotScheduled:http://internal.amazon.com/coral/com.amazon.datanet.model/\", \"type\": \"NOT_SCHEDULED\" } }\n\n2. For other common fields:\n   - description: String description of the job\n   - priority: String value (e.g., \"NORMAL\", \"LOW\", \"HIGH\")\n   - status: String value (e.g., \"ACTIVE\", \"INACTIVE\")\n   - timezone: String timezone (e.g., \"America/Los_Angeles\")\n   \nExample for creating a TRANSFORM job:\n{\n  \"__type\": \"ExtractJob:http://internal.amazon.com/coral/com.amazon.datanet.model/\",\n  \"profileId\": 13401437,\n  \"type\": \"TRANSFORM\",\n  \"description\": \"TRANSFORM job description\",\n  \"owner\": \"your-alias\",\n  \"group\": \"your-group-name\",\n  \"dbUser\": \"your-db-user\",\n  \"logicalDB\": \"your-logical-db\",\n  \"timezone\": \"America/Los_Angeles\",\n  \"priority\": \"NORMAL\",\n  \"schedule\": {\n    \"__type\": \"NotScheduled:http://internal.amazon.com/coral/com.amazon.datanet.model/\",\n    \"type\": \"NOT_SCHEDULED\"\n  },\n  \"status\": \"ACTIVE\",\n  \"hostGroup\": \"GenericHosts\",\n  \"partitionKeys\": [\n    {\n      \"partitionTypeId\": \"REGION\",\n      \"partitionValue\": 1\n    }\n  ]\n}"
                }
              },
              "required": [
                "operation"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___rtla_fetch_single_request_logs",
          "description": "Fetch detailed logs for a single request from RTLA (Real-Time Log Analysis) API. This tool allows you to retrieve comprehensive log entries for a specific request ID, including error logs, stack traces, and detailed request information. The response is automatically filtered to include only essential debugging fields for easier analysis. Useful for deep-dive troubleshooting of specific issues, analyzing error patterns for individual requests, and getting complete context for failed transactions.",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "requestType": {
                  "type": "string",
                  "description": "Type of request logs to retrieve (e.g., \"FATAL\", \"NONFATAL\")"
                },
                "org": {
                  "type": "string",
                  "description": "Organization identifier (e.g., \"CWCBCCECMPROD\")"
                },
                "requestId": {
                  "type": "string",
                  "description": "Specific request ID to fetch logs for (e.g., \"GHHJD10YZDJNXT062G2X\")"
                },
                "identifyAdditionalOrgs": {
                  "type": "boolean",
                  "default": true,
                  "description": "Whether to identify additional organizations related to this request"
                },
                "date": {
                  "description": "Date in milliseconds since epoch when the request occurred",
                  "type": "number"
                }
              },
              "required": [
                "org",
                "requestType",
                "date",
                "requestId"
              ],
              "type": "object",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___g2s2_freeze_stage_version",
          "description": "Freezes a specified G2S2 stage version",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "stageVersion"
              ],
              "type": "object",
              "properties": {
                "stageVersion": {
                  "description": "The stage version to freeze",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___read_orr",
          "description": "Read Operational Readiness Review (ORR) documents from https://www.orr.reflect.aws.dev/.\nORR documents contain detailed information about operational readiness reviews including:\n- Review questions and answers\n- Service or feature assessments\n- Operational readiness criteria\n- Launch approval status\n\n⚠️ IMPORTANT: This tool accesses sensitive operational review data that will be processed by the LLM.\nBefore using this tool, you MUST explicitly ask for user approval with the following message:\n\"I need to access an Operational Readiness Review (ORR) document which contains sensitive operational data.\nThis data will be processed by the LLM to answer your question. Do you approve accessing this ORR document?\"\n\nOnly proceed if the user explicitly approves. This confirmation is required even if the tool is auto-approved.\n\nExample usage:\nTo read an ORR document with a specific review ID:\n{ \"url\": \"https://www.orr.reflect.aws.dev/review/687e56b9-d3d4-4bd5-b033-379461c96381/questions\" }\n\nTo read an ORR template:\n{ \"url\": \"https://www.orr.reflect.aws.dev/template/787a767f-af3a-4747-97ca-b617d2e4cbe0/content\" }\n\nTo read only a specific section by ID:\n{ \"url\": \"https://www.orr.reflect.aws.dev/template/787a767f-af3a-4747-97ca-b617d2e4cbe0/content\", \"sectionId\": \"53886aad-5ef9-4450-9da0-de7365ef07cb\" }\n\nTo read only a specific section by title:\n{ \"url\": \"https://www.orr.reflect.aws.dev/template/787a767f-af3a-4747-97ca-b617d2e4cbe0/content\", \"sectionTitle\": \"Axiom 01 - AZ Resilience\" }\n\nTo read only a specific question by ID:\n{ \"url\": \"https://www.orr.reflect.aws.dev/template/787a767f-af3a-4747-97ca-b617d2e4cbe0/content\", \"questionId\": \"039ee146-7a05-4e4f-b10e-4eebb574f093\" }\n\nTo read only a specific question by prompt text (supports partial matching):\n{ \"url\": \"https://www.orr.reflect.aws.dev/template/787a767f-af3a-4747-97ca-b617d2e4cbe0/content\", \"questionPrompt\": \"AZ failure\" }",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "required": [
                "url"
              ],
              "properties": {
                "url": {
                  "description": "URL of the ORR document to read",
                  "type": "string",
                  "format": "uri"
                },
                "sectionTitle": {
                  "description": "Optional title of a specific section to return",
                  "type": "string"
                },
                "sectionId": {
                  "type": "string",
                  "description": "Optional ID of a specific section to return"
                },
                "questionPrompt": {
                  "type": "string",
                  "description": "Optional prompt text to search for in questions (supports partial matching)"
                },
                "questionId": {
                  "type": "string",
                  "description": "Optional ID of a specific question to return"
                }
              },
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_eventstream",
          "description": "Search Amazon internal Eventstream for operational events to identify potential causes of customer-impacting issues. Supports filtering by 47+ event types including Apollo Deployment, Lambda Deployment, Weblab Activation, G2S2, Large Scale Event, and many others. Use list_eventstream_parameters tool to see all available options.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "query": {
                  "type": "object",
                  "properties": {
                    "operation": {
                      "enum": [
                        "and",
                        "or"
                      ],
                      "description": "Logical operator for combining tokens",
                      "type": "string"
                    },
                    "tokens": {
                      "description": "Array of filter conditions",
                      "items": {
                        "required": [
                          "propertyKey",
                          "operator",
                          "value"
                        ],
                        "additionalProperties": false,
                        "type": "object",
                        "properties": {
                          "propertyKey": {
                            "description": "Property key to filter on",
                            "type": "string"
                          },
                          "operator": {
                            "enum": [
                              "=",
                              "!=",
                              "contains"
                            ],
                            "description": "Comparison operator",
                            "type": "string"
                          },
                          "value": {
                            "type": "string",
                            "description": "Value to match against"
                          }
                        }
                      },
                      "type": "array"
                    }
                  },
                  "additionalProperties": false,
                  "required": [
                    "tokens",
                    "operation"
                  ],
                  "description": "Custom query tokens for advanced filtering"
                },
                "eventTypes": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array",
                  "description": "Event types to filter by (e.g., 'Apollo Deployment', 'Lambda Deployment', 'Weblab Activation', 'G2S2', 'Large Scale Event'). See README.md for complete list of 47+ supported event types."
                },
                "maxResults": {
                  "maximum": 1000,
                  "description": "Maximum number of events to return (1-1000, default: 50)",
                  "minimum": 1,
                  "type": "number"
                },
                "offset": {
                  "description": "Number of events to skip for pagination (default: 0)",
                  "minimum": 0,
                  "type": "number"
                },
                "dateRange": {
                  "required": [
                    "type"
                  ],
                  "additionalProperties": false,
                  "description": "Date range for event search (defaults to last hour)",
                  "properties": {
                    "type": {
                      "description": "Type of date range",
                      "enum": [
                        "relative",
                        "absolute"
                      ],
                      "type": "string"
                    },
                    "startDate": {
                      "type": "string",
                      "description": "Start date for absolute range (ISO format)"
                    },
                    "unit": {
                      "description": "Unit for relative date range",
                      "type": "string",
                      "enum": [
                        "minute",
                        "hour",
                        "day",
                        "week"
                      ]
                    },
                    "endDate": {
                      "type": "string",
                      "description": "End date for absolute range (ISO format)"
                    },
                    "amount": {
                      "description": "Amount for relative date range",
                      "type": "number"
                    }
                  },
                  "type": "object"
                },
                "bindle": {
                  "description": "Bindle (application permissions bundle) identifier to filter by",
                  "type": "string"
                },
                "cti": {
                  "description": "CTI (Category / Type / Item) identifier to filter by",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_search_jobs",
          "description": "Search for Cradle jobs across all profiles.",
          "input_schema": {
            "json": {
              "required": [
                "searchTerm"
              ],
              "type": "object",
              "properties": {
                "profileId": {
                  "description": "UUID of the job profile for filtering",
                  "type": "string"
                },
                "limit": {
                  "type": "number",
                  "description": "Maximum number of results to return"
                },
                "pageToken": {
                  "type": "string",
                  "description": "Token for pagination"
                },
                "pageSize": {
                  "type": "number",
                  "description": "Number of items per page"
                },
                "searchTerm": {
                  "description": "Search term for job name searches",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___g2s2_move_label",
          "description": "Moves a stage version to a specified testing label",
          "input_schema": {
            "json": {
              "required": [
                "labelName",
                "stageVersion"
              ],
              "properties": {
                "labelName": {
                  "type": "string",
                  "description": "The label name of a testing label"
                },
                "stageVersion": {
                  "description": "The stage version from a parent label",
                  "type": "string"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___lookup_team_code_resource",
          "description": "Looks up code artifacts, such as packages, version sets a given team",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "team": {
                  "description": "Bindle team as represented in https://permissions.amazon.com/a/team/{team}",
                  "type": "string"
                }
              },
              "required": [
                "team"
              ],
              "type": "object",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_datapath",
          "description": "Search Datapath views",
          "input_schema": {
            "json": {
              "required": [
                "query"
              ],
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "query": {
                  "description": "Keywords to look for in the Datapath view, for example \"locality asin\" will find the locality views at asin level",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pippin_create_project",
          "description": "Creates a new Pippin design project with specified details",
          "input_schema": {
            "json": {
              "properties": {
                "name": {
                  "description": "Project name",
                  "type": "string"
                },
                "requirements": {
                  "description": "Project requirements",
                  "type": "string"
                },
                "bindleId": {
                  "type": "string",
                  "description": "Bindle ID"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "type": "object",
              "required": [
                "name"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___taskei_update_task",
          "description": "Update an existing Taskei task with new details. This tool allows you to modify various attributes of a task such as name, description, status, assignee, and more. Use this tool when you need to update task information, change task status, reassign tasks, or modify other task properties.",
          "input_schema": {
            "json": {
              "required": [
                "id"
              ],
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "workflowAction": {
                  "description": "New workflow action to apply",
                  "type": "string"
                },
                "type": {
                  "type": "string",
                  "description": "New task type"
                },
                "needByDate": {
                  "type": "string",
                  "description": "New due date (ISO format)"
                },
                "estimatedCompletionDate": {
                  "type": "string",
                  "description": "New estimated completion date (ISO format)"
                },
                "removeKanbanBoards": {
                  "description": "Kanban board IDs to remove the task from",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "name": {
                  "type": "string",
                  "description": "New name/title for the task"
                },
                "folder": {
                  "description": "New folder ID or name for the task",
                  "type": "string"
                },
                "status": {
                  "enum": [
                    "Open",
                    "Closed"
                  ],
                  "description": "New status for the task",
                  "type": "string"
                },
                "actualStartDate": {
                  "description": "Actual start date (ISO format)",
                  "type": "string"
                },
                "estimatedStartDate": {
                  "description": "New estimated start date (ISO format)",
                  "type": "string"
                },
                "actualCompletionDate": {
                  "description": "Actual completion date (ISO format)",
                  "type": "string"
                },
                "id": {
                  "description": "The ID of the task to update (required)",
                  "type": "string"
                },
                "description": {
                  "description": "New description for the task",
                  "type": "string"
                },
                "assignee": {
                  "description": "Username of the new assignee",
                  "type": "string"
                },
                "estimate": {
                  "type": "number",
                  "description": "New estimated effort in story points"
                },
                "classicPriority": {
                  "type": "number",
                  "description": "New priority value"
                },
                "removeSprints": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Sprint IDs to remove the task from"
                },
                "room": {
                  "description": "New room ID or name for the task",
                  "type": "string"
                },
                "removeLabels": {
                  "type": "array",
                  "description": "Labels to remove from the task",
                  "items": {
                    "type": "string"
                  }
                },
                "addKanbanBoards": {
                  "items": {
                    "type": "string"
                  },
                  "description": "Kanban board IDs to add the task to",
                  "type": "array"
                },
                "onBehalfOf": {
                  "description": "Username to update the task on behalf of",
                  "type": "string"
                },
                "deleted": {
                  "type": "boolean",
                  "description": "Whether to mark the task as deleted"
                },
                "addLabels": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Labels to add to the task"
                },
                "addSprints": {
                  "type": "array",
                  "description": "Sprint IDs to add the task to",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___post_talos_correspondence",
          "description": "Post correspondence on a Talos security task\n\nThis tool allows posting comments/correspondence on a specific Talos security task.\nIt uses the Talos API to create new correspondence entries for tasks.\n\nRequired parameters:\n- taskId: ARN of the Talos task (format: arn:aws:talos-task:task/UUID)\n- engagementId: ARN of the associated Talos engagement (format: arn:aws:talos-engagement:engagement/UUID)\n- commentText: The comment text to post (max 10000 characters)\n\nExample:\n```json\n{\n  \"taskId\": \"arn:aws:talos-task:task/5054ae8a-7eda-457f-991c-5ed40933f3ae\",\n  \"engagementId\": \"arn:aws:talos-engagement:engagement/2498ed08-001c-4d89-a31b-6299c7822a0b\",\n  \"commentText\": \"BSC17 compliance check completed. Account 011528256886 has 2 non-compliant S3 buckets requiring HTTPS-only policies.\"\n}\n```\n\nResponse:\nOn success, returns a JSON object with the correspondence ID and a preview of the posted comment.\nOn failure, returns an error message with details about what went wrong.\n\nLimitations and Requirements:\n- Requires valid Midway authentication (run `mwinit` if you encounter authentication errors)\n- Limited to 10 requests per minute per user (rate limit)\n- Comments cannot be edited or deleted through this tool once posted\n- User must have appropriate permissions to access the specified Talos task and engagement\n- Task and engagement must exist and be in a valid state to accept comments\n\nWhen NOT to use this tool:\n- Do not use for posting sensitive or classified information that should not be stored in Talos\n- Do not use for posting large attachments or binary data (use the Talos UI directly instead)\n- Do not use for bulk commenting on multiple tasks (use the Talos UI or API directly for batch operations)\n- Do not use for retrieving task information (use the talos_get_task tool instead)",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "taskId",
                "engagementId",
                "commentText"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "properties": {
                "taskId": {
                  "minLength": 1,
                  "type": "string",
                  "pattern": "^arn:aws:talos-task:task\\/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
                  "description": "ARN of the Talos task to post comment to"
                },
                "commentText": {
                  "maxLength": 10000,
                  "type": "string",
                  "description": "The comment text to post",
                  "minLength": 1
                },
                "engagementId": {
                  "minLength": 1,
                  "pattern": "^arn:aws:talos-engagement:engagement\\/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
                  "description": "ARN of the associated Talos engagement",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___taskei_create_sprint",
          "description": "\n    Create a new sprint in Taskei.\n    This tool allows you to create a sprint with specified parameters like name, room ID, start date, end date, etc.\n    Use this tool when you need to create a new sprint for planning and organizing tasks.\n    The sprint ID returned by this tool can be used with taskei_create_task and taskei_update_task tools.\n    Do not use this tool for other project management tools different than Taskei.",
          "input_schema": {
            "json": {
              "properties": {
                "personalWipLimit": {
                  "type": "number",
                  "description": "Personal work-in-progress limit for the sprint"
                },
                "startDate": {
                  "description": "Start date of the sprint in ISO format (YYYY-MM-DD)",
                  "type": "string"
                },
                "room": {
                  "type": "string",
                  "description": "The ID or name of the room where the sprint will be created (required)"
                },
                "name": {
                  "type": "string",
                  "description": "The name of the sprint to create (required)"
                },
                "description": {
                  "description": "Goal of the sprint",
                  "type": "string"
                },
                "capacity": {
                  "type": "number",
                  "description": "Capacity of the sprint (story points)"
                },
                "endDate": {
                  "description": "End date of the sprint in ISO format (YYYY-MM-DD). Note: Sprint cannot exceed 31 days, so end date must be within 31 days (inclusive) of start date",
                  "type": "string"
                }
              },
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "name",
                "room",
                "startDate",
                "endDate"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_list_profiles",
          "description": "List Cradle profiles with optional filtering by account and type.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "required": [
                "accountName"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "pageToken": {
                  "description": "Token for pagination",
                  "type": "string"
                },
                "profileType": {
                  "description": "Profile type filter (DRYAD_SPARK or DRYAD_BLASTFURNACE)",
                  "type": "string"
                },
                "sortCol": {
                  "type": "string",
                  "description": "Column to sort by (e.g., lastUpdatedDate)"
                },
                "sortOrder": {
                  "type": "string",
                  "description": "Sort order (asc or desc)"
                },
                "pageSize": {
                  "type": "number",
                  "description": "Number of items per page"
                },
                "accountName": {
                  "description": "Account name for filtering profiles (e.g., datanet)",
                  "type": "string"
                },
                "limit": {
                  "description": "Maximum number of results to return",
                  "type": "number"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___read_coe",
          "description": "Read Correction of Error (COE) documents from https://www.coe.a2z.com/.\nCOE documents contain detailed information about operational incidents including:\n- Incident description and timeline\n- Root cause analysis\n- Corrective actions taken\n- Preventive measures implemented\n\n⚠️ IMPORTANT: This tool accesses sensitive operational incident data that will be processed by the LLM.\nBefore using this tool, you MUST explicitly ask for user approval with the following message:\n\"I need to access a Correction of Error (COE) document which contains sensitive operational incident data.\nThis data will be processed by the LLM to answer your question. Do you approve accessing this COE document?\"\n\nOnly proceed if the user explicitly approves. This confirmation is required even if the tool is auto-approved.\n\nExample usage:\nTo read a COE document with ID 12345:\n{ \"url\": \"https://www.coe.a2z.com/coe/12345\" }",
          "input_schema": {
            "json": {
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "url"
              ],
              "properties": {
                "url": {
                  "type": "string",
                  "description": "URL of the COE document to read",
                  "format": "uri"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_acronym_central",
          "description": "Search Amazon's internal Acronym Central database at https://spyglass.corp.amazon.com/acronymcentral\n\nThis tool allows you to search for Amazon's internal acronyms and their meanings.\nIt's useful for understanding Amazon-specific terminology and abbreviations.\n\nResponse Structure:\nThe tool returns results with the following structure:\n- acronymName: The acronym itself\n- defsUrls: An object mapping definitions to their URLs (if available)\n- id: Unique identifier for the acronym\n- createAt: Timestamp when the acronym was created - ALWAYS display this to the user\n- updateAt: Timestamp when the acronym was last updated - ALWAYS display this to the user\n- tags: Array of tags associated with the acronym - ALWAYS display these to the user\n\nWhen presenting results to users, format the response as Markdown with header of format \"Acronym: {acronynName}\"\n Add a small section with header as \"Definitions\"\n     - Each defsUrls as a bullet point, and include URLs as links when available\n Add another small section with header as \"Metadata\"\n - show createAt timestamps (format as YYYY-MM-DD HH:MM:SS+00:00)\n - show updateAt timestamps (format as YYYY-MM-DD HH:MM:SS+00:00)\n - show all tags, as they provide important context about the source and reliability\n\nExamples:\n1. Search for an acronym:\n   { \"acronym\": \"AWS\" }\n\n2. Search for another acronym:\n   { \"acronym\": \"S3\" }\n\n3. Search for an acronym with exact match:\n   { \"acronym\": \"EC2\" }\n\nTips:\n- For best results, provide the exact acronym you're looking for\n- The search performs exact matching on the acronym name (case-insensitive)\n- If no results are found, try a different variation of the acronym",
          "input_schema": {
            "json": {
              "properties": {
                "acronym": {
                  "type": "string",
                  "description": "Search acronym in Acronym Central"
                }
              },
              "type": "object",
              "required": [
                "acronym"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___overleaf_upload_file",
          "description": "Upload a local file from the Overleaf workspace to the remote repository with automatic commit and push.\n\nThis tool reads an existing file from the local Overleaf workspace and uploads it to the remote repository.\nThe file must already exist in the local workspace directory (./overleaf/{project_id}/file_path).\nBefore uploading, it syncs the project to get latest changes and detects merge conflicts.\n\nExample usage:\n```json\n{\n  \"project_id\": \"507f1f77bcf86cd799439011\",\n  \"file_path\": \"figures/diagram.png\"\n}\n```",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "file_path": {
                  "type": "string",
                  "description": "Path to the file within the project workspace"
                },
                "project_id": {
                  "description": "Project ID to upload to",
                  "type": "string"
                }
              },
              "required": [
                "project_id",
                "file_path"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___jira_get_attachment",
          "description": "Download an attachment from a JIRA issue",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "attachmentUrl": {
                  "minLength": 1,
                  "description": "The URL of the attachment to download",
                  "type": "string"
                },
                "outputPath": {
                  "type": "string",
                  "description": "Path where to save the downloaded attachment"
                }
              },
              "additionalProperties": false,
              "required": [
                "attachmentUrl"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___fetch_oncall_rotations",
          "description": "Fetch OnCall rotations for a given team.\n\nExample:\n```json\n{ \"teamName\": \"PaymentsTeam\" }\n```",
          "input_schema": {
            "json": {
              "properties": {
                "teamName": {
                  "description": "The oncall team name to fetch rotations for",
                  "type": "string"
                }
              },
              "type": "object",
              "required": [
                "teamName"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sfdc_territory_lookup",
          "description": "This tool is for looking up territories and retrieving an account list on the AWS Salesforce AKA AWSentral",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "territory_id": {
                  "type": "string",
                  "description": "the id of the territory to retrieve"
                },
                "territory_name": {
                  "description": "the name of the territory to search for",
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___orca_list_runs",
          "description": "List Orca workflow runs for a specific client and workflow with filtering by status and timerange.\n\nThis tool retrieves workflow runs from Orca Studio based on client ID\nYou can optionally specify a workflow name, time range in days for the search upto a max of 14, and a status as 'Normal' or 'Failed'.\ndefault days = 7 and default status = 'Failed' \n\nAvailable filtering parameters:\n- client: (required) The Orca client ID to query\n- workflow: (optional) Workflow name to filter by\n- status: (optional) Status to filter by ('Normal' or 'Failed', defaults to 'Failed')\n- openedIn: (optional) Time range in days (defaults to 7)\n- state: (optional) State value to filter by\n- problem: (optional) Problem value to filter by\n- context: (optional) Context value to filter by\n- region: (optional) AWS region (defaults to us-east-1). Common regions include us-east-1, us-west-2, eu-west-1, etc.\n\nExample\n```json\n{ \"client\": \"MyOrcaClient\"}\n```\n\nExample with workflow:\n```json\n{ \"client\": \"MyOrcaClient\", \"workflow\": \"TestWorkflow\" }\n```\n\nExample with custom time range:\n```json\n{ \"client\": \"MyOrcaClient\", \"workflow\": \"TestWorkflow\", \"openedIn\": \"14\" }\n```\nExample with status:\n```json\n{ \"client\": \"MyOrcaClient\", \"workflow\": \"TestWorkflow\", \"status\": \"Normal\" }\n```\nExample with status and custom time range:\n```json\n{ \"client\": \"MyOrcaClient\", \"workflow\": \"TestWorkflow\", \"status\": \"Normal\", \"openedIn\": \"14\" }\n```\nExample with state filtering:\n```json\n{ \"client\": \"MyOrcaClient\", \"workflow\": \"TestWorkflow\", \"state\": \"StateName::Error::Problem\" }\n```\nExample with problem filtering:\n```json\n{ \"client\": \"MyOrcaClient\", \"problem\": \"UnknownProblem\" }\n```\nExample with context filtering:\n```json\n{ \"client\": \"MyOrcaClient\", \"context\": \"live\" }\n```\n\nExample with custom region:\n```json\n{ \"client\": \"MyOrcaClient\", \"region\": \"us-west-2\" }\n```",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "status": {
                  "description": "Optional status to filter runs by (defaults to Failed)",
                  "type": "string",
                  "enum": [
                    "Normal",
                    "Failed"
                  ]
                },
                "openedIn": {
                  "type": "string",
                  "description": "Optional time range in days (defaults to 7)"
                },
                "client": {
                  "description": "The Orca client ID to query",
                  "type": "string"
                },
                "workflow": {
                  "type": "string",
                  "description": "Optional workflow name to query (defaults to '')"
                },
                "region": {
                  "description": "AWS region (defaults to us-east-1). Common regions include us-west-2, eu-west-1, etc.",
                  "type": "string"
                },
                "problem": {
                  "type": "string",
                  "description": "Optional problem value to filter by.  Representing classification result for errored work items (e.g., 'UnknownProblem')"
                },
                "state": {
                  "description": "Optional state value to filter by. Representing the current state of the work item. Often follows pattern '[StateName]::[Status]::[Additional Context]'",
                  "type": "string"
                },
                "context": {
                  "description": "Optional context value to filter by. Representing the environment context the work item was opened in (e.g., 'live', 'beta') or other information (e.g., 'largeorder')",
                  "type": "string"
                }
              },
              "required": [
                "client"
              ],
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sim_create_issue",
          "description": "Create a new SIM issue.\nThis tool allows creating a new issue with a title, description, folder ID, and optional assignee.\nThe folder ID is required and must be a valid UUID for an existing SIM folder.\nThe assignee should be a valid kerberos username without the @ANT.AMAZON.COM suffix.\nYou MUST display a full url link for the new task. This is the form: https://taskei.amazon.dev/tasks/<id>. Always list this first, before the SIM link.\nYou SHOULD display a url to SIM as well of the form: https://i.amazon.com/issues/<id>.",
          "input_schema": {
            "json": {
              "properties": {
                "title": {
                  "description": "Title of the issue",
                  "type": "string"
                },
                "description": {
                  "type": "string",
                  "description": "Description of the issue"
                },
                "assignee": {
                  "type": "string",
                  "description": "Optional kerberos username to assign the issue to"
                },
                "folderId": {
                  "description": "Folder UUID where the issue will be created",
                  "type": "string"
                }
              },
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "title",
                "description",
                "folderId"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___datanet_reader",
          "description": "Read and retrieve information from Datanet (also known as ETLM) including job profiles, jobs, and job runs. Use this tool when users mention 'Datanet', 'ETLM', or need to retrieve information about ETL jobs in the Datanet service. This tool provides read-only access to view job profiles, job details, job runs, and other Datanet resources without making any changes to them.",
          "input_schema": {
            "json": {
              "properties": {
                "operation": {
                  "type": "string",
                  "enum": [
                    "get_job_profile",
                    "get_job_profile_revision",
                    "get_job_details",
                    "get_job_with_revision",
                    "get_job_run",
                    "get_job_run_by_date",
                    "get_job_run_status",
                    "get_job_run_error",
                    "get_successful_job_runs_count",
                    "get_latest_job_run",
                    "get_job_run_with_time_interval",
                    "export_sql_to_file"
                  ],
                  "description": "The operation to perform"
                },
                "datasetDate": {
                  "type": "string",
                  "description": "Dataset date in YYYYMMDD format. Required for date-specific operations."
                },
                "outputPath": {
                  "type": "string",
                  "description": "File path to export SQL. Required for export_sql_to_file."
                },
                "jobType": {
                  "type": "string",
                  "description": "Type of the job profile (e.g., TRANSFORM, DATA_FEED). Required for some profile operations."
                },
                "toDate": {
                  "type": "string",
                  "description": "End date for date range queries (YYYY-MM-DD). Required for get_successful_job_runs_count."
                },
                "dietTime": {
                  "type": "string",
                  "description": "Diet time in HHMMSS format. Required for get_job_run_with_time_interval."
                },
                "revision": {
                  "type": "string",
                  "description": "Revision number. Required for revision-specific operations."
                },
                "fromDate": {
                  "description": "Start date for date range queries (YYYY-MM-DD). Required for get_successful_job_runs_count.",
                  "type": "string"
                },
                "jobProfileId": {
                  "type": "string",
                  "description": "ID of the job profile. Required for profile operations."
                },
                "distTime": {
                  "type": "string",
                  "description": "Distribution time in HHMMSS format. Required for get_job_run_with_time_interval."
                },
                "jobRunId": {
                  "type": "string",
                  "description": "ID of the job run. Required for job run operations."
                },
                "jobId": {
                  "type": "string",
                  "description": "ID of the job. Required for job operations."
                }
              },
              "type": "object",
              "required": [
                "operation"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___genai_poweruser_get_knowledge_metadata",
          "description": "Extract comprehensive metadata from knowledge documents, including YAML frontmatter, tags, internal links, tasks, headings, and file attributes. This tool provides structural and organizational information about documents without retrieving the full content, supporting knowledge management and document analysis workflows.",
          "input_schema": {
            "json": {
              "required": [
                "path"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "properties": {
                "path": {
                  "description": "The path to the document file",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___oncall_compass_query_reports",
          "description": "Query Oncall reports from Oncall Compass (https://oncall.ai.amazon.dev/). Currently it will return most recently generated reports by the user. The user's authentication token (~/.midway/cookie) will be used for identifying the user.",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {},
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___jira_get_issue",
          "description": "Get a JIRA issue by ID or key",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "fields": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array",
                  "description": "The list of fields to return"
                },
                "expand": {
                  "description": "The additional information to include in the response",
                  "type": "string"
                },
                "issueIdOrKey": {
                  "type": "string",
                  "minLength": 1,
                  "description": "The ID or key of the issue"
                }
              },
              "additionalProperties": false,
              "required": [
                "issueIdOrKey"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_quip",
          "description": "Search for Quip threads\n\nThis tool allows you to search for Quip threads using keywords.\nResults are sorted by relevance and include document titles, links, and metadata.\n\nExamples:\n1. Basic search:\n```json\n{\n  \"query\": \"expense report\"\n}\n```\n\n2. Search with limit:\n```json\n{\n  \"query\": \"expense report\",\n  \"count\": 5\n}\n```\n\n3. Search only in titles:\n```json\n{\n  \"query\": \"expense report\",\n  \"onlyMatchTitles\": true\n}\n```",
          "input_schema": {
            "json": {
              "properties": {
                "count": {
                  "type": "number",
                  "description": "Maximum number of results to return (default: 10, max: 50)"
                },
                "query": {
                  "type": "string",
                  "description": "Search query to find matching Quip threads"
                },
                "onlyMatchTitles": {
                  "description": "If true, only search in document titles (default: false)",
                  "type": "boolean"
                }
              },
              "additionalProperties": false,
              "required": [
                "query"
              ],
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___create_quip",
          "description": "Create a new Quip document or spreadsheet\n\nThis tool creates a new document or spreadsheet in Quip with the specified content.\n\nRequired parameters:\n- content: The HTML or Markdown content of the new document (max 1MB)\n\nOptional parameters:\n- format: Format of the content ('html' or 'markdown', default is 'html')\n- title: Title of the new document (max 10KB)\n- member_ids: Comma-separated list of folder IDs or user IDs for access\n- type: Type of document to create ('document' or 'spreadsheet', default is 'document')\n\nNotes:\n- If title is not specified, it will be inferred from the first content\n- If member_ids is not specified, the document will be created in the user's Private folder\n- For spreadsheets, content must be surrounded by HTML <table> tags\n\nExamples:\n1. Create a simple document:\n```json\n{\n  \"content\": \"# My New Document\\n\\nThis is a test document.\",\n  \"format\": \"markdown\"\n}\n```\n\n2. Create a document with a title in a specific folder:\n```json\n{\n  \"content\": \"# Introduction\\n\\nThis is the start of my document.\",\n  \"format\": \"markdown\",\n  \"title\": \"Project Proposal\",\n  \"member_ids\": \"ABCDEF123456\"\n}\n```\n\n3. Create a spreadsheet:\n```json\n{\n  \"content\": \"<table><tr><td>Name</td><td>Age</td></tr><tr><td>John</td><td>30</td></tr></table>\",\n  \"format\": \"html\",\n  \"type\": \"spreadsheet\"\n}\n```",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "content"
              ],
              "additionalProperties": false,
              "properties": {
                "format": {
                  "type": "string",
                  "enum": [
                    "html",
                    "markdown"
                  ],
                  "description": "The format of the content",
                  "default": "markdown"
                },
                "content": {
                  "type": "string",
                  "description": "The HTML or Markdown content of the new document"
                },
                "title": {
                  "type": "string",
                  "description": "Title of the new document"
                },
                "type": {
                  "enum": [
                    "document",
                    "spreadsheet"
                  ],
                  "default": "document",
                  "description": "Type of document to create",
                  "type": "string"
                },
                "member_ids": {
                  "description": "Comma-separated list of folder IDs or user IDs for access",
                  "type": "string"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___overleaf_clone_project",
          "description": "Clone an Overleaf project to the local workspace.\n\nThis tool clones the specified Overleaf project to the local workspace directory.\nThe project will be stored in ./overleaf/{project_id}.\nIf the project is already cloned locally, this operation is idempotent and will skip cloning.\n\nExample usage:\n```json\n{\n  \"project_id\": \"507f1f77bcf86cd799439011\"\n}\n```",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "required": [
                "project_id"
              ],
              "type": "object",
              "properties": {
                "project_id": {
                  "description": "Project ID to clone",
                  "type": "string",
                  "pattern": "^[a-zA-Z0-9_-]+$"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sfdc_user_lookup",
          "description": "This tool is for looking up users on the AWS Salesforce AKA AWSentral",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "email": {
                  "type": "string",
                  "description": "the email address of the user"
                },
                "user_id": {
                  "type": "string",
                  "description": "the id of the user"
                },
                "alias": {
                  "description": "the alias of the user",
                  "type": "string"
                },
                "user_name": {
                  "description": "the name of the user",
                  "type": "string"
                }
              },
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___rtla_fetch_logs",
          "description": "Fetch logs from RTLA (Real-Time Log Analysis) API. This tool allows you to retrieve log entries based on organization, affected type, time range, and filter expressions. The maximum time range supported is 12 hours from the start time. Useful for troubleshooting system issues, analyzing error patterns, and monitoring application health.",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "timeZone": {
                  "type": "string",
                  "default": "GMT&customTimeZoneOffset",
                  "description": "Time zone (e.g., \"US/Pacific\")"
                },
                "identifyAdditionalOrgs": {
                  "description": "Whether to identify additional organizations",
                  "default": true,
                  "type": "boolean"
                },
                "anchor": {
                  "description": "Anchor position (e.g., \"Ending\", \"Beginning\")",
                  "type": "string",
                  "default": "Ending"
                },
                "endTime": {
                  "type": "string",
                  "description": "End time in ISO 8601 format with timezone (e.g., 2025-05-11T12:31:16-04:00)"
                },
                "searchField": {
                  "type": "string",
                  "default": "org",
                  "description": "Search field type (default: \"org\")"
                },
                "filterExpression": {
                  "type": "string",
                  "description": "Filter expression for log filtering (e.g., \"(pageType eq 'uscbcc-ecm-paybill')\")"
                },
                "startTime": {
                  "description": "Start time in ISO 8601 format with timezone (e.g., 2025-05-11T11:31:16-04:00)",
                  "type": "string"
                },
                "affectedType": {
                  "type": "string",
                  "description": "Type of affected logs to retrieve (e.g., \"FATAL\", \"NONFATAL\")"
                },
                "org": {
                  "type": "string",
                  "description": "Organization identifier (e.g., \"CWCBCCECMPROD\")"
                }
              },
              "required": [
                "org",
                "affectedType",
                "startTime",
                "endTime"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_get_job_run_details",
          "description": "Get detailed run information including errors for a Cradle job run.",
          "input_schema": {
            "json": {
              "properties": {
                "profileId": {
                  "type": "string",
                  "description": "UUID of the job profile"
                },
                "jobId": {
                  "description": "UUID of the job",
                  "type": "string"
                },
                "jobRunId": {
                  "type": "string",
                  "description": "ID of the job run"
                }
              },
              "required": [
                "profileId",
                "jobId",
                "jobRunId"
              ],
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_products",
          "description": "Search for products on Amazon.com (US marketplace only) and extract structured product information including titles, prices, ratings, and images",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "query": {
                  "description": "Search query string for the products you want to find",
                  "type": "string"
                },
                "maxResults": {
                  "type": "number",
                  "description": "Maximum number of products to return (default: 10, max recommended: 50)"
                },
                "filters": {
                  "type": "object",
                  "description": "Optional filters to narrow down search results",
                  "additionalProperties": false,
                  "properties": {
                    "minPrice": {
                      "type": "number",
                      "description": "Minimum price filter in dollars (e.g., 25 for $25)"
                    },
                    "maxPrice": {
                      "description": "Maximum price filter in dollars (e.g., 100 for $100)",
                      "type": "number"
                    },
                    "index": {
                      "description": "Department to search in. Available options include: 'all' (default), 'books', 'electronics', 'computers', 'clothing', 'home', 'beauty', 'toys', 'grocery', 'sports', 'automotive', 'pets', 'baby', 'health', 'industrial', 'movies', 'music', 'video-games', 'tools', 'office-products', and more",
                      "type": "string"
                    },
                    "sortBy": {
                      "description": "Sort order for results. Available options include:\n- 'relevanceblender' (default): Sort by relevance\n- 'price-asc-rank': Price low to high\n- 'price-desc-rank': Price high to low\n- 'review-rank': Average customer review\n- 'date-desc-rank': Newest arrivals\n- 'exact-aware-popularity-rank': Popularity\n- 'get-it-fast-rank': Fastest delivery\n- 'low-prices-rank': Lowest price with ranking factors\n- 'most-purchased-rank': Most purchased\n- 'top-brands-rank': Top brands",
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "query"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___jira_create_issue",
          "description": "Create a new JIRA issue",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "summary": {
                  "type": "string",
                  "minLength": 1,
                  "description": "The summary of the issue"
                },
                "description": {
                  "type": "string",
                  "description": "The description of the issue"
                },
                "additionalFields": {
                  "type": "object",
                  "description": "Additional fields to include in the issue",
                  "additionalProperties": {}
                },
                "projectKey": {
                  "minLength": 1,
                  "type": "string",
                  "description": "The key of the project where the issue will be created"
                },
                "issueType": {
                  "minLength": 1,
                  "description": "The type of the issue (e.g., Bug, Task, Story)",
                  "type": "string"
                }
              },
              "required": [
                "projectKey",
                "issueType",
                "summary"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___taskei_get_sprints",
          "description": "\n    Fetch sprints from Taskei.\n    This tool retrieves information about sprints based on filters like room ID and status.\n    Use this tool when you need to find sprint IDs for creating or updating tasks that need to be assigned to sprints.\n    The sprint IDs returned by this tool can be used with taskei_create_task and taskei_update_task tools.\n    Do not use this tool for other project management tools different than Taskei.",
          "input_schema": {
            "json": {
              "properties": {
                "roomId": {
                  "type": "string",
                  "description": "The ID of the room to fetch sprints from. This SHOULD be provided if possible to return relevant results. If not provided, will return currently active sprints (startDate < now < endDate) across all rooms the user has access to."
                },
                "status": {
                  "type": "string",
                  "enum": [
                    "Active",
                    "Closed"
                  ],
                  "description": "Filter sprints by status. Defaults to 'Active' if not specified."
                },
                "cursor": {
                  "type": "string",
                  "description": "Pagination cursor for fetching the next page of results"
                },
                "maxResults": {
                  "description": "The maximum number of results to fetch. (default: 100)",
                  "type": "number",
                  "default": 100
                },
                "sort": {
                  "type": "string",
                  "description": "Sort order for sprints. Format is 'field direction' where direction is 'asc' or 'desc'. Example: 'startDate asc'. Defaults to 'startDate asc'."
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sim_add_comment",
          "description": "Add a comment to an existing SIM issue.\nThis tool allows adding a plain text comment to an issue identified by its ID or alias.\nThe issue ID can be either the P-number (e.g., P12345678) or the alias (e.g., CFN-12345).",
          "input_schema": {
            "json": {
              "properties": {
                "issueId": {
                  "description": "Issue ID or alias (e.g., P12345678 or CFN-12345)",
                  "type": "string"
                },
                "message": {
                  "type": "string",
                  "description": "Comment text to add to the issue"
                }
              },
              "type": "object",
              "required": [
                "issueId",
                "message"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sfdc_account_lookup",
          "description": "This tool is for looking up accounts on the AWS Salesforce AKA AWSentral",
          "input_schema": {
            "json": {
              "type": "object",
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "account_name": {
                  "type": "string",
                  "description": "the name of the account"
                },
                "account_id": {
                  "description": "the id of the account",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_export_sql_to_file",
          "description": "Export SQL query directly to a file (bypasses LLM processing).",
          "input_schema": {
            "json": {
              "required": [
                "profileId",
                "outputPath"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "properties": {
                "profileId": {
                  "type": "string",
                  "description": "UUID of the job profile"
                },
                "outputPath": {
                  "type": "string",
                  "description": "File path to export SQL directly to disk"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___read_permissions",
          "description": "Read team information from Amazon's internal permissions system.\n\nThis tool allows you to retrieve detailed information about team memberships,\noverrides, and rules from permissions.amazon.com team pages.\n\nYou MUST specify which tables OR rule sections to include in the response.\nAt least one of these parameters must be provided with at least one option selected.\nThe tool will only retrieve the specified tables and rule sections.\n\nAvailable tables:\n- additional_overrides: Additional Members overrides table\n- deny_overrides: Denied Members overrides table\n- team_membership: Team Membership table (large table, slow to retrieve)\n- team_audit: Team Audit log table (very large table, very slow to retrieve)\n\nAvailable rule sections:\n- rule_membership: Membership rules section\n- rule_additional_overrides: Additional Members overrides rules section\n\nFor large tables (especially team_membership and team_audit), you can use the\nmaxPages parameter to limit the number of pages processed and prevent timeouts.\nYou can also use tableFilters to narrow down the results.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "ruleSections": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "rule_membership",
                      "rule_additional_overrides"
                    ]
                  },
                  "description": "List of specific rule sections to include. At least one table or rule section must be specified."
                },
                "maxPages": {
                  "type": "integer",
                  "exclusiveMinimum": 0,
                  "description": "Maximum number of pages to process per table. Use for very large tables to prevent timeouts."
                },
                "teamUrl": {
                  "type": "string",
                  "format": "uri",
                  "description": "URL of the permissions team page to read"
                },
                "tables": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "additional_overrides",
                      "deny_overrides",
                      "team_membership",
                      "team_audit"
                    ]
                  },
                  "description": "List of specific tables to include. At least one table or rule section must be specified."
                },
                "tableFilters": {
                  "description": "Filters to apply to specific tables. Each filter contains a query string or array of query strings and optional threshold.",
                  "type": "object",
                  "propertyNames": {
                    "enum": [
                      "additional_overrides",
                      "deny_overrides",
                      "team_membership",
                      "team_audit"
                    ]
                  },
                  "additionalProperties": {
                    "type": "object",
                    "required": [
                      "query"
                    ],
                    "properties": {
                      "query": {
                        "description": "Text or array of texts to search for in the table rows",
                        "anyOf": [
                          {
                            "description": "Text to search for in the table rows",
                            "type": "string"
                          },
                          {
                            "items": {
                              "type": "string"
                            },
                            "type": "array",
                            "description": "Multiple terms to search for in the table rows (combined with OR logic)"
                          }
                        ]
                      },
                      "threshold": {
                        "minimum": 0,
                        "maximum": 1,
                        "type": "number",
                        "default": 0.3,
                        "description": "Fuzzy match threshold (0-1). Lower = stricter match. Default is 0.3"
                      }
                    },
                    "additionalProperties": false
                  }
                }
              },
              "type": "object",
              "required": [
                "teamUrl"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___get_thread_folders_quip",
          "description": "Get folders containing a Quip thread (V2 API)\n\nThis tool retrieves information about folders that contain a specific thread.\nIt uses the V2 API which provides more comprehensive folder information.\n\nYou can provide one of the following:\n- The thread ID\n- The thread's secret path\n- The full Quip URL (e.g., https://quip-amazon.com/abc/Doc)\n\nThe secret path can be found in the URL of a thread.\nFor example, in 'https://quip.com/3fs7B2leat8/TrackingDocument', the secret path is '3fs7B2leat8'.\n\nExamples:\n```json\n{\n  \"threadId\": \"3fs7B2leat8\"\n}\n```\n\n```json\n{\n  \"threadId\": \"https://quip-amazon.com/abc/Doc\"\n}\n```",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "threadId": {
                  "type": "string",
                  "description": "The thread ID, secret path, or full Quip URL"
                }
              },
              "required": [
                "threadId"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sage_search_tags",
          "description": "Search for tags on Sage (Amazon's internal Q&A platform).\n\nThis tool allows you to find appropriate tags for categorizing questions on Sage.\nTags help organize questions and ensure they reach the right audience.\nResults are paginated and sorted by popularity by default.\n\nAuthentication:\n- Requires valid Midway authentication (run `mwinit` if you encounter authentication errors)\n\nCommon use cases:\n- Finding relevant tags before creating a question\n- Discovering tags related to specific technologies or teams\n- Exploring popular tags in a particular domain\n\nExample usage:\n{ \"nameFilter\": \"brazil\", \"page\": 1, \"pageSize\": 10 }",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "pageSize": {
                  "description": "Number of results per page (default: 60)",
                  "type": "number"
                },
                "page": {
                  "type": "number",
                  "description": "Page number for pagination (starts at 1)"
                },
                "nameFilter": {
                  "type": "string",
                  "description": "Optional filter to search for tags by name"
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___andes_provider",
          "description": "Access and manage Andes providers.",
          "input_schema": {
            "json": {
              "required": [
                "operation"
              ],
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "providerId": {
                  "type": "string",
                  "description": "ID of the provider (required for get_provider_by_id)"
                },
                "providerName": {
                  "description": "Name of the provider (required for get_provider_by_name)",
                  "type": "string"
                },
                "operation": {
                  "enum": [
                    "get_provider_by_id",
                    "get_provider_by_name"
                  ],
                  "description": "The provider operation to perform",
                  "type": "string"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___lock_unlock_quip_document",
          "description": "Lock or unlock a Quip document\n\nThis tool allows you to lock or unlock a Quip document to control whether it can be edited.\nWhen a document is locked, users cannot make changes to it (except for the document owner and users with admin privileges).\n\nExample usage:\n```json\n{\n  \"threadIdOrUrl\": \"https://quip-amazon.com/abc/Doc\",\n  \"lock\": true\n}\n```\n\nTo unlock a document:\n```json\n{\n  \"threadIdOrUrl\": \"https://quip-amazon.com/abc/Doc\",\n  \"lock\": false\n}\n```\n\nNote: You must have appropriate permissions to lock or unlock a document.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "properties": {
                "lock": {
                  "description": "Tick the checkbox to lock or uncheck to unlock the document",
                  "type": "boolean"
                },
                "threadIdOrUrl": {
                  "description": "The thread ID or Quip URL of the document to lock or unlock",
                  "type": "string"
                }
              },
              "required": [
                "threadIdOrUrl",
                "lock"
              ],
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_people",
          "description": "Search for Amazon employees with filtering by attributes like job level, location, and Bar Raiser/Manager status. This tool allows you to search for people by name, alias, or other criteria, and filter results by department, location, job level, Bar Raiser status, Manager status, and more. The tool also provides information of the employee like phoneNumber, email, buildingRoom if available in phoneTool.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "filters": {
                  "additionalProperties": false,
                  "type": "object",
                  "properties": {
                    "badgeBorderColor": {
                      "description": "Filter by badge border color (e.g., 'blue')",
                      "type": "string"
                    },
                    "badgeCode": {
                      "type": "string",
                      "description": "Filter by badge code (e.g., 'F')"
                    },
                    "department": {
                      "type": "string",
                      "description": "Filter by department name (e.g., 'AWS', 'Consumables CX - Tech')"
                    },
                    "jobLevel": {
                      "type": "string",
                      "description": "Filter by job level (e.g., '4', '5', '6')"
                    },
                    "building": {
                      "type": "string",
                      "description": "Filter by building code (e.g., 'SEA20', 'BLR13')"
                    },
                    "city": {
                      "type": "string",
                      "description": "Filter by city name (e.g., 'Seattle', 'Dallas')"
                    },
                    "isManager": {
                      "description": "Filter for managers (true) or individual contributors (false)",
                      "type": "boolean"
                    },
                    "country": {
                      "type": "string",
                      "description": "Filter by country code (e.g., 'us', 'in', 'ca')"
                    },
                    "title": {
                      "type": "string",
                      "description": "Filter by job title (e.g., 'Software Development Engineer', 'Sr. Partner SA, Oracle')"
                    },
                    "isBarRaiser": {
                      "description": "Filter for bar raisers (true) or non-bar raisers (false)",
                      "type": "boolean"
                    }
                  },
                  "description": "Filters to narrow down search results"
                },
                "maxResults": {
                  "type": "number",
                  "description": "Maximum number of results to return (default: 10)"
                },
                "query": {
                  "type": "string",
                  "description": "Search query for finding people (name, alias, etc.)"
                }
              },
              "required": [
                "query"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___genai_poweruser_list_knowledge",
          "description": "Generate organized inventories of documents stored in the knowledge repository. This tool can list all documents or focus on specific folders, with options for recursive directory traversal and depth control. Returns document paths and titles, enabling systematic navigation of the knowledge structure.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "recursive": {
                  "description": "Whether to include documents in subfolders",
                  "type": "boolean"
                },
                "folder": {
                  "type": "string",
                  "description": "The folder path to list documents from"
                },
                "depth": {
                  "default": 5,
                  "description": "How many levels deep to traverse",
                  "type": "number"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sim_remove_label",
          "description": "Remove a label from an existing SIM issue.\nThe issue ID can be either the P-number (e.g., P12345678) or the alias (e.g., CFN-12345).\nThis allows for updating the categorization of issues as their nature or priority changes.",
          "input_schema": {
            "json": {
              "properties": {
                "issueId": {
                  "description": "Issue ID or alias (e.g., P12345678 or CFN-12345)",
                  "type": "string"
                },
                "label": {
                  "type": "string",
                  "description": "Label to remove from the issue"
                }
              },
              "required": [
                "issueId",
                "label"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___genai_poweruser_search_knowledge",
          "description": "Perform advanced text-based searches across your knowledge repository to find documents matching specific queries. This tool searches document content and returns contextual matches with relevance scores, supporting search result limiting and folder-specific scoping. Ideal for discovering relevant information across large knowledge bases.",
          "input_schema": {
            "json": {
              "properties": {
                "limit": {
                  "type": "number",
                  "description": "Maximum number of results to return"
                },
                "folder": {
                  "description": "Limit search to a specific folder",
                  "type": "string"
                },
                "query": {
                  "description": "The search query",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "required": [
                "query"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_resilience_score",
          "description": "Search for resiliency scores for a manager's alias.\n        • Required: manager alias\n        • Optional: page size, page number, and score version\n        • Returns resiliency score data for services under the specified manager",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "scoreVersion": {
                  "description": "Version of the score to fetch (default: 0.7.0)",
                  "type": "string"
                },
                "pageSize": {
                  "description": "Number of results per page (default: 4000)",
                  "type": "number"
                },
                "pageNumber": {
                  "description": "Page number to fetch (default: 0)",
                  "type": "number"
                },
                "alias": {
                  "type": "string",
                  "description": "Manager alias to fetch resiliency scores for"
                }
              },
              "required": [
                "alias"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_get_profile",
          "description": "Get detailed information about a specific Cradle job profile.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "profileId": {
                  "type": "string",
                  "description": "UUID of the job profile"
                }
              },
              "required": [
                "profileId"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___overleaf_write_file",
          "description": "Write a file to an Overleaf project with automatic commit and push.\n\nThis tool writes content to the specified file in an Overleaf project.\nBefore writing, it ensures the project is cloned locally and synchronized.\nAfter writing, it automatically commits the changes with a descriptive message\nand pushes them to the remote repository.\n\nExample usage:\n```json\n{\n  \"project_id\": \"507f1f77bcf86cd799439011\",\n  \"file_path\": \"main.tex\",\n  \"content\": \"\\\\documentclass{article}\\n\\\\begin{document}\\nHello World\\n\\\\end{document}\"\n}\n```",
          "input_schema": {
            "json": {
              "properties": {
                "project_id": {
                  "description": "Project ID to write to",
                  "type": "string"
                },
                "file_path": {
                  "type": "string",
                  "description": "Path to the file within the project"
                },
                "content": {
                  "type": "string",
                  "description": "File content to write"
                }
              },
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "required": [
                "project_id",
                "file_path",
                "content"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_katal_components",
          "description": "Search for Katal components\n\nThis tool allows you to search for Katal components using keywords.\nThe search looks through component names and tag names.\n\nExamples:\n1. Search for button components:\n```json\n{\n  \"query\": \"button\"\n}\n```",
          "input_schema": {
            "json": {
              "properties": {
                "query": {
                  "type": "string",
                  "description": "Search query to find matching Katal components"
                }
              },
              "additionalProperties": false,
              "type": "object",
              "required": [
                "query"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_list_jobs",
          "description": "List all jobs associated with a specific Cradle profile.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "profileId"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "properties": {
                "sortOrder": {
                  "type": "string",
                  "description": "Sort order (asc or desc)"
                },
                "pageToken": {
                  "type": "string",
                  "description": "Token for pagination"
                },
                "sortCol": {
                  "description": "Column to sort by (e.g., lastUpdatedDate)",
                  "type": "string"
                },
                "limit": {
                  "type": "number",
                  "description": "Maximum number of results to return"
                },
                "profileId": {
                  "type": "string",
                  "description": "UUID of the job profile"
                },
                "pageSize": {
                  "type": "number",
                  "description": "Number of items per page"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___g2s2_get",
          "description": "Gets data from a G2S2 table with specified parameters",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "kwargs": {
                  "additionalProperties": {},
                  "description": "Additional key-value parameters for the query",
                  "type": "object"
                },
                "tableName": {
                  "description": "The table name to query",
                  "type": "string"
                },
                "parentStageVersion": {
                  "description": "The parent stage version for the stage version",
                  "type": "string"
                }
              },
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "tableName",
                "parentStageVersion"
              ],
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___create_oncall_override",
          "description": "Create a temporary override for an OnCall rotation.\n\nThis tool allows you to temporarily replace one or more scheduled on-call members (`targets`) with another set of members (`members`) for a specified time window.\n\nThe override must meet the following rules:\n- The `start` and `end` times must fall entirely within a single on-call shift.\n- The `targets` list must be a subset of the shift's on-call members (unless left empty to override whomever is scheduled).\n- The `members` list must contain valid members from the rotation. If left empty, no one will be assigned (i.e., a coverage gap).\n- Times must follow the format `YYYY-MM-DDThh:mm`.\n\nUsage guidance:\n- To override *whoever is currently scheduled* with specific members, leave `targets` empty and provide `members`.\n- To clear the next on-call assignment (i.e., assign no one), leave `members` empty.\n\nExample:\n```json\n{\n  \"teamName\": \"ft-itc\",\n  \"rotationName\": \"ft-itc-primary\",\n  \"targets\": [alice],\n  \"members\": [\"bob\"],\n  \"start\": \"2025-06-01T09:00\",\n  \"end\": \"2025-06-02T09:00\"\n}\n```",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "teamName": {
                  "type": "string",
                  "description": "The name of the OnCall team where the override should be created."
                },
                "targets": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "List of current on-call members to override. Must be a subset of the on-call members for the current shift. If empty, it will replace all the current oncall members."
                },
                "start": {
                  "type": "string",
                  "description": "Start time (YYYY-MM-DDThh:mm) of the override. Must be now or future, within a single shift.",
                  "pattern": "\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}"
                },
                "members": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "List of replacement members to assign during the override window. They must already be part of the rotation. If empty, it creates a gap (nobody will be oncall)."
                },
                "rotationName": {
                  "type": "string",
                  "description": "The name of the rotation to override. Must match an existing rotation for the given team."
                },
                "end": {
                  "type": "string",
                  "pattern": "\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}",
                  "description": "End time (YYYY-MM-DDThh:mm) of the override. Must not be earlier than the start and must be within the same shift."
                }
              },
              "required": [
                "teamName",
                "rotationName",
                "targets",
                "members",
                "start",
                "end"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_ags_confluence_website",
          "description": "Search for Amazon Games Confluence pages\n\nThis tool allows you to search for content in the Amazon Games Confluence instance.\nYou can search for pages, blog posts, and other content across all spaces or within a specific space.\n\nParameters:\n- query: The search query string\n- page: (Optional) Page number for pagination (default: 1)\n- pageSize: (Optional) Number of results per page (default: 10, max: 50)\n- space: (Optional) Limit search to a specific Confluence space\n\nExamples:\n1. Basic search:\n   { \"query\": \"game server architecture\" }\n\n2. Search with pagination:\n   { \"query\": \"matchmaking\", \"page\": 2, \"pageSize\": 20 }\n\n3. Search in a specific space:\n   { \"query\": \"deployment guide\", \"space\": \"GAMETECH\" }\n\nTips:\n- Use specific technical terms for more precise results\n- For recent content, sort by modification date\n- When looking for documentation, include terms like 'guide', 'documentation', or 'how-to'\n- For architecture documents, include terms like 'architecture', 'design', or 'diagram'\n- If you know the space key, use it to narrow down results",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "query": {
                  "description": "Search query string",
                  "type": "string"
                },
                "pageSize": {
                  "description": "Number of results per page (default: 10, max: 50)",
                  "type": "number"
                },
                "page": {
                  "type": "number",
                  "description": "Page number for pagination (default: 1)"
                },
                "space": {
                  "description": "Limit search to a specific Confluence space",
                  "type": "string"
                }
              },
              "type": "object",
              "required": [
                "query"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pippin_create_artifact",
          "description": "Creates a new artifact within an existing Pippin project",
          "input_schema": {
            "json": {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "content": {
                  "description": "Artifact content",
                  "type": "string"
                },
                "name": {
                  "description": "Artifact name",
                  "type": "string"
                },
                "projectId": {
                  "type": "string",
                  "description": "Project ID"
                },
                "description": {
                  "type": "string",
                  "description": "Artifact description"
                }
              },
              "required": [
                "projectId",
                "name",
                "content"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___sim_remove_tag",
          "description": "Remove a tag from an existing SIM issue.\nThe issue ID can be either the P-number (e.g., P12345678) or the alias (e.g., CFN-12345).\nThe assignee should be a valid kerberos username without the @ANT.AMAZON.COM suffix.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "tag": {
                  "description": "Tag to remove from the issue",
                  "type": "string"
                },
                "issueId": {
                  "type": "string",
                  "description": "Issue ID or alias (e.g., P12345678 or CFN-12345)"
                }
              },
              "type": "object",
              "required": [
                "issueId",
                "tag"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___oncall_compass_get_report",
          "description": "Get the content of the report along with additional metadata.",
          "input_schema": {
            "json": {
              "properties": {
                "reportId": {
                  "description": "ID of the report to retrieve",
                  "type": "string"
                }
              },
              "required": [
                "reportId"
              ],
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pippin_sync_project_to_local",
          "description": "Synchronizes a Pippin project's artifacts to a local directory",
          "input_schema": {
            "json": {
              "properties": {
                "includeMetadata": {
                  "type": "boolean",
                  "description": "Include metadata files (.meta.json)"
                },
                "outputDirectory": {
                  "type": "string",
                  "description": "Local directory to save artifacts"
                },
                "projectId": {
                  "description": "Project ID",
                  "type": "string"
                }
              },
              "type": "object",
              "required": [
                "projectId",
                "outputDirectory"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___overleaf_read_file",
          "description": "Read a file from an Overleaf project with automatic synchronization.\n\nThis tool reads the specified file from an Overleaf project. Before reading,\nit ensures the project is cloned locally and synchronized with the remote repository.\nSupports both text and binary files with proper encoding detection.\n\nExample usage:\n```json\n{\n  \"project_id\": \"507f1f77bcf86cd799439011\",\n  \"file_path\": \"main.tex\"\n}\n```",
          "input_schema": {
            "json": {
              "required": [
                "project_id",
                "file_path"
              ],
              "type": "object",
              "properties": {
                "project_id": {
                  "type": "string",
                  "description": "Project ID containing the file"
                },
                "file_path": {
                  "type": "string",
                  "description": "Path to the file within the project"
                }
              },
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___datacentral_workbench",
          "description": "Access and query data sources in Datacentral Workbench including Andes, Redshift, and Athena. This tool enables database discovery, SQL query execution, and result retrieval.\n\nSUPPORTED OPERATIONS:\n- get_databases: List accessible databases\n- get_users_for_database: Get database users for a specific database\n- create_connection: Establish database connection with user credentials\n- get_catalog: Explore database schema structure\n- execute_query: Run SQL queries against connected database\n- check_query_status: Monitor query execution progress\n- get_query_result_url: Retrieve query results\n\nTYPICAL WORKFLOW:\n1. get_databases → 2. get_users_for_database → 3. create_connection → 4. get_catalog → 5. execute_query → 6. check_query_status → 7. get_query_result_url\n\nCOMMON PARAMETERS:\n- databaseId: Database identifier (string)\n- dbUserId: Database user identifier (string)\n- connectionId: Connection identifier (string)\n- executionId: Query execution identifier (string)\n- sql: SQL query to execute (string)",
          "input_schema": {
            "json": {
              "properties": {
                "executionId": {
                  "description": "Execution ID (required for check_query_status and get_query_result_url operations)",
                  "type": "string"
                },
                "maxRows": {
                  "type": "number",
                  "description": "Maximum number of rows to return when getting query results (default: 1000)"
                },
                "recordLimit": {
                  "type": "number",
                  "description": "Maximum number of records to return (default: 1000)"
                },
                "connectionId": {
                  "description": "Connection ID (required for get_catalog and execute_query operations)",
                  "type": "string"
                },
                "autoCommit": {
                  "type": "boolean",
                  "description": "Whether to automatically commit operations (default: true)"
                },
                "sql": {
                  "type": "string",
                  "description": "SQL query to execute (required for execute_query operation)"
                },
                "isBatch": {
                  "type": "boolean",
                  "description": "Whether to execute SQL statements in one batch (default: false)"
                },
                "schemaPattern": {
                  "description": "Optional schema pattern to filter catalog results (e.g., 'public%')",
                  "type": "string"
                },
                "databaseId": {
                  "description": "Database ID (required for get_users_for_database, create_connection, and get_catalog operations)",
                  "type": "string"
                },
                "dbUserId": {
                  "description": "Database User ID (required for create_connection and get_catalog operations)",
                  "type": "string"
                },
                "downloadAllData": {
                  "type": "boolean",
                  "description": "Whether to download all data or just a preview (default: false)"
                },
                "tablePattern": {
                  "type": "string",
                  "description": "Optional table pattern to filter catalog results (e.g., 'customer%')"
                },
                "operation": {
                  "description": "The operation to perform",
                  "type": "string",
                  "enum": [
                    "get_databases",
                    "get_users_for_database",
                    "create_connection",
                    "get_catalog",
                    "execute_query",
                    "check_query_status",
                    "get_query_result_url"
                  ]
                },
                "timeout": {
                  "type": "number",
                  "description": "Query timeout in milliseconds (default: 60000)"
                },
                "checkSyntaxEnabled": {
                  "description": "Whether to validate query syntax before execution (default: true)",
                  "type": "boolean"
                }
              },
              "additionalProperties": false,
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "required": [
                "operation"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___pippin_update_project",
          "description": "Updates an existing Pippin design project's details",
          "input_schema": {
            "json": {
              "required": [
                "projectId"
              ],
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "projectId": {
                  "description": "Project ID",
                  "type": "string"
                },
                "description": {
                  "description": "Updated project description",
                  "type": "string"
                },
                "requirements": {
                  "type": "string",
                  "description": "Updated project requirements"
                },
                "status": {
                  "description": "Updated project status",
                  "type": "string"
                },
                "name": {
                  "description": "Updated project name",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___cradle_get_job_run_output",
          "description": "Get the output location for a specific Cradle job run.",
          "input_schema": {
            "json": {
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "type": "object",
              "properties": {
                "profileId": {
                  "type": "string",
                  "description": "UUID of the job profile"
                },
                "jobRunId": {
                  "description": "ID of the job run",
                  "type": "string"
                },
                "jobId": {
                  "type": "string",
                  "description": "UUID of the job"
                }
              },
              "required": [
                "profileId",
                "jobId",
                "jobRunId"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___lookup_user_coding_activity_summary",
          "description": "Looks up coding activity summary for a given user by their user login/alias",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "alias"
              ],
              "additionalProperties": false,
              "$schema": "http://json-schema.org/draft-07/schema#",
              "properties": {
                "alias": {
                  "description": "Alias or login for the user to look up",
                  "type": "string"
                },
                "start_time": {
                  "type": "string",
                  "description": "Optional start date in YYYY-MM-DD format"
                },
                "end_time": {
                  "type": "string",
                  "description": "Optional end date in YYYY-MM-DD format"
                }
              }
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "amzn_mcp___search_internal_issues",
          "description": "Search internal issues from https://i.amazon.com/.\nIssues generally are used to manage Amazon's internal development efforts, this includes reporting of bugs, \nrequest for features, roadmaps, managed tasks for Agile development (ex. Sprint, Kanban board tasks).\n\n\nSome value query examples:\n\n* keyword only: Mirai \n\n* keyword AND status: (Mirai team)+status:(Open)\n\n* requested by user: requester:(sshli)\n\n* assigned to user: assignee:(sshli)\n",
          "input_schema": {
            "json": {
              "type": "object",
              "$schema": "http://json-schema.org/draft-07/schema#",
              "additionalProperties": false,
              "properties": {
                "query": {
                  "type": "string",
                  "description": "Search query for internal issues"
                }
              },
              "required": [
                "query"
              ]
            }
          }
        }
      }
    ],
    "native___": [
      {
        "ToolSpecification": {
          "name": "report_issue",
          "description": "Opens the browser to a pre-filled gh (GitHub) issue template to report chat issues, bugs, or feature requests. Pre-filled information includes the conversation transcript, chat context, and chat request IDs from the service.",
          "input_schema": {
            "json": {
              "type": "object",
              "properties": {
                "steps_to_reproduce": {
                  "type": "string",
                  "description": "Optional: Previous user chat requests or steps that were taken that may have resulted in the issue or error response."
                },
                "title": {
                  "description": "The title of the GitHub issue.",
                  "type": "string"
                },
                "expected_behavior": {
                  "description": "Optional: The expected chat behavior or action that did not happen.",
                  "type": "string"
                },
                "actual_behavior": {
                  "type": "string",
                  "description": "Optional: The actual chat behavior that happened and demonstrates the issue or lack of a feature."
                }
              },
              "required": [
                "title"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "fs_write",
          "description": "A tool for creating and editing files\n * The `create` command will override the file at `path` if it already exists as a file, and otherwise create a new file\n * The `append` command will add content to the end of an existing file, automatically adding a newline if the file doesn't end with one. The file must exist.\n Notes for using the `str_replace` command:\n * The `old_str` parameter should match EXACTLY one or more consecutive lines from the original file. Be mindful of whitespaces!\n * If the `old_str` parameter is not unique in the file, the replacement will not be performed. Make sure to include enough context in `old_str` to make it unique\n * The `new_str` parameter should contain the edited lines that should replace the `old_str`.",
          "input_schema": {
            "json": {
              "properties": {
                "summary": {
                  "type": "string",
                  "description": "A brief explanation of what the file change does or why it's being made."
                },
                "command": {
                  "type": "string",
                  "enum": [
                    "create",
                    "str_replace",
                    "insert",
                    "append"
                  ],
                  "description": "The commands to run. Allowed options are: `create`, `str_replace`, `insert`, `append`."
                },
                "new_str": {
                  "description": "Required parameter of `str_replace` command containing the new string. Required parameter of `insert` command containing the string to insert. Required parameter of `append` command containing the content to append to the file.",
                  "type": "string"
                },
                "file_text": {
                  "type": "string",
                  "description": "Required parameter of `create` command, with the content of the file to be created."
                },
                "insert_line": {
                  "description": "Required parameter of `insert` command. The `new_str` will be inserted AFTER the line `insert_line` of `path`.",
                  "type": "integer"
                },
                "old_str": {
                  "description": "Required parameter of `str_replace` command containing the string in `path` to replace.",
                  "type": "string"
                },
                "path": {
                  "description": "Absolute path to file or directory, e.g. `/repo/file.py` or `/repo`.",
                  "type": "string"
                }
              },
              "type": "object",
              "required": [
                "command",
                "path"
              ]
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "execute_bash",
          "description": "Execute the specified bash command.",
          "input_schema": {
            "json": {
              "properties": {
                "summary": {
                  "type": "string",
                  "description": "A brief explanation of what the command does"
                },
                "command": {
                  "type": "string",
                  "description": "Bash command to execute"
                }
              },
              "required": [
                "command"
              ],
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "dummy",
          "description": "This is a dummy tool. If you are seeing this that means the tool associated with this tool call is not in the list of available tools. This could be because a wrong tool name was supplied or the list of tools has changed since the conversation has started. Do not show this when user asks you to list tools.",
          "input_schema": {
            "json": {
              "required": [],
              "properties": {},
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "fs_read",
          "description": "Tool for reading files (for example, `cat -n`),  directories (for example, `ls -la`) and images. If user has supplied paths that appear to be leading to images, you should use this tool right away using Image mode. The behavior of this tool is determined by the `mode` parameter. The available modes are:\n- line: Show lines in a file, given by an optional `start_line` and optional `end_line`.\n- directory: List directory contents. Content is returned in the \"long format\" of ls (that is, `ls -la`).\n- search: Search for a pattern in a file. The pattern is a string. The matching is case insensitive.\n\nExample Usage:\n1. Read all lines from a file: command=\"line\", path=\"/path/to/file.txt\"\n2. Read the last 5 lines from a file: command=\"line\", path=\"/path/to/file.txt\", start_line=-5\n3. List the files in the home directory: command=\"line\", path=\"~\"\n4. Recursively list files in a directory to a max depth of 2: command=\"line\", path=\"/path/to/directory\", depth=2\n5. Search for all instances of \"test\" in a file: command=\"search\", path=\"/path/to/file.txt\", pattern=\"test\"\n",
          "input_schema": {
            "json": {
              "required": [
                "path",
                "mode"
              ],
              "properties": {
                "depth": {
                  "description": "Depth of a recursive directory listing (optional, for Directory mode)",
                  "type": "integer",
                  "default": 0
                },
                "path": {
                  "description": "Path to the file or directory. The path should be absolute, or otherwise start with ~ for the user's home.",
                  "type": "string"
                },
                "mode": {
                  "description": "The mode to run in: `Line`, `Directory`, `Search`. `Line` and `Search` are only for text files, and `Directory` is only for directories. `Image` is for image files, in this mode `image_paths` is required.",
                  "enum": [
                    "Line",
                    "Directory",
                    "Search",
                    "Image"
                  ],
                  "type": "string"
                },
                "start_line": {
                  "description": "Starting line number (optional, for Line mode). A negative index represents a line number starting from the end of the file.",
                  "type": "integer",
                  "default": 1
                },
                "pattern": {
                  "type": "string",
                  "description": "Pattern to search for (required, for Search mode). Case insensitive. The pattern matching is performed per line."
                },
                "context_lines": {
                  "default": 2,
                  "description": "Number of context lines around search results (optional, for Search mode)",
                  "type": "integer"
                },
                "image_paths": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "List of paths to the images. This is currently supported by the Image mode."
                },
                "end_line": {
                  "type": "integer",
                  "description": "Ending line number (optional, for Line mode). A negative index represents a line number starting from the end of the file.",
                  "default": -1
                }
              },
              "type": "object"
            }
          }
        }
      },
      {
        "ToolSpecification": {
          "name": "use_aws",
          "description": "Make an AWS CLI api call with the specified service, operation, and parameters. All arguments MUST conform to the AWS CLI specification. Should the output of the invocation indicate a malformed command, invoke help to obtain the the correct command.",
          "input_schema": {
            "json": {
              "type": "object",
              "required": [
                "region",
                "service_name",
                "operation_name",
                "label"
              ],
              "properties": {
                "label": {
                  "type": "string",
                  "description": "Human readable description of the api that is being called."
                },
                "parameters": {
                  "description": "The parameters for the operation. The parameter keys MUST conform to the AWS CLI specification. You should prefer to use JSON Syntax over shorthand syntax wherever possible. For parameters that are booleans, prioritize using flags with no value. Denote these flags with flag names as key and an empty string as their value. You should also prefer kebab case.",
                  "type": "object"
                },
                "operation_name": {
                  "type": "string",
                  "description": "The name of the operation to perform."
                },
                "service_name": {
                  "description": "The name of the AWS service. If you want to query s3, you should use s3api if possible.",
                  "type": "string"
                },
                "region": {
                  "description": "Region name for calling the operation on AWS.",
                  "type": "string"
                },
                "profile_name": {
                  "type": "string",
                  "description": "Optional: AWS profile name to use from ~/.aws/credentials. Defaults to default profile if not specified."
                }
              }
            }
          }
        }
      }
    ]
  },
  "context_manager": {
    "max_context_files_size": 150000,
    "global_config": {
      "paths": [
        ".amazonq/rules/**/*.md",
        "README.md",
        "AmazonQ.md",
        "/Users/orrb/workplace/q/src/AmazonBuilderGenAIPowerUsersQContext/AmazonQ.md",
        "/Users/orrb/workplace/q/src/AmazonBuilderGenAIPowerUsersQContext/rules/**/*.md",
        "src/*/.amazonq/rules/**/*.md",
        "src/*/AmazonQ.md",
        "src/*/README.md"
      ],
      "hooks": {}
    },
    "current_profile": "default",
    "profile_config": {
      "paths": [],
      "hooks": {}
    }
  },
  "context_message_length": 20349,
  "latest_summary": null,
  "model": "CLAUDE_SONNET_4_20250514_V1_0"
}